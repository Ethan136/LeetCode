# LeetCode
[125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)


# Answer
## V1 - 更新 index 機制比較複雜，不是很喜歡（但概念可以看看）
```C

class Solution {
public:
    bool checkAlphaNumeric(char a) {
        char lowcase_a = tolower(a);
        if('a'<= lowcase_a && lowcase_a <= 'z') return true;
        if('0'<= lowcase_a && lowcase_a <= '9') return true;
        return false;
    };

    bool UpdateIndexAndCheckDoNextTerm(string &s, int &IdxFromHead, int &IdxFromTail) {
        while(IdxFromHead < int(s.size()) && !checkAlphaNumeric(s[++IdxFromHead]));
        while(IdxFromTail > 0 && !checkAlphaNumeric(s[--IdxFromTail]));
        return (IdxFromHead < IdxFromTail);
    };

    bool isPalindrome(string s) {
        for(int i = -1, j = s.size(); UpdateIndexAndCheckDoNextTerm(s, i, j); ) {
            if(tolower(s[i]) != tolower(s[j])) return false;
        }
        return true;
    }
};
```
- 注意：**size() 系列都是 unsigned**
	- 如果 size() 和 int 負數做比對，會把 int 轉換成 unsigned，這時候會發生 『-1 < string.size()』 會傳 false
	- 如果 size() 和 int 負數做比對，要把 size() 轉換成 signed -> 使用 『-1 < int(string.size())』可達成需求
- 思維
	- 用一個 func 檢查是否為『英文 or 數字』
	- 用一個 func 更新 index 並且跳過『非英文 and 非數字』
	- 比對的地方單純化，直接當作需要比對的 index 一定是『英文 or 數字』

## V2 - 比較簡單，但使用 Map 做大小寫轉換比較慢
```Cpp
class Solution {
public:
    bool isPalindrome(string s) {
        unordered_map<char, char> charMap;

        // build map for ABC / abc
        for(char ABC = 'A', abc = 'a'; ABC <= 'Z'; ABC++, abc++) {
            charMap[ABC] = abc;
            charMap[abc] = abc;
        }

        // build map for 0 to 9
        for(char numChar = '0'; numChar <= '9'; numChar++) {
            charMap[numChar] = numChar;
        }

        // check the string from both sides
        for(int l = 0, r = (int)(s.size())-1;
                l < r; 
                l++, r--) {

            // move left index until valid alphanumeric
            while(!charMap.count( s[l] ) && l < r) l++;

            // move right index until valid alphanumeric
            while(!charMap.count( s[r] ) && l < r) r--;

            // if all char are parsed and left idx & right idx corss over
            // -> the parsed char are all "non abc char and served as empty"
            if(l >= r) break;

            // compare char
            if(charMap[ s[l] ] != charMap[ s[r] ]) return false;
        }
        return true;
    }
};
```


## V3 - 更簡化，使用 tolower 做大小寫轉換效能較好
### V3.1 - 複習 1st
```Cpp
class Solution {
private:
    bool isAlphaNumeric(char c) {
        if('a' <= tolower(c) && tolower(c) <= 'z') return true;
        if('0' <= c && c <= '9') return true;
        return false;
    }
public:
    bool isPalindrome(string s) {

        // check the string from both sides
        for(int l = 0, r = (int)(s.size())-1;
                l < r; 
                l++, r--) {

            // move left index until valid alphanumeric
            while(!isAlphaNumeric( s[l] ) && l < r) l++;

            // move right index until valid alphanumeric
            while(!isAlphaNumeric( s[r] ) && l < r) r--;

            // if all char are parsed and left idx & right idx corss over
            // -> the parsed char are all "non abc char and served as empty"
            if(l >= r) break;

            // compare char
            if(tolower( s[l] ) != tolower( s[r] )) return false;
        }
        return true;
    }
};
```

### V3.2 - 複習 2nd
```Cpp
class Solution {
public:
    bool isPalindrome(string s) {

        auto convertAlphaNumericToLower = [](char &c) {
            if(('A' <= c) && (c <= 'Z')) {
                c = 'a' + (c - 'A');
                return true;
            }

            if(('a' <= c) && (c <= 'z')) {
                return true;
            }
            
            if(('0' <= c) && (c <= '9')) {
                return true;
            }

            return false;
        };

        for(int i = 0, j = s.size()-1; i < j; i++, j--) {

            // parse s[i] until one alphabet numberic
            while((i < s.size()) && !convertAlphaNumericToLower(s[i])) i++;

            // consecutive invalid number to end
            if(i >= s.size()) return true;

            // parse s[j] until one alphabet numberic
            while((j >= 0) && !convertAlphaNumericToLower(s[j])) j--;

            // consecutive invalid number from start
            if(j < 0) return true;

            // compare valid char from both sides
            if(s[i] != s[j]) return false;
        }
        return true;
    }
};
```

## V4 - 轉換出新字串，再檢查字串（速度比較慢）
```Cpp
class Solution {
public:
    bool isPalindrome(string s) {
        string s1;
        for(char c : s) {
            bool upperAlphabet = ('A' <= c) && (c <= 'Z');
            bool lowerAlphabet = ('a' <= c) && (c <= 'z');
            bool numeric = ('0' <= c) && (c <= '9');
            if(!upperAlphabet && !lowerAlphabet && !numeric) continue;

            if(upperAlphabet) c = 'a' + (c - 'A');
            s1 += c;
        }
        if(s1.empty()) return true;

        for(int i = 0, j = s1.size()-1; i < j; i++, j--) {
            if(s1[i] != s1[j]) return false;
        }
        return true;
    }
};
```