# LeetCode
[42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

# 示意圖
![[42. Trapping Rain Water - Plot.excalidraw]]

# Answer
## V1 - two pointer 兩端點視為「已經處理完畢的 index」
- l / r 在一開始是完全邊界，不可能儲水，所以 initial condition 設定後，就可以視為「處理完畢」
- 這時候 **要先更新 l / r，再計算面積**，並且 **終止條件為 l < r**
```Cpp
class Solution {
public:
    int trap(vector<int>& height) {

        // init result
        int result = 0;

        // start check from both sides of wall
        auto leftWall = height.begin(), rightWall = height.end()-1;
        int leftMaxHeight = *leftWall, rightMaxHeight = *rightWall;

        // move the side with the "shorter wall"
        // (the water could be trapped is constrained by the shorter side of wall)
        while( leftWall < rightWall ) {
            int AreaInc = 0;
            if(*leftWall < *rightWall) {
                leftWall++;
                AreaInc = max((leftMaxHeight - *leftWall), 0);
                if(AreaInc == 0) leftMaxHeight = *leftWall;
            }
            else {
                rightWall--;
                AreaInc = max((rightMaxHeight - *rightWall), 0);
                if(AreaInc == 0) rightMaxHeight = *rightWall;
            }
            result += AreaInc;
        }

        // return the trapped area
        return result;
    }
};
```
- 從兩側開始往中間檢查
- 雨水承載量受到『比較矮的那側所限制』 -> **所以比較矮的那測，比較有機會往內檢查後，檢查到更矮的牆並且 trap 到雨水**
- *目標：矮還要更矮*
	- 當矮的那側往內檢查：檢查到更矮的牆 -> 低下去的部分可以容納雨水 -> 更新容納量
	- 當矮的那測往內檢查：檢查到更高的牆 -> 搞出來的部分無法容納雨水 -> 不更新容納量，但更新『那一側的最大牆高』

## V2 - two pointer 兩端點視為「尚未處理的 index」
- l / r 再一開始雖然是完全邊界，但仍然拿來算看看積水面積（為 0）
- 這時候 **要先計算面積，再更新 l / r**，並且 **終止條件為 l <= r** -> **這樣最後 l / r 重合的情況下，才會去計算「最後一格的積水」**
```Cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2) return 0;

        int waterTrap = 0;
        for(int l = 0, r = height.size()-1, leftWallHeight = height[l], rightWallHeight = height[r];
                l <= r; ) {

            // calculate the water from left side if left wall is lower
            if(leftWallHeight < rightWallHeight) {
                if(height[l] < leftWallHeight) {
                    waterTrap += (leftWallHeight - height[l]) * 1;
                }
                else {
                    leftWallHeight = height[l];
                }
                l++;
            }
            // otherwise, calculate the water from the righ side
            else {
                if(height[r] < rightWallHeight) {
                    waterTrap += (rightWallHeight - height[r]) * 1;
                }
                else {
                    rightWallHeight = height[r];
                }
                r--;
            }
        }
        return waterTrap;
    }
};
```