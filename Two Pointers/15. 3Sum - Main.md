# LeetCode
[15. 3Sum](https://leetcode.com/problems/3sum/)

# Answer：把 Sort 過的 Vector 視爲『最左檢測元素』+『檢測元素右側 Vector 做 2Sum』 (正解)
### V1 - 最一開始的寫法
```Cpp
class Solution {
public:
    inline void UpdateLeftIndex(vector<int>& nums, int& l) {
        l++;
        while( l < nums.size() && nums[l] == nums[l-1]) l++;
    };

    inline void UpdateTwoHeadIndex(vector<int>& nums, int updateDir, int& m, int& r) {
        if(updateDir >= 0) {
            m++;
            while( m < r && nums[m] == nums[m-1] ) m++;
        }
        if(updateDir <= 0) {
            r--;
            while( m < r && nums[r] == nums[r+1] ) r--;
        }
    };

    vector<vector<int>> threeSum(vector<int>& nums) {
        // sort vector in order to use two pointer
        sort(nums.begin(), nums.end());

        // initiate the result
        vector<vector<int>> result;

        // split the array to element[n] [later element two sum problem]
        for(int l = 0; l < nums.size(); UpdateLeftIndex(nums, l) ) {

            // two sum problem with target = residual
            int residual = -nums[l];
            for(int updateDir = 0, m = l+1, r = nums.size()-1;
                m < r; UpdateTwoHeadIndex(nums, updateDir, m, r)){

                // check match
                int twoSum = nums[m] + nums[r];
                if(twoSum == residual) {
                    result.push_back({nums[l], nums[m], nums[r]});
                    updateDir = 0;
                }
                // if less than target
                else if(twoSum < residual) {
                    updateDir = 1;
                }
                // if greater than target
                else {
                    updateDir = -1;
                }
            }            
        }
        return result;
    }
};
```
- Three Sum -> 拆成『某一個 element』+『這個元素右邊的 Array Part 處理 2Sum』
- 因為回傳的 result 不能有相同組合 -> 先把 vector 進行 sort，再針對 sort 後的 vector 進行處理
	- 相同數值的 element 在 sort 後排在一起 -> 這時候更新 index，可以一次往後跳過相同的數值內容
- **複雜的 index update -> 可以改成在 function 裡面做 update，這樣 coding style 比較漂亮**

### V2 - index 更新機制簡化
```Cpp
class Solution {
public:
    bool AddVecElmtIfDiffFromLastOne(vector<vector<int>> &threeSumResultGroup, vector<int> &NewResult) {
		for(auto result : threeSumResultGroup) {
			if (result == NewResult) return false;
		}
		threeSumResultGroup.push_back(NewResult);
		return true;
	}

    vector<vector<int>> threeSum(vector<int>& nums) {
        // sort vector in order to use two pointer
        sort(nums.begin(), nums.end());

        // initiate the result
        vector<vector<int>> result;

        // split the array to element[n] [later element two sum problem]
        for(int l = 0; l < nums.size(); l++ ) {

            // two sum problem with target = residual
            int residual = -nums[l];
            for(int m = l+1, r = nums.size()-1; m < r; ){

                // check match
                int twoSum = nums[m] + nums[r];
                if(twoSum == residual) {
					AddVecElmtIfDiffFromLastOne(result, {nums[l], nums[m++], nums[r--]});
					continue;
                }

                // if less than target
                if(twoSum < residual) m++;
                // if greater than target
                else r--;

            }
        }
        return result;
    }
};
```
- **Vector 可以使用 a_vect == b_vect 來檢查是否相等
- 這個解法速度很慢，因爲每次 add result 都要檢查先前全部的 result 內容
- 這個解法也是研究用
- **備註**
	- 無法使用 unordered_set / unordered_map 搭配 vector 作爲 key -> 會無法 compile


### V3 - 複習1st時候的寫法（最簡化）
```Cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {

        sort(nums.begin(), nums.end());

        vector<vector<int>> result;
        for(int i = 0; i < nums.size(); i++) {

            // to prevent duplicated three sum
            if(i > 0 && nums[i] == nums[i-1]) continue;

            // calculate the non-duplicated two sum by two pointers
            int twoSumTarget = -nums[i];
            for(int l = i+1, r = (int)(nums.size()) - 1;
                    l < r;) {

                // two sum                
                int twoSum = nums[l] + nums[r];

                // two sum equals to targer
                if(twoSum == twoSumTarget) {
                    result.push_back({nums[i], nums[l], nums[r]});

                    // move l to the last duplicated num
                    while( (l+1 < nums.size()) && (nums[l+1] == nums[l]) ) l++;

                    // move r to the last duplicated num
                    while( (r > 0) && (nums[r-1] == nums[r]) ) r--;

                    // update l & r
                    l++, r--;
                }
                // larget than target -> reduce sum
                else if(twoSum > twoSumTarget) {
                    r--;
                }
                // less than target -> increase sum
                else {
                    l++;
                }
            }
        }

        return result;
    }
};
```
- 避免重複
	- **原本的數列要做排序**
	- **原本的數列檢查 three sum 的時候， index 更新時，要避免 num[i] = num[i-1] 的情況**
- 特別注意
	- **Two pointer 有找到解的時候 -> 這時 l / r 都要更新**

### V4 - 複習2nd時候的寫法（語意更明確）
- **避免使用相同solution 放到 result 的要點：適當更新 check index 確保每次更新後，不會有重複 solution 出現**
	- target of two sum 必須每次不一樣
	- 內層一旦 two sum match -> 要確保 update l / r 之後的數值不一樣
```Cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        vector<vector<int>> result;
        for(int i = 0, numCnt = 1; i < nums.size(); i += numCnt) {

            // i should always use the different num
            numCnt = 1;
            while(((i+numCnt) < nums.size()) && (nums[i+numCnt] == nums[i])) numCnt++;

            // two sum by two pointer with duplicated num
            int targetNum = -nums[i];
            for(int l = i+1, r = nums.size()-1; l < r; ) {
                int twoSum = nums[l] + nums[r];
                bool updateL = false, updateR = false;

                if(twoSum == targetNum) {
                    result.push_back({nums[i], nums[l], nums[r]});
                    updateL = true;
                    updateR = true;
                }
                else if(twoSum > targetNum) {
                    updateR = true;
                }
                else {
                    updateL = true;
                }

                if(updateL) {
                    l++;
                    while((l < nums.size()) && (nums[l] == nums[l-1])) l++;
                }
                    
                if(updateR) {
                    r--;
                    while((r >= 0) && (nums[r] == nums[r+1])) r--;
                }
            }
        }

        return result;
    }
};
```

# Answer：把 vector 整理成 map\<key = 數值, value = 出現次數\> (研究用)
```Cpp
class Solution {
public:
    void PopBackElementFromVector(vector<int>& vect, int N) {
        for(int i = 0; vect.size() && (i < N); i++) vect.pop_back();
    }
	void AddorElementToVector(vector<int>& vect,int N, int element) {
		for(int i = 0; i < N; i++) vect.push_back(element);
	};

	bool CheckNSum(map<int,int>& numMap, map<int,int>::iterator startPairItr,
					int N, int Target, 
					vector<vector<int>>& result, vector<int>& trasverseRec) {

		// iterate to the end -> cant check anymore
		map<int,int>::iterator pivotCheckItr = startPairItr;
		if(pivotCheckItr == numMap.end()) {
			return false;
		}

		// check direction1
		int maxChkRepeatNum = min(pivotCheckItr->second, N);

		for(int i = 1; i <= maxChkRepeatNum; i++) {
			// use i number in total N
			int N_Remain = N - i;

			// update the remained target after addup (i * Value)
			int TargetRemain = Target - (i * (pivotCheckItr->first));
			// add the repeated use number to trasverse record
			AddorElementToVector(trasverseRec, i, pivotCheckItr->first);

			// if remained times = 0 -> check remained target = 0 if matched
			if(N_Remain == 0 && TargetRemain == 0) {
				result.push_back(trasverseRec);
				PopBackElementFromVector(trasverseRec, i);
				return true;
			}

			// if remained times = 0 -> check remained target != 0 if not matched
			if(N_Remain == 0 && TargetRemain != 0) {
				PopBackElementFromVector(trasverseRec, i);
				return false;
			}

			// if remained N != 0 -> check next pair in Direction2
			map<int,int>::iterator nextCheckItr = pivotCheckItr;
			while(++nextCheckItr != numMap.end()) {
				// if current pair check fail
				if(CheckNSum(numMap, nextCheckItr, N_Remain, TargetRemain, result, trasverseRec) == false) {
					continue;
				}
			}

			PopBackElementFromVector(trasverseRec, i);
		}
		return false;
	};

	vector<vector<int>> threeSum(vector<int>& nums) {
		map<int,int> numMap;
		for(int num : nums) {
			if(numMap.count(num)) numMap[num]++;
			else numMap[num] = 1;
		}

		int N = 3, Target = 0;
		vector<vector<int>> result;
		for(auto pairItr = numMap.begin(); pairItr != numMap.end(); pairItr++) {
			vector<int> trasverseRec;
			CheckNSum(numMap, pairItr, N, 0, result, trasverseRec);
		}

		return result;
	}
};
```
**這個做法單純是研究用，但算法複雜度很高 O(N^3)**
- vectory 整理成 map -> 本身要做 sort O(Nlog(N))
	- num_A - cnt_A
	- num_B - cnt_B
	- num_C - cnt_C
- 最外層先選定一個起始 pair 開始檢查 -> O(N)
	- 內層分兩個方向檢索
		- 方向1：單一數值『重複次數』 -> 選定某個 num_K 後，依序檢查出現 N to 1 次 -> O(N)
		- 方向2：不同數值『依照 map 裏面的 pair 方向依序檢查』 -> 每次只檢查『往後的 pair，不往前檢查 pair』 -> O(N)
- 執行機制：遞迴呼叫
	- (0) 中止條件
		- first pair 是在 map 尾端 -> 中止情況：回傳 false

	- (1) 從 first pair 開始，先找方向 1 -> 選定這個 pair 裏面的數值使用 N to 1 次
		- (1-a) 相同數值選用 k 次就湊滿總次數 N -> 中止情況：檢查是否湊到 target num
		- (1-b) 相同數值沒這麼多重複次數可以湊到 k -> 不繼續檢查 k to N -> 檢查回到 (1) 檢查 (first pair+1)
		- (1-c) 相同數值選用 k 次沒湊滿總次數 N -> 繼續檢查方向2

		- (2) 選定後檢查方向 2 -> 從 pair+1 往後檢查
			- > (pair+1) 檢查的時候，執行 recursive func call -> 回到 (1)

**其他注意事項**
- 輸出 debug log 會大幅降低效能， 可能造成 leetcode timeout
- 執行時間大約在『快要timeout的地方』 -> *有時候 timeout 有時候不會*


# Answer：先找出 unique two sum，再找出 unique three sum (邏輯 OK 但速度很慢)
```Cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {

        // for all the two sum combinations
        unordered_map<int, vector<pair<int, int>>> twoSumMapToIdx;

        // calculate unique two sum combinations
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++) {

            // to make sure i < j -> j start from i + 1
            for(int j = i+1; j < nums.size(); j++) {

                // add the non-duplicated result to two sum
                twoSumMapToIdx[nums[i] + nums[j]].push_back({i, j});

                // to prevent the duplicated two sum combination -> skip the same num after num[j]
                while(j+1 < nums.size() && nums[j] == nums[j+1]) j++;
            }

            // to prevent the duplicated two sum combination -> skip the same num after num[i]
            while(i+1 < nums.size() && nums[i] == nums[i+1]) i++;
        }

        // to fast map the last index of certain one-sum
        unordered_map<int, int> lastIdxOfNumMap;
        for(int k = 0; k < nums.size(); k++) lastIdxOfNumMap[nums[k]] = k;

        // fetch the non-duplicated result nums[i], nums[j], nums[k] | i < j < k
        vector<vector<int>> result;
        for(auto &[towSum, SumIdxVec] : twoSumMapToIdx) {

            // if there's no one-sum to yield zero three some by combining with current two sum
            if(lastIdxOfNumMap.count( -towSum ) == false) continue;

            int k = lastIdxOfNumMap[ -towSum ];
            for(auto [i, j] : SumIdxVec) {

                // to make sure the result i < j < k
                if(k <= i || k <= j) continue;

                // add to result
                result.push_back({nums[i], nums[j], nums[k]});
            }
        }

        return result;
    }
};
```
- 先找出每一個 two sum 的 unique combination num[i], num[j]
	- {num[i], num[j]} 一定不重複
	- i 一定小於 j
	- i 和 j 都是越小越好
- 再針對上面 two sum 的 unique combination，看是否有可能找出 three some = 0
	- nums[k] 代表「nums 裡面某個數值的最後一個index 為 k」，比如說 0, 1, 1, 1, 1, 2，則 nums[k] = 1 的時候，k 為 4
	- 這樣可以搭配上面的 two sum unique combination: {nums[i], nums[j]}，找出 nums[k]，確保三者相加等於 0，而且 i < k && j < k
- **使用很多 map，所以速度很慢**


# Answer：2nd 複習 - Backtracking Recursive 通解（會 timeout 但概念很重要）
- **數字量很大的時候，建立 map 會花很多時間**
- **但這個作法是 N-Sum 通用，很方便**
```Cpp
class Solution {
private:

    void calcSumWithNumCnt(int targetSum, vector<int>& sortedNums, int checkStartIdx, int numCanUse, auto &numToCnt, auto &curResult, auto &resultSet ) {
	    // not expected to be here
        if(numCanUse < 0) return;

		// if there's no num can be used -> check whether target sum = 0
        if(numCanUse == 0) {
            if(targetSum == 0) resultSet.push_back(curResult);
            return;
        }

		// check if start index is valid
		if(checkStartIdx >= sortedNums.size()) return;

		// check if targetSum is out of [minPossible, maxPossible]
		if(targetSum < (sortedNums[checkStartIdx] * numCanUse)) return;
		if(targetSum > (sortedNums.back() * numCanUse)) return;

		// try from start index and deal with duplicated num
        for(int i = checkStartIdx, numDupCnt = 1; i < sortedNums.size(); i += numDupCnt) {
            if((targetSum < 0) && (sortedNums[i] >= 0)) break;
                
            numDupCnt = numToCnt[sortedNums[i]];
            int curNumMaxUseCnt = min(numDupCnt, numCanUse);
            for(int useCnt = 1; useCnt <= curNumMaxUseCnt; useCnt++) {
                for(int n = useCnt; n > 0; n--) curResult.push_back(sortedNums[i]);
                calcSumWithNumCnt(targetSum - useCnt*sortedNums[i], sortedNums, i + numDupCnt, numCanUse - useCnt, numToCnt, curResult, resultSet);
                for(int n = useCnt; n > 0; n--) curResult.pop_back();
            }
        }
    }

public:
    vector<vector<int>> threeSum(vector<int>& nums) {

        sort(nums.begin(), nums.end());

        unordered_map<int, int> numToCnt;
        for(int i = 0; i < nums.size(); i++) numToCnt[ nums[i] ] += 1;

        vector<int> curResult;
        vector<vector<int>> resultSet;
        calcSumWithNumCnt(0, nums, 0, 3, numToCnt, curResult, resultSet);

        return resultSet;

    }
};
```