# LeetCode
[15. 3Sum](https://leetcode.com/problems/3sum/)

# Answer
```Cpp
class Solution {
public:
    inline void UpdateLeftIndex(vector<int>& nums, int& l) {
        l++;
        while( l < nums.size() && nums[l] == nums[l-1]) l++;
    };

    inline void UpdateTwoHeadIndex(vector<int>& nums, int updateDir, int& m, int& r) {
        if(updateDir >= 0) {
            m++;
            while( m < r && nums[m] == nums[m-1] ) m++;
        }
        if(updateDir <= 0) {
            r--;
            while( m < r && nums[r] == nums[r+1] ) r--;
        }
    };

    vector<vector<int>> threeSum(vector<int>& nums) {
        // sort vector in order to use two pointer
        sort(nums.begin(), nums.end());

        // initiate the result
        vector<vector<int>> result;

        // split the array to element[n] [later element two sum problem]
        for(int l = 0; l < nums.size(); UpdateLeftIndex(nums, l) ) {

            // two sum problem with target = residual
            int residual = -nums[l];
            for(int updateDir = 0, m = l+1, r = nums.size()-1;
                m < r; UpdateTwoHeadIndex(nums, updateDir, m, r)){

                // check match
                int twoSum = nums[m] + nums[r];
                if(twoSum == residual) {
                    result.push_back({nums[l], nums[m], nums[r]});
                    updateDir = 0;
                }
                // if less than target
                else if(twoSum < residual) {
                    updateDir = 1;
                }
                // if greater than target
                else {
                    updateDir = -1;
                }
            }            
        }
        return result;
    }
};
```
- Three Sum -> 拆成『某一個 element』+『這個元素右邊的 Array Part 處理 2Sum』
- 因為回傳的 result 不能有相同組合 -> 先把 vector 進行 sort，再針對 sort 後的 vector 進行處理
	- 相同數值的 element 在 sort 後排在一起 -> 這時候更新 index，可以一次往後跳過相同的數值內容
- **複雜的 index update -> 可以改成在 function 裡面做 update，這樣 coding style 比較漂亮**