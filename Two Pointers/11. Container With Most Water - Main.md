# LeetCode
[11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

# Answer
- **注意：更新 two pointer 的時候，是「如果 left side > H」，則「right side--」，不能用「left side >= H」，否則如果 left side 是矮的那一邊，則會直接把高的另一邊進行更新**
## V1
```Cpp
class Solution {
public:

    int maxArea(vector<int>& height) {
        int result = 0;
        for(int l = 0, r = height.size()-1;
            l < r; ) {

            // update max area
            int curArea = min(height[l] , height[r]) * (r-l);
            result = max(curArea, result);

            // update index
            if(height[l] < height[r]) l++;
            else r--;
        }
        return result;
    }
};
```
- **Two Pointer 處理的目標，不一定要是Sorted Array：只要可以從兩端逼近處理並且符合某個求解邏輯，即可使用**
- 從最兩側開始檢查體積
	- 並且每次都更新『高度比較矮的那一側』 -> *雖然更新 index 會減少底面積*
	- **但是更新『左側 wall』和『右側 wall』底面積損失的量一樣**
	- **所以每次更新，都更新『比較矮的那個 wall』

## V2：複習1st
```Cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        if(height.size() < 2) return 0;

        int maxContain = 0;
        for(int l = 0, r = height.size()-1;
                l < r; ) {

            int H = min(height[l], height[r]);
            int W = r - l;

            maxContain = max(maxContain, W * H);

            // if left side is higher -> move right side
            if(height[l] > H) r--;
            // if right side is higher -> move left side
            else l++;
        }

        return maxContain;
    }
};
```

## V3：複習2nd
```Cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int maxAreaInRange = 0;
        for(int l = 0, r = height.size()-1; l < r; ) {
            int area = min(height[l], height[r]) * (r-l);
            maxAreaInRange = max(maxAreaInRange, area);

            if(height[l] > height[r]) r--;
            else l++;
        }
        return maxAreaInRange;
    }
};
```