---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[684. Redundant Connection](https://leetcode.com/problems/redundant-connection/)

# Concept
- 只拿掉一個 edge 就能讓圖形不是封閉的 -> **node num 一定等於 edge num + 1**
- 假設每個 node 一開始都獨立是一個 component -> component[i] 對應 node i
- 檢查每個 edge，把兩端的 node 所屬的 component 合併
-  -> **合併方式為 component[i] 連結到 node j -> 意義為 node i 所屬的 component[i] 的 root 位在 node j**
- **這個方式就是 union find**

- **注意： union find 要把 root 連到另一個 root，不能直接連 non-root node**

# Answer：Union Find + Component Merge
## V1：basic search component root
```Cpp
class Solution {
private:
    int findRootNodeOfComponent(auto &componentBelongToNode, int componentIdx, int &componentNodeNum) {
        componentNodeNum = 1;

        while(componentBelongToNode[componentIdx] != componentIdx) {
            componentNodeNum++;

            int node = componentBelongToNode[componentIdx];
            componentIdx = node;
        }
        return componentIdx;
    }

public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int maxNodeVal = edges.size() + 1;
        vector<int> componentBelongToNode(maxNodeVal);
        for(int i = 0; i < maxNodeVal; i++) componentBelongToNode[i] = i;

        for(auto &edge : edges) {

            int compNodeNum0 = 0;
            int root0 = findRootNodeOfComponent(componentBelongToNode, edge[0], compNodeNum0);

            int compNodeNum1 = 0;
            int root1 = findRootNodeOfComponent(componentBelongToNode, edge[1], compNodeNum1);

            if(root0 == root1) return edge;

            // merge component to the one with less node
            if(compNodeNum0 < compNodeNum1) componentBelongToNode[root0] = root1;
            else componentBelongToNode[root1] = root0;
        }

        return {};
    }
};
``` 

## V2：search component root + compress link nodes to root
```Cpp
class Solution {
private:
    int travCompressToFindRootNodeOfComponent(auto &componentBelongToNode, int componentIdx, int &componentNodeNum) {
        // all component at least has one node
        componentNodeNum = 1;

        // find root node
        int travCompIdx = componentIdx;
        while(componentBelongToNode[travCompIdx] != travCompIdx) {
            componentNodeNum++;

            int node = componentBelongToNode[travCompIdx];
            travCompIdx = node;
        }
        int rootNode = travCompIdx;

        // link all component node directly to root
        travCompIdx = componentIdx;
        while(componentBelongToNode[travCompIdx] != travCompIdx) {
            int nextTravNode = componentBelongToNode[travCompIdx];

            componentBelongToNode[travCompIdx] = rootNode;

            travCompIdx = nextTravNode;
        }

        // return root
        return rootNode;
    }

public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int maxNodeVal = edges.size() + 1;
        vector<int> componentBelongToNode(maxNodeVal);
        for(int i = 0; i < maxNodeVal; i++) componentBelongToNode[i] = i;

        for(auto &edge : edges) {

            int compNodeNum0 = 0;
            int root0 = travCompressToFindRootNodeOfComponent(componentBelongToNode, edge[0], compNodeNum0);

            int compNodeNum1 = 0;
            int root1 = travCompressToFindRootNodeOfComponent(componentBelongToNode, edge[1], compNodeNum1);

            if(root0 == root1) return edge;

            // merge component to the one with less node
            if(compNodeNum0 < compNodeNum1) componentBelongToNode[root0] = root1;
            else componentBelongToNode[root1] = root0;
        }

        return {};
    }
};
```