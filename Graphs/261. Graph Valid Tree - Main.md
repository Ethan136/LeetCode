---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[261. Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)

# Concept
- 各個 node 一開始是視為一個獨立 component
- 用 union find 逐漸把 edge 兩端的 node 所在的 component 合併 -> **compToRootComp[rootComp0] = rootComp1**
	- 如果某個 edge 兩端的 root component 相同 -> return false
- 合併 component 的時候，也更新 independent component cnt -> **合併一次則 independent component cnt 減 1**
	- 最後檢查是否 independent component cnt 剩下一個 -> 一個才是 valid tree

# Answer
```Cpp
class Solution {
private:
    int travAndCompressToRootComp(vector<int> &compToRootComp, int compIdx) {
        if(compToRootComp[ compIdx ] == compIdx) return compIdx;

        int rootComp = travAndCompressToRootComp(compToRootComp, compToRootComp[ compIdx ]);
        compToRootComp[ compIdx ] = rootComp;

        return rootComp;
    }
public:
    bool validTree(int n, vector<vector<int>>& edges) {
        vector<int> compToRootComp(n);
        for(int i = 0; i < n; i++) compToRootComp[i] = i;

        int independentCompCnt = n;
        for(auto &edge : edges) {
            int rootComp0 = travAndCompressToRootComp(compToRootComp, edge[0]);
            int rootComp1 = travAndCompressToRootComp(compToRootComp, edge[1]);
            
            if(rootComp0 == rootComp1) return false;
            compToRootComp[rootComp0] = rootComp1;

            independentCompCnt--;
        }
        return (independentCompCnt == 1);
    }
};

``` 