---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
NeetCode: [Graph Valid Tree - NeetCode](https://neetcode.io/problems/valid-tree/question?list=neetcode150)
LeetCode(locked): [261. Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)

# Concept
- 各個 node 一開始是視為一個獨立 component
- 用 union find 逐漸把 edge 兩端的 node 所在的 component 合併 -> **compToRootComp[rootComp0] = rootComp1**
	- 如果某個 edge 兩端的 root component 相同 -> return false
- 合併 component 的時候，也更新 independent component cnt -> **合併一次則 independent component cnt 減 1**
	- 最後檢查是否 independent component cnt 剩下一個 -> 一個才是 valid tree

# Answer
## V1：複習1st - union find DFS Recursive
```Cpp
class Solution {
private:
    int travAndCompressToRootComp(vector<int> &compToRootComp, int compIdx) {
        if(compToRootComp[ compIdx ] == compIdx) return compIdx;

        int rootComp = travAndCompressToRootComp(compToRootComp, compToRootComp[ compIdx ]);
        compToRootComp[ compIdx ] = rootComp;

        return rootComp;
    }
public:
    bool validTree(int n, vector<vector<int>>& edges) {
        vector<int> compToRootComp(n);
        for(int i = 0; i < n; i++) compToRootComp[i] = i;

        int independentCompCnt = n;
        for(auto &edge : edges) {
            int rootComp0 = travAndCompressToRootComp(compToRootComp, edge[0]);
            int rootComp1 = travAndCompressToRootComp(compToRootComp, edge[1]);
            
            if(rootComp0 == rootComp1) return false;
            compToRootComp[rootComp0] = rootComp1;

            independentCompCnt--;
        }
        return (independentCompCnt == 1);
    }
};

``` 


## V2：複習2nd - 模板化寫法
```Cpp
class Solution {
private:
    int unionFindPivotNode(int node, unordered_map<int, int> &nodeToConnectNode) {
        int travNode = node;
        while(travNode != nodeToConnectNode[travNode]) {
            travNode = nodeToConnectNode[travNode];
        }
        int pivotNode = travNode;

        travNode = node;
        while(travNode != nodeToConnectNode[travNode]) {
            int nextTravNode = nodeToConnectNode[travNode];
            nodeToConnectNode[travNode] = pivotNode;
            travNode = nextTravNode;
        }

        return pivotNode;
    }
public:
    bool validTree(int n, vector<vector<int>>& edges) {
        unordered_map<int, int> nodeToConnectNode;
        for(int i = 0; i < n; i++) nodeToConnectNode[i] = i;

        int componentNum = n;
        for(auto &edge : edges) {
            int node1 = edge[0];
            int node2 = edge[1];

            int pivotNode1 = unionFindPivotNode(node1, nodeToConnectNode);
            int pivotNode2 = unionFindPivotNode(node2, nodeToConnectNode);

            if(pivotNode1 == pivotNode2) return false;

            nodeToConnectNode[pivotNode1] = pivotNode2;
            componentNum--;
        }

        return (componentNum == 1);
    }
};
```