---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)

# Concept
- **從 boundary 往中心檢查** -> 這樣情況最單純，一定是檢查到「不需要 mark X 的 'O'」
- 如果從任意位置檢查 -> 情況會複雜很多，必須判斷「當下的 O 有沒有連到 boundary」以及「當下的 traverse 是否有走過」以及「走過的 O 是否連到 boundary」 -> *會很複雜 ！！*

# Answer
## V1：複習1st
```Cpp
#define UN_SURROUND_O_CHAR    ('#')
vector<vector<int>> TRAV_DIRS = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
class Solution {
private:
    void travAndMarkFromBoundary(auto &board, int r, int c) {

        // if current position can't be traversed
        if(board[r][c] == 'X') return;

        // if current position had been traversed before
        if(board[r][c] == UN_SURROUND_O_CHAR) return;

        // mark current position as traversed
        board[r][c] = UN_SURROUND_O_CHAR;

        // traverse to adjacent position to ensure all around position are not 'O' connect to boundary
        for(auto& dir : TRAV_DIRS) {
            int r2 = r + dir[0];
            if( (r2 < 0) || (r2 >= board.size()) ) {
                continue;
            }
            
            int c2 = c + dir[1];
            if( (c2 < 0) || (c2 >= board[r2].size()) ) {
                continue;
            }

            travAndMarkFromBoundary(board, r2, c2);
        }
    }
public:
    void solve(vector<vector<char>>& board) {

        // mark un-surround position from left / right boundary
        for(int r = 0; r < board.size(); r++) {
            travAndMarkFromBoundary(board, r, 0);
            travAndMarkFromBoundary(board, r, board[r].size()-1);
        }

        // mark un-surround position from up / down boundary
        for(int c = 0; c < board[0].size(); c++) {
            travAndMarkFromBoundary(board, 0, c);
            travAndMarkFromBoundary(board, board.size()-1, c);
        }

        // restore the traversed 'O' char pos
        for(auto &row : board) {
            for(auto &pos : row) {
                switch (pos) {
                case UN_SURROUND_O_CHAR:
                    pos = 'O';
                    break;
                case 'O':
                    pos = 'X';
                    break;
                }
            }
        }
    }
};
``` 


## V2：複習2nd - 模板化寫法
```Cpp
class Solution {
private:
    void travAndMarkTargetGrid(auto &grid, int row, int col, char target, char Mark) {
        if( (row < 0) || (row >= grid.size()) ) return;
        if( (col < 0) || (col >= grid[row].size()) ) return;

        if(grid[row][col] != target) return;
        grid[row][col] = Mark;

        int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(int i = 0; i < 4; i++) {
            travAndMarkTargetGrid(grid, row + dir[i][0], col + dir[i][1], target, Mark);
        }
    }

public:
    void solve(vector<vector<char>>& board) {

        // mark edge connected parts
        int firstRow = 0;
        int lastRow = board.size() - 1;
        for(int col = 0; col < board[0].size(); col++) {
            travAndMarkTargetGrid(board, firstRow, col, 'O', '=');
            travAndMarkTargetGrid(board, lastRow, col, 'O', '=');
        }

        int firstCol = 0;
        int lastCol = board[0].size() - 1;
        for(int row = 0; row < board.size(); row++) {
            travAndMarkTargetGrid(board, row, firstCol, 'O', '=');
            travAndMarkTargetGrid(board, row, lastCol, 'O', '=');
        }

        // mark remained 'O' to 'X' & mark remained '=' back to 'O'
        for(int row = 0; row < board.size(); row++) {
            for(int col = 0; col < board[row].size(); col++) {
                
                char &boardRef = board[row][col];
                //cout << boardRef << " | ";
                
                if(boardRef == 'X') continue;
                if(boardRef == '=') boardRef = 'O';
                else if(boardRef == 'O') boardRef = 'X';
            }
            //cout << endl;
        }
    }
};
```