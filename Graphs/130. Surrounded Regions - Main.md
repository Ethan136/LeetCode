---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)

# Concept
- **從 boundary 往中心檢查** -> 這樣情況最單純，一定是檢查到「不需要 mark X 的 'O'」
- 如果從任意位置檢查 -> 情況會複雜很多，必須判斷「當下的 O 有沒有連到 boundary」以及「當下的 traverse 是否有走過」以及「走過的 O 是否連到 boundary」 -> *會很複雜 ！！*

# Answer
```Cpp
#define UN_SURROUND_O_CHAR    ('#')
vector<vector<int>> TRAV_DIRS = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
class Solution {
private:
    void travAndMarkFromBoundary(auto &board, int r, int c) {

        // if current position can't be traversed
        if(board[r][c] == 'X') return;

        // if current position had been traversed before
        if(board[r][c] == UN_SURROUND_O_CHAR) return;

        // mark current position as traversed
        board[r][c] = UN_SURROUND_O_CHAR;

        // traverse to adjacent position to ensure all around position are not 'O' connect to boundary
        for(auto& dir : TRAV_DIRS) {
            int r2 = r + dir[0];
            if( (r2 < 0) || (r2 >= board.size()) ) {
                continue;
            }
            
            int c2 = c + dir[1];
            if( (c2 < 0) || (c2 >= board[r2].size()) ) {
                continue;
            }

            travAndMarkFromBoundary(board, r2, c2);
        }
    }
public:
    void solve(vector<vector<char>>& board) {

        // mark un-surround position from left / right boundary
        for(int r = 0; r < board.size(); r++) {
            travAndMarkFromBoundary(board, r, 0);
            travAndMarkFromBoundary(board, r, board[r].size()-1);
        }

        // mark un-surround position from up / down boundary
        for(int c = 0; c < board[0].size(); c++) {
            travAndMarkFromBoundary(board, 0, c);
            travAndMarkFromBoundary(board, board.size()-1, c);
        }

        // restore the traversed 'O' char pos
        for(auto &row : board) {
            for(auto &pos : row) {
                switch (pos) {
                case UN_SURROUND_O_CHAR:
                    pos = 'O';
                    break;
                case 'O':
                    pos = 'X';
                    break;
                }
            }
        }
    }
};
``` 