---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
Locked: https://leetcode.com/problems/walls-and-gates/description/
NeetCode: https://neetcode.io/problems/islands-and-treasure?list=neetcode150

# Concept
- **從 treasure 所在的位置開始 traverse**

# Answer
## V1：複習1st
```Cpp
#define NUM_LAND    (INT_MAX)
#define NUM_TREASURE    (0)
#define NUM_WALL        (-1)
#define NEXT_DIR_NUM (4)
int const NEXT_DIR[ NEXT_DIR_NUM ][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
class Solution {
private:
    void traverseToMarkLandToTreasure(vector<vector<int>> &grid, int r, int c, int stepNum) {
	    // check position valid
        if((r < 0) || (r >= grid.size())) return;
        if((c < 0) || (c >= grid[r].size())) return;

		// if position is wall
        if(grid[r][c] == NUM_WALL) return;

		// if position already marked to closer distance of other treasure
        if(grid[r][c] < stepNum) return;

		// record the step number on the land
        grid[r][c] = stepNum;

		// traverse to next position
        for(int i = 0; i < NEXT_DIR_NUM; i++) {
            int r2 = r + NEXT_DIR[i][0];
            int c2 = c + NEXT_DIR[i][1];

            traverseToMarkLandToTreasure(grid, r2, c2, stepNum+1);
        }
    }
public:
    void islandsAndTreasure(vector<vector<int>>& grid) {
        for(int r = 0; r < grid.size(); r++) {
            for(int c = 0; c < grid[r].size(); c++) {
	            // traverse from treasure point
                if(grid[r][c] != NUM_TREASURE) continue;
                traverseToMarkLandToTreasure(grid, r, c, 0);
            }
        }
    }
};

``` 

## V2：複習2nd - 模板化寫法
```Cpp
class Solution {
private:
    void travAndMarkTreasureDist(int prevStep, vector<vector<int>>& grid, int row, int col) {
        if( (row < 0) || (row >= grid.size()) ) return;
        if( (col < 0) || (col >= grid[row].size()) ) return;

        int &gridNumRef = grid[row][col];
        if(gridNumRef == -1) return;
        
        if(prevStep >= gridNumRef) return;
        gridNumRef = prevStep + 1;
        
        int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(int i = 0; i < 4; i++) {
            travAndMarkTreasureDist(gridNumRef, grid, row + dir[i][0], col + dir[i][1]);
        }
    }
public:
    void islandsAndTreasure(vector<vector<int>>& grid) {
        for(int row = 0; row < grid.size(); row++) {
            for(int col = 0; col < grid[row].size(); col++) {
                if(grid[row][col] != 0) continue;
                travAndMarkTreasureDist(-1, grid, row, col);
            }
        }
    }
};

```