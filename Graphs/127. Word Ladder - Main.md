---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[127. Word Ladder](https://leetcode.com/problems/word-ladder/)

# Concept
- TopDown -> 可能會發散找不到能連到 endWord 的字
- Bottom Up -> 可以限縮一定能連到的字（感覺比較好，但或許沒差）
- 找出差一個或是相同的字 -> 可以 string 兩兩比對每個 char，也可以把 string a 依序改一個字，然後用 map 檢查有沒有存在
- **其實是一個 traverse 的問題，要避免用過的字重複使用 -> 用過的字要剔除 candidate 或是標記不再使用**
- **一次改一個字，然後從新的字再改一個，檢查後續可行的 -> 可以用 BFS，而且 BFS 層數 = 最短的 word change 路徑**
- **也可以用 DFS，但 DFS 執行的時候，不保證最短路徑，仍然需要跑很多組解來看 min layer cnt**
- **如果每一輪的 candidate 都拿來和 target word 比對一次，來看是否差異小於1 -> 可以節省 BFS 的最後一輪

# Answer：Bottom Up Track Back From End Word
## V1： 每一輪把當前的 candicate 和剩餘所有的 word 比對 -> O(N^2 * M)
- N = word Cnt
- M = word length
```Cpp
#define INVALID_STEP_TO_END_WORD    (-1)
class Solution {
private:
    int checkWordDiffCntNotMoreThan1(auto &w1, auto &w2) {
        if(w1.size() != w2.size()) return 2;

        int diffCnt = 0;
        for(int i = 0; i < w1.size(); i++) {
            if(w1[i] == w2[i]) continue;
            if(++diffCnt > 1) break;
        }
        return diffCnt;
    }
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // wordList[w0, w1, w2, w3...
        // endWord -> [w0, w2, w3...]
        // w0 -> [w1, w3, w5 ...]
        // w2 -> [w3, w4, w5 ...]

        // find the index of endWord in wordList
        int endWordIdx = -1;
        for(int i = 0; i < wordList.size(); i++) {
            if(wordList[i] != endWord) continue;
    
            endWordIdx = i;
            break;
        }

        // if endword is not in the word list
        if(endWordIdx < 0) {
            return 0;
        }

        // to record the step to endword
        vector<int> wordNumToEnd(wordList.size(), INVALID_STEP_TO_END_WORD);

        // word number to endword from endword is 1
        wordNumToEnd[ endWordIdx ] = 1;

        // build connection relationship from closest to further
        // (1) start from end word        
        queue<int> pendingComponent;
        pendingComponent.push( endWordIdx );

        // (2) check until there's no word that could be connected to endword
        while(pendingComponent.size()) {
            int compIdx = pendingComponent.front();
            pendingComponent.pop();

            int diffCnt = checkWordDiffCntNotMoreThan1(beginWord, wordList[ compIdx ]);
            if(diffCnt <= 1) {
                return wordNumToEnd[ compIdx ] + diffCnt;
            }

            for(int i = 0; i < wordList.size(); i++) {
                if(i == compIdx) continue;
                if(wordNumToEnd[i] != INVALID_STEP_TO_END_WORD) continue;
                
                diffCnt = checkWordDiffCntNotMoreThan1(wordList[i], wordList[compIdx]);
                if(diffCnt > 1) continue;

                wordNumToEnd[i] = wordNumToEnd[compIdx] + diffCnt;
                pendingComponent.push(i);
            }
        }

        // if there's no possible way to step from beginword to endword
        return 0;
  }
};
```


## V2：每一輪把當前 candidate 一次改一個字，用 Map 找出下一個 Candidate -> O(N x M x 26)
- N = word Cnt
- M = word length
- 26 = word[i] 試著改成其他英文字
```Cpp
#define INVALID_STEP_TO_END_WORD    (-1)
class Solution {
private:
    int checkWordDiffCntNotMoreThan1(auto &w1, auto &w2) {
        if(w1.size() != w2.size()) return 2;

        int diffCnt = 0;
        for(int i = 0; i < w1.size(); i++) {
            if(w1[i] == w2[i]) continue;
            if(++diffCnt > 1) break;
        }
        return diffCnt;
    }
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // wordList[w0, w1, w2, w3...
        // endWord -> [w0, w2, w3...]
        // w0 -> [w1, w3, w5 ...]
        // w2 -> [w3, w4, w5 ...]

        // set wordList to unordered_map
        // -> time complexity of map[ targetStr ] is O(1) in avg
        unordered_map<string, int> wordMapToIdx;
        for(int i = 0; i < wordList.size(); i++) wordMapToIdx[ wordList[i] ] = i;

        // if endword is not in the word set
        if(!wordMapToIdx.count( endWord )) {
            return 0;
        }

        // get end word idx & erase word from map
        int endWordIdx = wordMapToIdx[ endWord ];
        wordMapToIdx.erase( endWord );

        // to record the step to endword
        vector<int> wordNumToEnd(wordList.size(), INVALID_STEP_TO_END_WORD);

        // word number to endword from endword is 1
        wordNumToEnd[ endWordIdx ] = 1;

        // build connection relationship from closest to further
        // (1) start from end word        
        queue<int> pendingComponent;
        pendingComponent.push( endWordIdx );

        // (2) check until there's no word that could be connected to endword
        while(pendingComponent.size()) {
            int compIdx = pendingComponent.front();
            pendingComponent.pop();

            int diffCnt = checkWordDiffCntNotMoreThan1(beginWord, wordList[ compIdx ]);
            if(diffCnt <= 1) {
                return wordNumToEnd[ compIdx ] + diffCnt;
            }

            for(int i = 0; i < wordList[ compIdx ].size(); i++) {
                char char_i = wordList[ compIdx ][i];

                for(int c = 'a'; c <= 'z'; c++) {

                    if(c == char_i) continue;
                    wordList[ compIdx ][i] = c;

                    if(!wordMapToIdx.count(wordList[ compIdx ])) continue;
                    int oneDiffWordIdx = wordMapToIdx[ wordList[ compIdx ] ];
                    wordMapToIdx.erase( wordList[ compIdx ] );

                    wordNumToEnd[ oneDiffWordIdx ] = wordNumToEnd[compIdx] + 1;
                    pendingComponent.push( oneDiffWordIdx );
                }

                wordList[ compIdx ][i] = char_i;
            }
        }

        // if there's no possible way to step from beginword to endword
        return 0;
  }
};
```