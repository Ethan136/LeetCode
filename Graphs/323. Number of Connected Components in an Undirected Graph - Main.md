---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
NeetCode: [Problems](https://neetcode.io/problems/count-connected-components/question)
LeetCode (locked): [323. Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

# Concept
- 一開始先當做一個 node 是一個 component，並假設所有 component 都不相連
- **每當有兩個 component 相連 -> 減少一個 un-connected component num**

# Answer：複習1st - DFS Union Search（只檢查有幾個 component）
```Cpp
class Solution {
private:
    int travAndCompressToFirstParent(vector<int> &compToRootComp, int compIdx) {
        // if component root is component itself
        if(compToRootComp[ compIdx ] == compIdx) return compIdx;

        // traverse to parent
        int rootCompIdx = travAndCompressToFirstParent(compToRootComp, compToRootComp[ compIdx ]);

        // link component to ever root component directly
        compToRootComp[ compIdx ] = rootCompIdx;

        // get root component
        return rootCompIdx;
    }
public:
    int countComponents(int n, vector<vector<int>>& edges) {
        vector<int> compToRootComp(n);
        for(int i = 0; i < n; i++) compToRootComp[i] = i;

        int unConnectedCompCnt = n;
        for(auto &edge : edges) {
            int rootComp0 = travAndCompressToFirstParent(compToRootComp, edge[0]);
            int rootComp1 = travAndCompressToFirstParent(compToRootComp, edge[1]);

            if(rootComp0 == rootComp1) continue;
            compToRootComp[rootComp0] = rootComp1;
            unConnectedCompCnt--;
        }

        return unConnectedCompCnt;
    }
};

```

# Answer：複習2nd - 模板化寫法
## V1：重建所有 component
```Cpp
class Solution {
private:
    int unionFindPivotConnectNode(int node, unordered_map<int, int> &nodeToConnectNode) {
        // find pivot connected node
        int travNode = node;
        while(travNode != nodeToConnectNode[travNode]) {
            travNode = nodeToConnectNode[travNode];
        }
        int pivotNode = travNode;

        // compress path
        travNode = node;
        while(travNode != nodeToConnectNode[travNode]) {
            int nextTravNode = nodeToConnectNode[travNode];
            nodeToConnectNode[travNode] = pivotNode;
            travNode = nextTravNode;
        }

        // finish
        return pivotNode;
    }
public:
    int countComponents(int n, vector<vector<int>>& edges) {
        unordered_map<int, int> nodeToConnectNode;
        for(int i = 0; i < n; i++) nodeToConnectNode[i] = i;

        for(auto &edge: edges) {
            int node1 = edge[0];
            int node2 = edge[1];

            int pivotNode1 = unionFindPivotConnectNode(node1, nodeToConnectNode);
            int pivotNode2 = unionFindPivotConnectNode(node2, nodeToConnectNode);

            nodeToConnectNode[pivotNode1] = pivotNode2;
        }

        unordered_map<int, unordered_set<int>> pivotNodeToComponent;
        for(auto &[node, connectNode] : nodeToConnectNode) {
            int pivotNode = unionFindPivotConnectNode(node, nodeToConnectNode);

            pivotNodeToComponent[pivotNode].insert(pivotNode);
            pivotNodeToComponent[pivotNode].insert(node);
        }

        return pivotNodeToComponent.size();
    }
};
```

## V2：只計算 component 數量（不重建所有 component）
```Cpp
class Solution {
private:
    int unionFindPivotConnectNode(int node, unordered_map<int, int> &nodeToConnectNode) {
        // find pivot connected node
        int travNode = node;
        while(travNode != nodeToConnectNode[travNode]) {
            travNode = nodeToConnectNode[travNode];
        }
        int pivotNode = travNode;

        // compress path
        travNode = node;
        while(travNode != nodeToConnectNode[travNode]) {
            int nextTravNode = nodeToConnectNode[travNode];
            nodeToConnectNode[travNode] = pivotNode;
            travNode = nextTravNode;
        }

        // finish
        return pivotNode;
    }
public:
    int countComponents(int n, vector<vector<int>>& edges) {
        unordered_map<int, int> nodeToConnectNode;
        for(int i = 0; i < n; i++) nodeToConnectNode[i] = i;

        int componentNum = n;
        for(auto &edge: edges) {
            int node1 = edge[0];
            int node2 = edge[1];

            int pivotNode1 = unionFindPivotConnectNode(node1, nodeToConnectNode);
            int pivotNode2 = unionFindPivotConnectNode(node2, nodeToConnectNode);

            if(pivotNode1 == pivotNode2) continue;
            
            nodeToConnectNode[pivotNode1] = pivotNode2;
            componentNum--;
        }


        return componentNum;
    }
};
```