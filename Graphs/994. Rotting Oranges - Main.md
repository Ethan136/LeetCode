# LeetCode
[994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)

# Concept
- **Rotten time 記錄為 2 + timestamp**
	- time stamp 為實際的 rotten time
	- 2 為 ROTTEN_ORANGE_NUM 作為 offset
- **rotten time 是一直向上疊加**
	- **所以不用考慮「rotten A -> B 後， B -> A rotten 時 time stamp 相同的情況」
	- **也不用考慮「rotten A -> B 後，B -> C 遇到 initial rotten 記錄為 2 的情況（因為 B-C 的時候使用的 time stamp 一定大於 2）**

# Answer
## V1：複習1st
```Cpp
#define EMPTY_CELL_NUM (0)
#define FRESH_ORANGE_NUM (1)
#define ROTTEN_ORANGE_NUM   (2)
#define ROTTEN_TIME_OFFSET  (ROTTEN_ORANGE_NUM)
vector<vector<int>> SPREAD_DIR_VEC = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
class Solution {
private:
    void spreadMarkFromRotten(auto &grid, int r, int c, int rottenTimestamp) {
        if( (r < 0) || (r >= grid.size()) ) return;
        if( (c < 0) || (c >= grid[r].size()) ) return;

        // empty cell
        if(grid[r][c] == EMPTY_CELL_NUM) {
            return;
        }

        // not initial rotten -> check if current position already rottened earlier
        if( (grid[r][c] >= ROTTEN_TIME_OFFSET) && (grid[r][c] < (ROTTEN_TIME_OFFSET + rottenTimestamp) ) ) {
            return;
        }

        // rotten the orange
        grid[r][c] = ROTTEN_TIME_OFFSET + rottenTimestamp;

        // spread rotten to adjacent position
        for(auto &dir : SPREAD_DIR_VEC) {
            spreadMarkFromRotten(grid, r + dir[0], c + dir[1], rottenTimestamp + 1);
        }
    }
public:
    int orangesRotting(vector<vector<int>>& grid) {

        // start rottening
        for(int r = 0; r < grid.size(); r++) {
            for(int c = 0; c < grid[r].size(); c++) {
                if(grid[r][c] != ROTTEN_ORANGE_NUM) continue;
                spreadMarkFromRotten(grid, r, c, 0);
            }
        }

        // check remained orange has any fresh
        int maxRottenTime = 0;
        for(auto &row : grid) {
            for(int cond : row) {
                // empty cell
                if(cond == EMPTY_CELL_NUM) continue;

                // and un-rotten orange
                if(cond == FRESH_ORANGE_NUM) return -1;

                // fetch rotten time
                maxRottenTime = max(maxRottenTime, cond - ROTTEN_TIME_OFFSET);
            }
        }

        // return max rotten spread time
        return maxRottenTime;
    }
};
``` 

## V2：複習2nd
```Cpp
class Solution {
private:
    void travAndMarkRotten(int prevStep, auto &grid, int row, int col) {
        if( (row < 0) || (row >= grid.size()) ) return;
        if( (col < 0) || (col >= grid[row].size()) ) return;

        if(grid[row][col] == -1) return;

        if(grid[row][col] <= prevStep) return;
        grid[row][col] = prevStep + 1;

        int dir[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
        for(int i = 0; i < 4; i++) {
            travAndMarkRotten(grid[row][col], grid, row + dir[i][0], col + dir[i][1]);
        }
    }
public:
    int orangesRotting(vector<vector<int>>& grid) {
        // pre condition
        for(int row = 0; row < grid.size(); row++) {
            for(int col = 0; col < grid[row].size(); col++) {
                switch(grid[row][col]) {
                case 0:
                    grid[row][col] = -1;
                    break;
                case 1:
                    grid[row][col] = INT_MAX;
                    break;
                case 2:
                    grid[row][col] = 0;
                    break; 
                }
            }
        }

        // traverse & start from rotten
        for(int row = 0; row < grid.size(); row++) {
            for(int col = 0; col < grid[row].size(); col++) {
                if(grid[row][col] != 0) continue;
                travAndMarkRotten(-1, grid, row, col);
            }
        }

        // post process: find max time
        int maxTime = 0;
        for(int row = 0; row < grid.size(); row++) {
            for(int col = 0; col < grid[row].size(); col++) {
                if(grid[row][col] == INT_MAX) return -1;
                maxTime = max( maxTime, grid[row][col] );
            }
        }
        return maxTime;
    }
};
```