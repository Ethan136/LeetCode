# LeetCode
[994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)

# Concept
- **Rotten time 記錄為 2 + timestamp**
	- time stamp 為實際的 rotten time
	- 2 為 ROTTEN_ORANGE_NUM 作為 offset
- **rotten time 是一直向上疊加**
	- **所以不用考慮「rotten A -> B 後， B -> A rotten 時 time stamp 相同的情況」
	- **也不用考慮「rotten A -> B 後，B -> C 遇到 initial rotten 記錄為 2 的情況（因為 B-C 的時候使用的 time stamp 一定大於 2）**

# Answer
```Cpp
#define EMPTY_CELL_NUM (0)
#define FRESH_ORANGE_NUM (1)
#define ROTTEN_ORANGE_NUM   (2)
#define ROTTEN_TIME_OFFSET  (ROTTEN_ORANGE_NUM)
vector<vector<int>> SPREAD_DIR_VEC = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
class Solution {
private:
    void spreadMarkFromRotten(auto &grid, int r, int c, int rottenTimestamp) {
        if( (r < 0) || (r >= grid.size()) ) return;
        if( (c < 0) || (c >= grid[r].size()) ) return;

        // empty cell
        if(grid[r][c] == EMPTY_CELL_NUM) {
            return;
        }

        // not initial rotten -> check if current position already rottened earlier
        if( (grid[r][c] >= ROTTEN_TIME_OFFSET) && (grid[r][c] < (ROTTEN_TIME_OFFSET + rottenTimestamp) ) ) {
            return;
        }

        // rotten the orange
        grid[r][c] = ROTTEN_TIME_OFFSET + rottenTimestamp;

        // spread rotten to adjacent position
        for(auto &dir : SPREAD_DIR_VEC) {
            spreadMarkFromRotten(grid, r + dir[0], c + dir[1], rottenTimestamp + 1);
        }
    }
public:
    int orangesRotting(vector<vector<int>>& grid) {

        // start rottening
        for(int r = 0; r < grid.size(); r++) {
            for(int c = 0; c < grid[r].size(); c++) {
                if(grid[r][c] != ROTTEN_ORANGE_NUM) continue;
                spreadMarkFromRotten(grid, r, c, 0);
            }
        }

        // check remained orange has any fresh
        int maxRottenTime = 0;
        for(auto &row : grid) {
            for(int cond : row) {
                // empty cell
                if(cond == EMPTY_CELL_NUM) continue;

                // and un-rotten orange
                if(cond == FRESH_ORANGE_NUM) return -1;

                // fetch rotten time
                maxRottenTime = max(maxRottenTime, cond - ROTTEN_TIME_OFFSET);
            }
        }

        // return max rotten spread time
        return maxRottenTime;
    }
};
``` 