---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[133. Clone Graph](https://leetcode.com/problems/clone-graph/)

# Concept
- **如果兩個 node 戶連，則要避免 node A clone 的時候，traverse node B，然後 node B clone 的時候，又回到 node A** -> **使用 DP 記錄 cloned nodes 來進行 early return**
- 這題因為 node 數量是 100 內，而且是 edge 很多 -> 適合用 DP 記錄已經生成的 node
- 複習2nd 的模板化寫法，可以無視 node value 是否重複，很萬用
# Answer：複習1st - DFS + DP for Cloned Nodes
```Cpp

class Solution {
private:
    Node* travGraphAndClone(Node* node, auto &valToCloneNodeMap) {
        // if the node is empty
        if(!node) {
            return nullptr;
        }

        // if current node had been cloned
        if(valToCloneNodeMap[node->val]) {
            return valToCloneNodeMap[node->val];
        }

        // clone node body
        Node * cloneNode = new Node( node->val, vector<Node*>( node->neighbors.size(), nullptr ) );

        // record on cloned map
        valToCloneNodeMap[node->val] = cloneNode;

        // clone neighbors
        for(int i = 0; i < node->neighbors.size(); i++) {
            cloneNode->neighbors[i] = travGraphAndClone(node->neighbors[i], valToCloneNodeMap);
        }

        // finish
        return cloneNode;
    }
public:
    Node* cloneGraph(Node* node) {
        unordered_map<int, Node*> valToCloneNodeMap;
        return travGraphAndClone(node, valToCloneNodeMap);
    }
};
``` 

# Answer：複習2nd - 模板化寫法
```Cpp
class Solution {
private:
    Node* traverseAndClone(Node *node, auto &originNodeToCloneNode) {
        if(!node) return nullptr;
        if(originNodeToCloneNode.count(node)) return originNodeToCloneNode[node];

        Node *cloneNode = new Node(node->val);
        originNodeToCloneNode[node] = cloneNode;

        for(auto neighborNode : node->neighbors) {
            cloneNode->neighbors.push_back( traverseAndClone(neighborNode, originNodeToCloneNode) );
        }
        return cloneNode;
    }
public:
    Node* cloneGraph(Node* node) {
        unordered_map<Node*, Node*> originNodeToCloneNode;
        return traverseAndClone(node, originNodeToCloneNode);
    }
};
```