---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[133. Clone Graph](https://leetcode.com/problems/clone-graph/)

# Concept
- **如果兩個 node 戶連，則要避免 node A clone 的時候，traverse node B，然後 node B clone 的時候，又回到 node A** -> **使用 DP 記錄 cloned nodes 來進行 early return**
- 這題因為 node 數量是 100 內，而且是 edge 很多 -> 適合用 DP 記錄已經生成的 node
# Answer：DFS + DP for Cloned Nodes
```Cpp

class Solution {
private:
    Node* travGraphAndClone(Node* node, auto &valToCloneNodeMap) {
        // if the node is empty
        if(!node) {
            return nullptr;
        }

        // if current node had been cloned
        if(valToCloneNodeMap[node->val]) {
            return valToCloneNodeMap[node->val];
        }

        // clone node body
        Node * cloneNode = new Node( node->val, vector<Node*>( node->neighbors.size(), nullptr ) );

        // record on cloned map
        valToCloneNodeMap[node->val] = cloneNode;

        // clone neighbors
        for(int i = 0; i < node->neighbors.size(); i++) {
            cloneNode->neighbors[i] = travGraphAndClone(node->neighbors[i], valToCloneNodeMap);
        }

        // finish
        return cloneNode;
    }
public:
    Node* cloneGraph(Node* node) {
        unordered_map<int, Node*> valToCloneNodeMap;
        return travGraphAndClone(node, valToCloneNodeMap);
    }
};
``` 