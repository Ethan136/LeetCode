---
ParentTask:
  - "[[graphs]]"
---

# LeetCode
[417. Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)

# Concept
- **從海平面開始，海平面記錄 ocean bit**
	- 如果可以往上走，走過的地方記錄 ocean bit
	- 往上走的時候，如果這個地方的 ocean bit 已經涵蓋當前位置的 ocean bit -> 代表已經走過，不用再走

# Answer：DFS + Trace From Ocean Level
## 第一次寫的
```Cpp
#define BIT(N)                  (1 << (N))
#define PACIFIC_WATER_FLOW_BIT  BIT(30)
#define ATLANTIC_WATER_FLOW_BIT BIT(29)

#define HEIGHT_BIT_MASK                         (ATLANTIC_WATER_FLOW_BIT - 1)
#define GET_HEIGHT_VALUE(HeightWithOceanBit)    (HeightWithOceanBit & HEIGHT_BIT_MASK)
class Solution {
private:
    void markFromOceanLevelBottomUp(vector<vector<int>>& heights, int i, int j, int fromLowerHeight, int oceanMarkBit) {
        // check position is valid
        if(i < 0 || i >= heights.size()) return;
        if(j < 0 || j >= heights[i].size()) return;

        // check if the current position had been checked and marked before
        if(heights[i][j] & oceanMarkBit) return;

        // check if current position is higher
        if(fromLowerHeight > GET_HEIGHT_VALUE(heights[i][j])) return;

        // mark the ocean water flow to the current position
        heights[i][j] |= oceanMarkBit;

        // check the surrounded position from the current height
        markFromOceanLevelBottomUp(heights, i+1, j, GET_HEIGHT_VALUE(heights[i][j]), oceanMarkBit);
        markFromOceanLevelBottomUp(heights, i-1, j, GET_HEIGHT_VALUE(heights[i][j]), oceanMarkBit);
        markFromOceanLevelBottomUp(heights, i, j+1, GET_HEIGHT_VALUE(heights[i][j]), oceanMarkBit);
        markFromOceanLevelBottomUp(heights, i, j-1, GET_HEIGHT_VALUE(heights[i][j]), oceanMarkBit);
    }

    void getAllPositionWithTwoOceanWaterFlow(vector<vector<int>>& heights, vector<vector<int>> &result, int targetOceanBitMask) {
        for(int i = 0; i < heights.size(); i++) {
            for(int j = 0; j < heights[i].size(); j++) {
                if((heights[i][j] & targetOceanBitMask) != targetOceanBitMask) continue;

                result.push_back({i, j});
            }
        }
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        // left boundary: check water from ocean back to higher position
        for(int i = 0, j = 0; i < heights.size(); i++) {
            markFromOceanLevelBottomUp(heights, i, j, 0, PACIFIC_WATER_FLOW_BIT);
        }

        // top boundary: check water from ocean back to higher position
        for(int i = 0, j = 0; j < heights[i].size(); j++) {
            markFromOceanLevelBottomUp(heights, i, j, 0, PACIFIC_WATER_FLOW_BIT);
        }

        // right boundary: check water from ocean back to higher position
        for(int i = 0, j = heights[i].size() - 1; i < heights.size(); i++) {
            markFromOceanLevelBottomUp(heights, i, j, 0, ATLANTIC_WATER_FLOW_BIT);
        }

        // bottom boundary: check water from ocean back to higher position
        for(int i = heights.size() - 1, j = 0; j < heights[i].size(); j++) {
            markFromOceanLevelBottomUp(heights, i, j, 0, ATLANTIC_WATER_FLOW_BIT);
        }

        // check the position where the water flow go to both the ocean
        vector<vector<int>> result;
        getAllPositionWithTwoOceanWaterFlow(heights, result, (PACIFIC_WATER_FLOW_BIT | ATLANTIC_WATER_FLOW_BIT));

        // return the result
        return result;
    }
};
``` 

## 複習時候寫的
```Cpp
#define BIT(N)  (1 << N)
#define FLOW_TO_PACIFIC_BIT    (BIT(30))
#define FLOW_TO_ATLANTIC_BIT   (BIT(31))
#define GET_FLOW_OCEAN_BITS(HEIGHT)     (HEIGHT & (FLOW_TO_PACIFIC_BIT | FLOW_TO_ATLANTIC_BIT) )
#define GET_HEIGHT_VAL(HEIGHT)  (HEIGHT & (BIT(30) - 1))

#define TRAV_DIR_LEN    (4)
int const TRAV_DIR[TRAV_DIR_LEN][2] = { {-1, 0}, {1, 0}, {0, 1}, {0, -1} };
class Solution {
private:

    void travFromOceanLevelToHigherPos(auto &heights, int r, int c) {

        int curPosHeight = GET_HEIGHT_VAL(heights[r][c]);
        int curPosOceanBits = GET_FLOW_OCEAN_BITS(heights[r][c]);

        for(int i = 0; i < TRAV_DIR_LEN; i++) {
            // next pos
            int r2 = r + TRAV_DIR[i][0];
            int c2 = c + TRAV_DIR[i][1];

            // check next pos
            if( (r2 < 0) || (r2 >= heights.size()) ) continue;
            if( (c2 < 0) || (c2 >= heights[r2].size()) ) continue;

            // check height
            if( GET_HEIGHT_VAL(heights[r2][c2]) < curPosHeight ) continue;

            // check if the next position had been traversed before
            if( (GET_FLOW_OCEAN_BITS(heights[r2][c2]) & curPosOceanBits) == curPosOceanBits ) continue;

            // convey ocean bit from current pos to next pos
            heights[r2][c2] |= curPosOceanBits;

            // traverse up
            travFromOceanLevelToHigherPos(heights, r2, c2);
        }
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {

        int lastRowIdx = heights.size() - 1;
        int lastColIdx = heights[0].size() - 1;

        // traverse from pacific oceal level c = 0
        for(int r = 0; r <= lastRowIdx; r++) {
            heights[r][0] |= FLOW_TO_PACIFIC_BIT;
            travFromOceanLevelToHigherPos(heights, r, 0);
        }

        // traverse from pacific oceal level r = 0
        for(int c = 0; c <= lastColIdx; c++) {
            heights[0][c] |= FLOW_TO_PACIFIC_BIT;
            travFromOceanLevelToHigherPos(heights, 0, c);
        }

        // traverse from atlantic oceal level c = last
        for(int r = 0; r <= lastRowIdx; r++) {
            heights[r][lastColIdx] |= FLOW_TO_ATLANTIC_BIT;
            travFromOceanLevelToHigherPos(heights, r, lastColIdx);
        }

        // traverse from atlantic oceal level r = last
        for(int c = 0; c <= lastColIdx; c++) {
            heights[lastRowIdx][c] |= FLOW_TO_ATLANTIC_BIT;
            travFromOceanLevelToHigherPos(heights, lastRowIdx, c);
        }

        // get all posotion flows to two oceans
        vector<vector<int>> twoOceanPos;
        for(int r = 0; r <= lastRowIdx; r++) {
            for(int c = 0; c <= lastColIdx; c++) {
                if( !(heights[r][c] & FLOW_TO_PACIFIC_BIT) ) continue;
                if( !(heights[r][c] & FLOW_TO_ATLANTIC_BIT) ) continue;
                twoOceanPos.push_back({r, c});
            }
        }
        return twoOceanPos;
    }
};
```