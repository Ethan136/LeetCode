# LeetCode
[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

# Answer
## V1 - 正規 sliding window 做法
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {

		int result = 0;
		for(int buyIndex = 0, sellIndex = 1; sellIndex < price.size(); sellIndex++) {
			int profit = (prices[sellIndex] - prices[buyIndex]);
			if(profit <= 0) {
				buyIndex = sellIndex;
			}
			else {
				result = max(result, profit);
			}
		}
		return result;
    }
};
```
- 注意1：一定是『先買、後賣』
	- 買入的 index 比較低：index 從 0 to Last-1
	- 賣出的 index 比較高：index 從 1 to Last
	- -> **buyIdnex 初始化爲 0 / SellIndex 初始化爲 1**
- 更新時機
	- 當『賣出價格低於買入價格』 -> 有機會買更低 -> buyIndex 更新過去
	- 當『賣出價格高於先前』 -> 有機會賣更高 -> sellIndex 更新過去

## V2 - 複習1st：sliding window 概念，但只用 single index 的做法
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int bestProfit = 0;
        for(int i = 0, buyPrice = prices[0]; i < prices.size(); ) {
            if(prices[i] > buyPrice) {
                bestProfit = max( bestProfit, prices[i] - buyPrice );
                i++;
                continue;
            }

            while(i < prices.size() && prices[i] <= buyPrice) {
                buyPrice = prices[i];
                i++;
            }
        }
        return bestProfit;
    }
};
```
- index i 代表「當下檢查的位置，並不預設是用來 buy 還是 sell」
- （1）如果 price[i] 搭配買入位置可以賺錢 -> **更新 best profit**
- （2）如果 price[i] 搭配買入位置無法賺錢 -> **使用一個 while loop 持續更新 index i 直到在連續的 index i 路徑中找到最低價 -> 設為新買點**
- 因為 index i 有兩套更新機制 -> **不在 for loop condition3 裡面更新 index i，而是在 for loop 內部依照上面情況 1 / 2 各自更新 index i**

## V3 - 複習2nd：sliding window 正規寫法 -> 覺得這樣寫比較直覺
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;

        int maxProfit = 0;
        for(int i = 0, checkCnt = 0; i < prices.size(); i += checkCnt) {
            int buyPrice = prices[i];

            for(checkCnt = 0; (i+checkCnt) < prices.size(); checkCnt++) {
                int sellPrice = prices[i+checkCnt];
                if(sellPrice < buyPrice) break;

                maxProfit = max(maxProfit, sellPrice - buyPrice);
            }
        }
        return maxProfit;
    }
};
```