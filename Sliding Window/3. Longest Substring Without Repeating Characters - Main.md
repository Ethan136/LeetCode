# LeetCode
[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

# Answer
## V1 - Hash Array Map + Sliding Window (寫法比較複雜)
```Cpp
class Solution {
public:
	int lengthOfLongestSubstring(string s) {

		// init result
		int LongestSubStrLen = 0;

		// to record the character occurred index in current sub-string (init to invalid index -1)
		int charIdxRec[UCHAR_MAX] = {};
		for(auto &charIdx : charIdxRec) charIdx = -1;

		// store the first string to window
		int subStrLen = 0;
		int windowStartIdx = 0;
		unsigned char curChat;
		if(s.size()) {
			curChat = (unsigned char)s[windowStartIdx];
			charIdxRec[curChat] = windowStartIdx;
			LongestSubStrLen = 1;
			subStrLen = 1;
		}

		// check the remained string
		for(int windowEndIdx = 1; windowEndIdx < s.size(); 
			charIdxRec[curChat] = windowEndIdx++, subStrLen = (windowEndIdx - windowStartIdx)) {

			// the current char
			curChat = (unsigned char)s[windowEndIdx];

			// if the new scanned char is not duplicated within sliding window
			if(charIdxRec[curChat] < windowStartIdx) {
				continue;
			}

			// the current char is located within the window
			// (1) update substr length 
			subStrLen = (windowEndIdx - windowStartIdx);
			LongestSubStrLen = max(LongestSubStrLen, subStrLen);

			// (2) update window start point
			windowStartIdx = charIdxRec[curChat] + 1;
		}

		// end condition
		LongestSubStrLen = max(LongestSubStrLen, subStrLen);
		return LongestSubStrLen;
	}
};
```
- 直覺想到用 unsorted_set -> 用來檢查當前 sub string -> ~~也可以用 Array 當作 hash table~~
	- 因爲需要動態調整 unsorted_set 的內容，用 Array 的 Hashtable 可能不好處理
	- 檢查容器功能，unsorted_set 本身做 insert 的時候，不保證是 insert 在 Tail -> 用起來沒那麼方便
- 應該要用 unsorted_map -> 這個用起來就會又回到 Array 當作 hash_table 的情況
- 往右檢查，檢查到相同數值 a
	- window left index 更新到『先前相同數值 a 的下一個』
	- window right index 繼續往後更新
	- 更新 unsorted_set
- **Sliding Window 邊界要特別注意**
	- 有些情況是離開 for loop 的時候可能會少檢查 或 多檢查一次 -> *比如這次的需要在處理 array 前先額外檢查第一個元素*
	- **更新 Sliding Window 資訊的時機很重要**
	- **啓動的邊界條件要看會不會有東西沒設定到**
	- *For Loop 的寫法，會影響到整體好不好看，以及是否容易發生 bug*
	- **寫 for Loop 前，想好『哪些東西先更新』、『哪些東西是 loop 結束前更新』 -> **Loop 結束前更新的，要善用 for loop 第三條件**

## V2 - unordered_map + Sliding Window (邏輯比較直覺)
```Cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> lastScannedCharIdx;
        int maxSubStrLen = 0;

        for(int i = 0, curSubStrLen = 0, subStrStartIdx = 0; i < s.size(); i++) {
            // if current char is duplicated -> start new sub str
            if(lastScannedCharIdx.count(s[i]) && (lastScannedCharIdx[s[i]] >= subStrStartIdx)) {

                // the index of the char duplicated in sub str
                int duplicateCharIdx = lastScannedCharIdx[s[i]];

                // start new sub str from the "next index of the prev duplicated char"
                subStrStartIdx = duplicateCharIdx + 1;
                curSubStrLen = i - duplicateCharIdx;

                // update the last scanned index of the duplicated char
                lastScannedCharIdx[s[i]] = i;
            }
            // if current char is not duplicated -> extend sub str
            else {
                lastScannedCharIdx[s[i]] = i;
                curSubStrLen++;
            }

            // update max sub str len
            maxSubStrLen = max(maxSubStrLen, curSubStrLen);
        }

        return maxSubStrLen;
    }
};
```
- 掃過的 char 在一個 map 記錄「最後一次掃到的 index」
- substr 記錄 start idx
- 可以透過 map 查詢「某個 char 上次被掃到的位置，是否在 substr start idx 後」 -> **來判斷是否掃到 duplicated char**
- 這個做法用到 map，速度比較慢

## V3 - 複習1st：Hash Vector Map + Sliding Window (邏輯比較直覺，V2 的優化版)
```Cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> lastScannedCharIdx(UCHAR_MAX, -1);
        int maxSubStrLen = 0;

        for(int i = 0, curSubStrLen = 0, subStrStartIdx = 0; i < s.size(); i++) {
            // if current char is duplicated -> start new sub str
            if((lastScannedCharIdx[s[i]] >= 0) && (lastScannedCharIdx[s[i]] >= subStrStartIdx)) {

                // the index of the char duplicated in sub str
                int duplicateCharIdx = lastScannedCharIdx[s[i]];

                // start new sub str from the "next index of the prev duplicated char"
                subStrStartIdx = duplicateCharIdx + 1;
                curSubStrLen = i - duplicateCharIdx;

                // update the last scanned index of the duplicated char
                lastScannedCharIdx[s[i]] = i;
            }
            // if current char is not duplicated -> extend sub str
            else {
                lastScannedCharIdx[s[i]] = i;
                curSubStrLen++;
            }

            // update max sub str len
            maxSubStrLen = max(maxSubStrLen, curSubStrLen);
        }

        return maxSubStrLen;
    }
};
```

## V4 - 複習2nd：Hash Vector Map + Sliding Window（直覺無優化的版本，比較慢）
### V4.1：沒有優化的版本 - 更新 sub-str 的時候掃描整個 char idx record
```Cpp
#define INVALID_IDX (-1)
#define ALL_CHAR_NUM (256)
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> charIdxInSubStr(ALL_CHAR_NUM, INVALID_IDX);

        int maxSubStrLen = 0, curSubStrLen = 0;
        for(int i = 0; i < s.size(); i++) {
            // extend sub str &
            if(charIdxInSubStr[ s[i] ] == INVALID_IDX) {
                // extend cur substr
                curSubStrLen++;
                charIdxInSubStr[ s[i] ] = i;

                // update max substr len
                maxSubStrLen = max(maxSubStrLen, curSubStrLen);
                continue;
            }

            // is max possible len has been achieved
            if(maxSubStrLen == ALL_CHAR_NUM) break;

            // update substr to new length
            int newSubStrStartIdx = charIdxInSubStr[ s[i] ] + 1;
            curSubStrLen = i - newSubStrStartIdx + 1;

            // update idx cond for new sub str
            charIdxInSubStr[ s[i] ] = i;
            for(int &idx : charIdxInSubStr) {
                if(idx == INVALID_IDX) continue;
                if(idx < newSubStrStartIdx) idx = INVALID_IDX;
            }
        }

        return maxSubStrLen;
    }
};
```


### V4.2：優化的版本 - 更新 sub-str 的時候只處理「old sub-str 被剔除部分的 char idx record」
- **注意：一定要先剔除舊的 sub-str 重疊部分，再更新「當前掃到的 char 的 record idx」**
	- 否則如果先設定當前掃到的 char 的 record idx，再剔除「舊的 sub-str 重疊部分 record idx 的時候，因為這個被剔除區段也包含新掃到的 char -> 會不小心把前面設定好的 new scan char idx record 給清除掉」
```Cpp
#define INVALID_IDX (-1)
#define ALL_CHAR_NUM (256)
#define CHAR_TO_IDX(_CHAR_) (_CHAR_ - CHAR_MIN)
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // to record the char index in substr
        vector<int> charIdxInSubStr(ALL_CHAR_NUM, INVALID_IDX);

        // init result
        int maxSubStrLen = 0;

        // check sub str
        int subStrStartIdx = 0, curSubStrLen = 0;
        for(int i = 0; i < s.size(); i++) {
            // extend sub str &
            if(charIdxInSubStr[ CHAR_TO_IDX(s[i]) ] == INVALID_IDX) {
                // extend cur substr
                curSubStrLen++;
                charIdxInSubStr[ CHAR_TO_IDX(s[i]) ] = i;

                // update max substr len
                maxSubStrLen = max(maxSubStrLen, curSubStrLen);
                continue;
            }

            // is max possible len has been achieved
            if(maxSubStrLen == ALL_CHAR_NUM) break;

            // start index of new sub-str
            int newSubStrStartIdx = charIdxInSubStr[ CHAR_TO_IDX(s[i]) ] + 1;

            // clear idx record of before the new sub-str
            for(int j = subStrStartIdx; j < newSubStrStartIdx; j++) {
                charIdxInSubStr[ CHAR_TO_IDX(s[j]) ] = INVALID_IDX;
            }

            // update index for the currently scanned char in new sub-str
            charIdxInSubStr[ CHAR_TO_IDX(s[i]) ] = i;

            // update the sub-str length & start index
            curSubStrLen = i - newSubStrStartIdx + 1;
            subStrStartIdx = newSubStrStartIdx;
        }

        return maxSubStrLen;
    }
};
```