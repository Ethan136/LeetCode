# LeetCode
[567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)

# Answer - Sliding Window - O(N) - 比較複雜
## Answer - 使用 Hash 記錄檢查過的字元計數 -> ScanWindow 最多只維持一個寬度，超過這個寬度代表有不符合的情況發生
```Cpp
class Solution {
public:

	bool checkInclusion(string s1, string s2) {
		// if str length 1 > length 2 -> not possible
		if(s1.size() > s2.size()) return false;

		// record the component hash of s1 equal the one in s2
		int s1Hash['z'-'a'+1] = {};
		for(char s1_char : s1) s1Hash[s1_char - 'a']++;

		// record the checked pass char in sliding window
		int s2Hash['z'-'a'+1] = {};

		// left: not include in check pass
		// right: included in check pass
		for(int left = -1, right = 0; right < s2.size(); right++) {
			// the current char in check
			char curChar = s2[right];

			// record the current char in s2 checked region &&
			// if current char in s2 does not exceed the num in s1 -> check next one
			if(++s2Hash[curChar - 'a'] <= s1Hash[curChar - 'a']) {
				// update check pass number & check if check pass
				if((right - left) == s1.size()) return true;

				// if still in check
				continue;
			}

			// if current char in s2 exceeds the num in s1
			// (1) update window left (not included region) to ensure the curChar repeated cnt in checked region is valid
			// (2) reduce check pass num & s2Hash char Cnt on the "left position
			while(s2Hash[curChar - 'a'] > s1Hash[curChar - 'a']) {
				s2Hash[ s2[++left] - 'a' ]--;
			}
		}
		return false;
	}
};
```
想法
- check pass length = *right - left*
	- left 不包含 -> *start index = -1*
	- right 包含
- 一旦掃到某個 s2 index 造成『s2 check-pass hash table 記錄的 repeat 次數超出 s1』
	- **這時候就一直移動 left，直到把超出 repeat 次數的字元移出 window**
	- **此外，left 更新的時候，『s2 check-pass hash table 也要針對 left 更新時剔除的字元進行更新』


## Answer - 使用 map 記錄檢查過的字元位置 -> 一旦新檢查的字元不合，就把 left 往後更新到『check windows 內第一個相同字元位置』
### 解法1: 使用 vector 操作 vector.erase(vector.begin()) 造成時間複雜度 N^2
```Cpp
class Solution {
public:

	bool checkInclusion(string s1, string s2) {
		// if str length 1 > length 2 -> not possible
		if(s1.size() > s2.size()) return false;

		// record the component hash of s1 equal the one in s2
		int s1Hash['z'-'a'+1] = {};
		for(char s1_char : s1) s1Hash[s1_char - 'a']++;

		// record the hash of s2 reflecting to "the indexes within checked region of s1"
		int checkPassNum = 0;
		unordered_map<char, vector<int>> s1StrInS2CheckedRegion;

		// left: not included in check pass
		// right: included in check pass
		for(int left = 0, right = 0; right < s2.size(); right++) {
			// the current char in check
			char curChar = s2[right];

			// record the current char in s2 checked region
			s1StrInS2CheckedRegion[curChar].push_back(right);

			// if current char in s2 does not exceed the num in s1 -> check next one
			if(s1StrInS2CheckedRegion[curChar].size() <= s1Hash[curChar - 'a']) {
				// update check pass number & check if check pass
				if(++checkPassNum == s1.size()) return true;

				// if still in check
				continue;
			}

			// if current char in s2 exceeds the num in s1 -> update left (not included)
			left = s1StrInS2CheckedRegion[curChar].front();

			// takeout the registered index <= left & reset check pass num
			checkPassNum = 0;
			for(auto& Pair : s1StrInS2CheckedRegion) {
				vector<int>& IndexVec = Pair.second;
				while(IndexVec.size() && IndexVec.front() <= left) IndexVec.erase(IndexVec.begin());
				checkPassNum += IndexVec.size();
			}
		}
		return false;
	}
};
```

### 解法2: 使用 deque 操作 deque.pop_front() 讓時間複雜度爲 O(N)
```Cpp
class Solution {
public:

	bool checkInclusion(string s1, string s2) {
		// if str length 1 > length 2 -> not possible
		if(s1.size() > s2.size()) return false;

		// record the component hash of s1 equal the one in s2
		int s1Hash['z'-'a'+1] = {};
		for(char s1_char : s1) s1Hash[s1_char - 'a']++;

		// record the hash of s2 reflecting to "the indexes within checked region of s1"
		int checkPassNum = 0;
		unordered_map<char, deque<int>> s1StrInS2CheckedRegion;

		// left: not included in check pass
		// right: included in check pass
		for(int left = 0, right = 0; right < s2.size(); right++) {
			// the current char in check
			char curChar = s2[right];

			// record the current char in s2 checked region
			s1StrInS2CheckedRegion[curChar].push_back(right);

			// if current char in s2 does not exceed the num in s1 -> check next one
			if(s1StrInS2CheckedRegion[curChar].size() <= s1Hash[curChar - 'a']) {
				// update check pass number & check if check pass
				if(++checkPassNum == s1.size()) return true;

				// if still in check
				continue;
			}

			// if current char in s2 exceeds the num in s1 -> update left (not included)
			left = s1StrInS2CheckedRegion[curChar].front();

			// takeout the registered index <= left & reset check pass num
			checkPassNum = 0;
			for(auto& [charKey, deqIdx] : s1StrInS2CheckedRegion) {
				while(deqIdx.size() && deqIdx.front() <= left) deqIdx.pop_front();
				checkPassNum += deqIdx.size();
			}
		}
		return false;
	}
};
```

### Note
想法記錄
- **核心概念：沒當掃描到某個 s2[i] = char_x 的時候，如果發生當下的 scanned region 和 s1 不匹配 -> 則吧 window left 更新到『最先前一次記錄 char_x 的位置』
	- 更新 window 後要把這個位置前的 scan 情況都清除

- *Sliding window left 可以設定爲 not include，並且 right 爲 include*
	- **這樣感覺比較有一致性**

- left 初始化
	- left = -1 -> left 不包含在 check pass window 區塊
	- left = 0 -> left 包含在 check pass window 區塊


演算法記錄
- **使用 unsorted_map 操作 element 注意事項**
	- `for(auto Pair : map)` 會取得 map 裏面的 Pair 的 DeepCopy（不是 shallow copy）
	- 如果要更改 map 裏面 Pair 的內容 -> 要使用 reference `for(auto& Pair : map)`
	- 上面這個寫法，可以改成 `for(auto& [key, val] : map)` -> 這樣寫比較好看


**時間複雜度 O(N^2) 的原因**
-主要瓶頸在於 vector.erase(begin) 造成的 左移 O(length) 開銷。
- 若改用 deque 或僅保留計數（經典滑動視窗兩個長度 26 的陣列），
- 所有操作皆成 O(1)，即可把時間複雜度降到 O(n)。


## Answer - 這個是看錯題目需求，以爲『s1 反向字串在 s2 要完全符合』
```Cpp
class Solution {
public:
	bool CheckSubStrOfS1WithinS2(string s1, int checklenS1FromStart, string s2, int startIndexS2) {
		for(int i = 0; i < checklenS1FromStart; i++) {
			if(s1[i] != s2[startIndexS2+i]) return false;
		}
		return true;
	};

	bool checkInclusion(string s1, string s2) {
		// if str length 1 > length 2 -> not possible
		if(s1.size() > s2.size()) return false;

		// reverse s1
		reverse(s1.begin(), s1.end());

		// to record all the index of scanned s2[i] which matched the start char of s1
		vector<int> s1StartCharOns2;

		// search through s2 (should be longer)
		// - search left point: on s2 (not included)
		// - searcch right point: n s2 (scanned)
		for(int s1CheckIdx = 0, left = 0, right = 0; right < s2.size(); right++) {
			// (0) record s1 start char idnex in s2
			if(s1[0] == s2[right]) {
				s1StartCharOns2.push_back(right);
			}

			// (1) check identical: s1 is the base standard should be satisfied -> check s2[i] = s1[j]
			if(s1[s1CheckIdx] == s2[right]) {
				// update next check index of s1
				s1CheckIdx++;

				// check whether s1 whole matched
				if(s1CheckIdx == s1.size()) return true;

				// if s1 has not been checked finish yet -> check next term
				continue;
			}

			// (2) different -> re-start search from the s2 position
			bool s1SubStrOnS2ScanPass = false;
			while(!s1SubStrOnS2ScanPass && s1StartCharOns2.size()) {
				// search from the recorded s2 index with s1 start char to the right
				int s1StartCharIndexOns2 = s1StartCharOns2.front();
				int s1CheckSubStrLen = (right - s1StartCharIndexOns2 +1);

				// check sub-str of s1 on the already-scanned region of s2
				if(s1SubStrOnS2ScanPass = CheckSubStrOfS1WithinS2(s1, s1CheckSubStrLen, s2, s1StartCharIndexOns2)) {
					// update left to next start chart index on s2
					left = s1StartCharIndexOns2;

					// update start check index of 1s for next term
					s1CheckIdx = s1CheckSubStrLen;
				}

				// the out the index used in s1 sub-str rescan
				s1StartCharOns2.erase( s1StartCharOns2.begin() );
			}

			// (3) if s1 sub-str match the already-scanned region in s2 -> update left to right
			if(s1SubStrOnS2ScanPass == false) {
				left = right;
				s1CheckIdx = 0;
			}
		}
		return false;
	}
};
```


# Answer - Sliding Window + Hash Map - O(N) - 比較簡單
## V2 複習1st時候想到的 - 掃描固定 s1 寬度的 window，檢查是否 s1 / s2 substr 字串計數想同 - O(n * 26)
- 概念最簡單 -> **但這個做法其實不算是 sliding window**
- 如果 s2 裡面包含 s1 字串的順序調整後的字串
	- -> **s2 裡面某個長度等於 s1 的範圍，裡面的字元統計等於 s1 的字元統計**
- 先檢查 s1 字元統計
- 再用一個變數紀錄『s1 和 s2 字元統計的差異』
	- **這個變數一開始是對應 s2 index [ 0 to s1.size()-1 ], 後續在 s1 裡面橫向平移 window，每次都更新  『s1 和 s2 substr 字元統計的差異』**
	- 一旦某次更新後 s1 和 s2 substr 字元統計差異等於0 -> 代表符合題目要求『s2 裡面的某個區段順序調整後等於 s1』
```Cpp
class Solution {
private:
    bool checkVectorAllZero(vector<int> &vec) {
        for(auto element : vec) if(element) return false;
        return true;
    }
public:
    bool checkInclusion(string s1, string s2) {
        if(s1.size() > s2.size()) return false;

        // count each alphabet within s1
        vector<int> s1AlphabetCnt(26, 0);
        for(char c : s1) s1AlphabetCnt[ c - 'a' ]++;

        // dff of char count of the substring within s2
        // = s1 alphabet count - s2 substr alphabet cnt
        vector<int> s2SubStrAlphabetCntDiff(s1AlphabetCnt);

        // initial condition: range [0, s1.length-1]
        for(int i = 0; i < s1.size(); i++) s2SubStrAlphabetCntDiff[ s2[i] - 'a' ]--;
        if(checkVectorAllZero( s2SubStrAlphabetCntDiff )) return true;

        // slide the range from [0, s1.length-1] to [s2.size() - s1.len, s2.size()-1]
        for(int l = 1, r = s1.size(); r < s2.size(); l++, r++) {
            // previous left edge move out of the window -> revert the diff cnt by add
            s2SubStrAlphabetCntDiff[ s2[l-1] - 'a' ]++;

            // add new right edge to the window -> add new diff cnt by minus
            s2SubStrAlphabetCntDiff[ s2[r] - 'a' ]--;

            // check if all char count is zero
            if(checkVectorAllZero( s2SubStrAlphabetCntDiff )) return true;
        }

        return false;
    }
};
```


## V3 複習1st時候寫的 - V2 改良版 - 試著讓 sub str 整個 range 都是 valid - > 比較複雜
```Cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if(s1.size() > s2.size()) return false;

        // char cnt within s1
        vector<int> s1CharCnt(26, 0);
        for(auto c : s1) s1CharCnt[c - 'a']++;

        // to record the char cnt within s2 sub str
        vector<int> s2SubStrCharCnt(26, 0);

        // initialize sliding window with valid char
        int l, r;
        for(l = 0, r = 0; r < s2.size(); l++, r++) {
            if( !s1CharCnt[ s2[r] - 'a' ] ) continue;

            s2SubStrCharCnt[ s2[r] - 'a' ]++;
            break;
        }

        // check through the remained s2
        while(r < s2.size()) {

            // check the valid sub str condition before updaing
            int validSubStrLen = r - l + 1;
            if(validSubStrLen == s1.size()) return true;

            // try to extend the sub str length
            r++;

            // check whether s2 end is reached
            if(r >= s2.size()) break;

            // record extended str to couner
            s2SubStrCharCnt[ s2[r] - 'a' ]++;

            // check the extended sub str -> if valid
            if(s2SubStrCharCnt[ s2[r] - 'a' ] <= s1CharCnt[ s2[r] - 'a' ]) continue;

            // if the extended sub str is invalid -> left side move right ward & pop out left char
            while(s2SubStrCharCnt[ s2[r] - 'a' ] > s1CharCnt[ s2[r] - 'a' ]) {
                s2SubStrCharCnt[ s2[l++] - 'a' ]--;
            }

            // if the length of shortened sub-str is not zero
            if(l <= r) continue;
        
            // if the shortened sub-str is zero-length -> need to re-find valid sub-range [l, r] 
            for(r = l; r < s2.size(); l++, r++) {
                if( !s1CharCnt[ s2[r] - 'a' ] ) continue;

                s2SubStrCharCnt[ s2[r] - 'a' ]++;
                break;
            }
        }

        return false;
    }
};
```

## V4 複習2nd 時候想到的 - 把 s1 所有 char 設定成一個 statistic，掃描 s2 並且隨時檢查是否有某個 sub-range 可以符合這個 statistic
```Cpp
#define INVALID_IDX (-1)
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if(s1.size() > s2.size()) return false;

        unordered_map<char, int> needCharStatistic;
        for(char c : s1) needCharStatistic[c] += 1;

        int subStrStartIdx = INVALID_IDX;
        int subStrLen = 0;
        for(int i = 0; i < s2.size(); i++) {

            // if current char is not in s1
            if(!needCharStatistic.count(s2[i])) {
                // kick out the un-finished sub-str in statistic
                for(int j = subStrStartIdx; (j != INVALID_IDX) && (j < i); j++) needCharStatistic[s2[j]]++;

                // reset start idx of sub-str
                subStrStartIdx = INVALID_IDX;

                // reset the char type num need to be checked
                subStrLen = 0;
                continue;
            }

            // if current char is in s1 and not exceed required num
            if(needCharStatistic[s2[i]] > 0) {
                // update substr start idx if necessary
                if(subStrStartIdx == INVALID_IDX) subStrStartIdx = i;

                // update sub-str len
                subStrLen++;

                // update remained statistic
                needCharStatistic[s2[i]]--;

                // check if all char in s1 is satisfied
                if(subStrLen == s1.size()) return true;
            }

            // if current char is in s1 but exceed required num
            else {
                // to record new start idx of substr
                int newSubStrStartIdx = INVALID_IDX;

                // kick out the un-finished sub-str in statistic
                for(int j = subStrStartIdx; (j < i); j++) {

                    // recover the required char num statistic
                    needCharStatistic[s2[j]]++;

                    // find until the first num-exceeded char in old sub-str part has not been found
                    if(s2[j] != s2[i]) continue;

                    // if the first exceeded char in old sub-str has been taken out
                    // -> record new start idx of sub-str on the index next to first appeared used-up char
                    newSubStrStartIdx = j+1;
                    break;
                }

                // update sub-str info
                subStrStartIdx = newSubStrStartIdx;
                subStrLen = i - subStrStartIdx + 1;

                // include the newly scanned char in statistic
                needCharStatistic[s2[i]]--;
            }
        }
        return false;
    }
};
```

## V5 複習2nd - 依照模板來寫
- **這個寫法比較好，速度也比較快**
```Cpp
#define CHAR_TO_IDX(c) (c - CHAR_MIN)
#define INVALID_IDX (-1)
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
	    // if input length invalid
	    if(s1.size() > s2.size()) return false;

		// record char statistic in s1
		vector<int> needCharCntForS1(UCHAR_MAX+1, 0);
		for(auto c : s1) needCharCntForS1[ CHAR_TO_IDX(c) ]++;

		// init sliding window of sub-string
		int subStrStartIdx = INVALID_IDX;
		int subStrLen = 0;

		// check through s2 until sub-str in certain region matched the statistic of s1
		for(int i = 0; i < s2.size(); i++) {

			// extend sub-str sliding window
			// (1) if the sub-str sliding window is zero size -> set start idx
			if(subStrStartIdx == INVALID_IDX) subStrStartIdx = i;
			// (2) update sub-str len & statistic
			subStrLen++;
			needCharCntForS1[ CHAR_TO_IDX(s2[i]) ]--;
			
			// if the extended sub-str window is invalid -> new added char exceeds the char requirement of s1
			// (1) shorten sub-str by moving the start idx + restore the required char cnt of s1 when moving char out of range
			while(needCharCntForS1[ CHAR_TO_IDX(s2[i]) ] < 0) {
				needCharCntForS1[ CHAR_TO_IDX(s2[subStrStartIdx]) ]++;
				subStrStartIdx++;
				subStrLen--;
			}
			// (2) check if the shortened sub-str is valid (or empty with length 0)
			if(subStrLen == 0) subStrStartIdx = INVALID_IDX;

			// if sub-str window matches s1
			if(subStrLen == s1.size()) return true;
		}

		// finish
		return (subStrLen == s1.size());
    }
};
```