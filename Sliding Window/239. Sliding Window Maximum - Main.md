# LeetCode
[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

# Answer: 使用 deque 記錄每次 local range 內 [Highest to rightest 的排序情況，並且忽略 valley value] - O(N)
## V1:  寫法比較難看
```Cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // initialize result
        vector<int> result(nums.size() - (k-1));

        // index of window: l = left (included) / r = right (included)
        int l = 0, r = 0;

        // use deque to stor the "local max" to "low" within the range
        deque<int> deqHtoLRecIdx = {nums[0]};
        for(r = 1; r < k; r++) {
            while(deqHtoLRecIdx.size() && deqHtoLRecIdx.back() < nums[r]) deqHtoLRecIdx.pop_back();
            deqHtoLRecIdx.push_back(nums[r]);
        }
        result[l] = deqHtoLRecIdx.front();

        // check the remained nums
        for( ; r < nums.size(); r++) {
            // check the moved r
            while(deqHtoLRecIdx.size() && deqHtoLRecIdx.back() < nums[r]) deqHtoLRecIdx.pop_back();
            deqHtoLRecIdx.push_back(nums[r]);

            // check before move l
            if(nums[l] >= deqHtoLRecIdx.front()) deqHtoLRecIdx.pop_front();

            // move l
            l++;

            // record the local max
            result[l] = deqHtoLRecIdx.front();

        }

        return result;

    }
};
```

- 每次 move window 檢查項目
	- 左邊移出去的是否爲 max
	- 左邊移出去的如果是 max，則中間是否有 second max / third max ...
		- **中間的 local min （valley value) 不重要** 
	- 右邊加進來的是否爲 max
- 重點：儲存格式『用一個 Queue 記錄當下 range 內 Highest to Low 的排序』
	- [5, 6, 7, 3, -1,  2] -> 記錄 [7, 3, 2]
	- [1,-2, 8, 1, 4] -> 記錄 [8, 4]
- 上面這個儲存方式的用途
	- front： 一定是 local range 內最大值
	- back：一定是 local range 最小值
- MoveSlidingWindow 執行邏輯
	- 先把右邊的加進來 -> 更新 local max 儲存結構的內容
	- 再把最左邊的踢掉 -> 更新 local max 儲存結構的內容
	- 記錄 local max 儲存結構的最大值到 result
- deque\<int\> 可以使用 push_front() / pop_back() -> *適合這一題的情況*


## V2：優化寫法，比較簡潔
```Cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;

        deque<pair<int, int>> windowMaxValueQue;
        for(int i = 0; i < nums.size(); i++) {

            // pop back if the value less than num[i]
            while(  windowMaxValueQue.size() && 
                    windowMaxValueQue.back().second < nums[i]) windowMaxValueQue.pop_back();
    
            // push to queue: {index, value}
            windowMaxValueQue.push_back({i, nums[i]});

            // if the windws has not full extended
            int windowLeftIdx = (i - k + 1);
            if(windowLeftIdx < 0) continue;

            // pop front if the max value within window should be move out
            while(  windowMaxValueQue.size() &&
                    windowMaxValueQue.front().first < windowLeftIdx ) windowMaxValueQue.pop_front();

            // record the max value within the window
            result.push_back(windowMaxValueQue.front().second);
        }

        return result;
    }
};
```


## V3：使用 vector + indicator 取代 deque 避免動態記憶體配置
```Cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;

        vector<pair<int, int>> windowMaxValueQue(k+1);
        int queHead = 0;
        int queLen = 0;

        for(int i = 0; i < nums.size(); i++) {

            // pop back if the value less than num[i]
            while(  queLen && 
                    windowMaxValueQue[(queHead + queLen - 1) % windowMaxValueQue.size()].second < nums[i]) queLen--;

            // push to queue: {index, value}
            windowMaxValueQue[(queHead + queLen) % windowMaxValueQue.size()] = {i, nums[i]};
            queLen++;
    
            // if the windws has not full extended
            int windowLeftIdx = (i - k + 1);
            if(windowLeftIdx < 0) continue;

            // pop front if the max value within window should be move out
            while(  queLen &&
                    windowMaxValueQue[queHead].first < windowLeftIdx ) {
                        
                    queHead = (queHead + 1) % windowMaxValueQue.size();
                    queLen--;
            }

            // record the max value within the window
            result.push_back(windowMaxValueQue[queHead].second);
        }

        return result;
    }
};
```

## V4：複習 2nd 時候寫的
- 隨時要保留各個數字 -> 才不會 move 的時候一旦把最大值移除，就沒有後續資訊 -> 新的資訊依照順序收入 -> 需要push
- 但如果當前 input 在最右邊而且比前面的大 
	- -> 因為前面的會先 pop out ，而且前面的在檢查的時候，他們的 value 不重要（比當前這個 idnex 比較後面的小），所以前面的資訊就不用保留
- 移動的時候，隨時要把儲存的資訊，剔除最左邊的 -> 需要 pop
- 使用 deque: 左邊可以 pop / 右邊可以 push / 當前新收入的 num 比先前的大的時候 -> 壓縮資訊時 pop 右邊的
```Cpp
class Solution {
private:
	struct idxToVal_t {
		int idx;
		int val;
	};
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result(nums.size() - (k-1));

		// init the window
		deque<idxToVal_t> incValInWindow;
		for(int i = 0; i < k; i++) {
			while(incValInWindow.size() && (incValInWindow.back().val < nums[i]) ) incValInWindow.pop_back();
			incValInWindow.push_back({i, nums[i]});
		}
		result[0] = incValInWindow.front().val;

		// scan through the array
		for(int i = 1; i < result.size(); i++) {
			// pop out left element
			if(incValInWindow.size() && (incValInWindow.front().idx < i) ) incValInWindow.pop_front();

			// check to push in right element
			int addNumIdx = i + k - 1;
			while(incValInWindow.size() && (incValInWindow.back().val < nums[addNumIdx]) ) incValInWindow.pop_back();
			incValInWindow.push_back({addNumIdx, nums[addNumIdx]});

			// check window max & record
			result[i] = incValInWindow.front().val;
		}

        return result;
    }
};
```
