# LeetCode
[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

# Answer：先排序，然後進行 merge
## V1: 額外一個 vector 裝 result
```Cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // if the intervals is one or empty
        if(intervals.size() <= 1) return intervals;

        // helper func to sort interval by
        auto intervalLess = [](auto const &itvl1, auto const &itvl2) {
            return (itvl1[0] < itvl2[0]);
        };

        // sort the intervals
        sort(intervals.begin(), intervals.end(), intervalLess);

        // helper func to do merege
        auto checkOverlapAndMergeToFisrt = [](auto &itvl1, auto &itvl2) {
            if(itvl1[1] < itvl2[0]) return false;
            if(itvl2[1] < itvl1[0]) return false;

            itvl1[0] = min(itvl1[0], itvl2[0]);
            itvl1[1] = max(itvl1[1], itvl2[1]);
            return true;
        };

        // merge all intervals into the result
        vector<vector<int>> result;
        result.reserve( intervals.size() );
        for(int i = 0, nextIdx; i < intervals.size(); i = nextIdx) {

            // assume there's no overlap -> push to result
            result.push_back( intervals[i] );

            // if there's any overlap -> merge interval and check next one
            nextIdx = i + 1;
            while(nextIdx < intervals.size() && checkOverlapAndMergeToFisrt( result.back(), intervals[nextIdx] )) {
                nextIdx++;
            }
        }

        // finish
        return result;
    }
};
``` 

## V2: 直接在原始 interval 執行 merge
- 如果下一個 interval 有 overlay -> 執行 merge 並且更新 overlap cnt -> **注意：overlay cnt 可以是 0**
- 每個 loop 的 i 更新為 i + overlap cnt + 1
```Cpp
#define prtVar3(var1, var2, var3) cout << #var1 << ": " << var1 << " | "#var2 << ": " << var2 << " | "#var3 << ": " << var3 << endl;

class Solution {
private:
        bool intervalOverlap(auto &intervals, int i, int j) {
            if(i >= j) return false;
            if(i < 0 || i >= intervals.size()) return false;
            if(j < 0 || j >= intervals.size()) return false;

            if(intervals[i][1] < intervals[j][0]) return false;
            if(intervals[j][1] < intervals[i][0]) return false;

            return true;
        }
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // sort the intervals
        auto cmpIntv = [](auto &a, auto &b) {
            return a[0] < b[0];
        };
        sort(intervals.begin(), intervals.end(), cmpIntv);

        // merge all overlapped intervals
        int intvResultCnt = 0;
        for(int i = 0, overlapCnt = 0;
                i < intervals.size();
                i+=(overlapCnt+1), intvResultCnt++) {

            // overlap -> merge to index i
            overlapCnt = 0;
            while(intervalOverlap(intervals, i, i+overlapCnt+1)) {
                overlapCnt++;
                intervals[i][0] = min(intervals[i][0], intervals[i+overlapCnt][0]);
                intervals[i][1] = max(intervals[i][1], intervals[i+overlapCnt][1]);
            }

            // shif-store to the new index with merge
            intervals[intvResultCnt] = intervals[i];
        }

        // resize the result
        intervals.resize(intvResultCnt);

        // finish
        return intervals;
    }
};
```


# Answer：採用『2 Interval Array Merge 時的通用格式』
- **概念詳見： [[57. Insert Interval - Main]]**

## 複習2nd
```Cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // sort the intervals
        auto cmpItvl = [](auto &a, auto &b) {
            return a[0] < b[0];
        };
        sort(intervals.begin(), intervals.end(), cmpItvl);

        // init result
        vector<vector<int>> result;
        result.reserve(intervals.size());

        // merge add intervals to result
        int i = 0;
        while(true) {
            if(i >= intervals.size()) break;

            vector<int> *pSelectItvl = &intervals[i++];

            if(result.empty() || (result.back()[1] < (*pSelectItvl)[0])) {
                result.push_back(*pSelectItvl);
            }
            else {
                result.back()[1] = max(result.back()[1], (*pSelectItvl)[1]);
            }
        }

        // finish
        return result;
    }
};
```