---
ParentTask:
  - "[[intervals]]"
---

# LeetCode
[435. Non-Overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)

# Concept
- **類似 sliding window 的概念，先選一個當作 current interval，後面選一個當作 next interval -> 兩個比較有沒有 overlap**
- 發生 overlap 的時候，把『end index 比較遠的移除』 -> 因為這一個更有可能會和後面的 overlay -> **Greedy**
- 發生 overlap 的時候，如果要移除『current index』，則 current index 更新到 next index，next index++ -> **當前留下的 next index 設為 current 下一輪繼續用**
- 發生 overlap 的時候，如果要移除『next index』，則 current index 不更新，並且 next index++ -> **current index 下一輪留著繼續拿來檢查**

# Answer
## V1：第一次寫，說明比較詳細
```Cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {

        // helper func for interval sort
        auto cmpInterval = [](auto &a, auto &b) {
            return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
        };

        // sort the intervals
        sort(intervals.begin(), intervals.end(), cmpInterval);

        // check each interval
        int removeCnt = 0;
        for(int chkIdx = 0, nextIdx = chkIdx+1; nextIdx < intervals.size(); nextIdx++) {
            // of the two interval are not overlapped
            if(intervals[chkIdx][1] <= intervals[nextIdx][0]) {
                chkIdx = nextIdx;
                continue;
            }

            // update remove counter
            removeCnt++;

            // remove next interval
            if(intervals[chkIdx][1] <= intervals[nextIdx][1]) {
                continue;
            }
            // remove current interval
            else {
                chkIdx = nextIdx;
            }
        }

        return removeCnt;
    }
};
``` 

## V2 - 複習時候寫的
```Cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        auto cmpIntv = [](auto &a, auto &b) {
            return a[0] < b[0];
        };
        sort(intervals.begin(), intervals.end(), cmpIntv);

        int removeCnt = 0;
        for(int i = 0, nextIdx = 1; nextIdx < intervals.size(); ) {

            // if non-overlap -> check next
            if(intervals[i][1] <= intervals[nextIdx][0]) {
                i = nextIdx++;
                continue;
            }

            // if overlay occurs -> choose the extend-further one to remove
            // (0) update remove cnt
            removeCnt++;

            // (a) remove the next interval
            if(intervals[i][1] < intervals[nextIdx][1]) {

                // next idx move right (current index stay)
                nextIdx += 1;
            }
            // (b) remove the current interval
            else {

                // current index updat to next index & update next index
                i = nextIdx++;
            }
        }

        return removeCnt;
    }
};
```