---
ParentTask:
  - "[[intervals]]"
---

# LeetCode
[57. Insert Interval](https://leetcode.com/problems/insert-interval/)

# Concept
- 直覺想法：把 new interval 丟到現有的 interval array 裡面，然後做 sort，再看需不需要 merge -> **速度很慢而且沒必要**
- 務實作法
	- 把 interval array 分成三個部分 -> **這三個部分依序處理**
	- 1）位在 new interval 左邊不重疊的：可以直接放到 result
	- 2）和 new interval 重疊的：必須做 merge 直到剩下一個 interval
	- 3）位在 new interval 右邊不重疊的：可以直接放到 result

# Answer：1 Interval Array + insert 1 interval
## V1：額外用一個 vector 裝答案
```Cpp
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        // new interval vector
        vector<vector<int>> result;

        // set additional interval as merge target
        auto &mergedInterval = newInterval;

        // check all interval indicator
        int idx = 0;

        // [non-overlap interval: store in new vector]
        // (1) intervals[i] prior to new one -> direct store to new vect
        for(; idx < intervals.size(); idx++) {
            if(intervals[idx][0] > mergedInterval[0]) break;

            if(intervals[idx][1] >= mergedInterval[0]) break;

            result.push_back(intervals[idx]);
        }

        // [overlapped merge]
        // (2) intervals[i] overlap with merged one
        // a. loop: merge intervals[i] with merged interval
        for(;idx < intervals.size(); idx++) {
            if(intervals[idx][0]> mergedInterval[1]) break;

            mergedInterval[0] = min(mergedInterval[0], intervals[idx][0]);
            mergedInterval[1] = max(mergedInterval[1], intervals[idx][1]);
        }
        // b. break: stor metged interval
        result.push_back(mergedInterval);

        // [non-overlap interval: store in new vector]
        // (3) intervals[i] later than merge one -> direct stor to new vect
        for(; idx < intervals.size(); idx++) {
            result.push_back(intervals[idx]);
        }

        // finish
        return result;
    }
};
```

## V2：直接改原始 interval
- **vector.erase: ( start iteration, end iteration (不包含) )**
```Cpp
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        // to indicate the interval num of result
        int resultLength = 0;

        // set additional interval as merge target
        auto &mergedInterval = newInterval;

        // check all interval indicator
        int idx = 0;

        // [non-overlap interval: store in new vector]
        // (1) intervals[i] prior to new one -> direct store to new vect
        for(; idx < intervals.size(); idx++) {
            if(intervals[idx][0] > mergedInterval[0]) break;

            if(intervals[idx][1] >= mergedInterval[0]) break;

            resultLength++;
        }

        // [overlapped merge]
        // (2) intervals[i] overlap with merged one
        // a. loop: merge intervals[i] with merged interval
        int mergeIntervReduceCnt = 0;
        for(;idx < intervals.size(); idx++, mergeIntervReduceCnt++) {
            if(intervals[idx][0]> mergedInterval[1]) break;

            mergedInterval[0] = min(mergedInterval[0], intervals[idx][0]);
            mergedInterval[1] = max(mergedInterval[1], intervals[idx][1]);
        }
        // b. break: store metged interval + handle the remained non-overlap interval
        if(mergeIntervReduceCnt) {
            // if merge & interval reduce was proceeded
            intervals[resultLength++] = mergedInterval;

            // the redundant interval that should be removed
            int intervalRemove = (mergeIntervReduceCnt-1);

            // remained clear the merged interval
            if(intervalRemove) intervals.erase(intervals.begin()+resultLength, intervals.begin()+resultLength+intervalRemove);
        }
        else {
            // if the new interval is not overlapped with any interval
            intervals.insert(intervals.begin()+resultLength, mergedInterval);
        }

        // finish
        return intervals;
    }
};
```

# Answer：2 Interval Arrays Merge (複習 2nd - 這個作法比較好)
- **類似 merge sort two sorted link list array 的作法**
- 兩個 array 各自依照 interval start 進行 sort
- 然後每個 loop 從兩個 interval array 挑選出 start point 比較小的進
	- 檢查是否需要和 result[ last ] 進行 merge（merge 後 interval end 採用 max{ result.back()[1], add interval[1]}
	- 如果不用 merge，則 selected interval 直接加入 result
```Cpp
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        // if added interval array is empty
        if(newInterval.size() == 0) return intervals;

        // sort added intervals
        vector<vector<int>> newIntervals = {newInterval};
        auto cmpInterval = [](vector<int> &a, vector<int> &b) {
            return a[0] < b[0];
        };
        sort(newIntervals.begin(), newIntervals.end(), cmpInterval);

        // check if origin interval array is empty
        if(intervals.size() == 0) return newIntervals;

        // init result with capacity of max possitble interval num
        vector<vector<int>> result;
        result.reserve(intervals.size() + newIntervals.size());

        // check from intervals i = 0 & added interval j = 0
        int i = 0, j = 0;
        while(true) {

            // A: select earlier interval from two array to result
            vector<int> *pSelectItvl;

            // (0) no intervals remain
            if((i >= intervals.size()) && (j >= newIntervals.size())) break;

            // (1) only remain interval[i]
            if(j >= newIntervals.size()) pSelectItvl = &intervals[i++];

            // (2) only remain new interval[j]
            else if(i >= intervals.size()) pSelectItvl = &newIntervals[j++];

            // (3) select interval with earlier start from arrays
            else if(intervals[i][0] < newIntervals[j][0]) pSelectItvl = &intervals[i++];
            else pSelectItvl = &newIntervals[j++];

            // B: add interval[i] to result
            // (1) if overlap with last iterval in result -> merge
            if(result.size() && ((*pSelectItvl)[0] <= result.back()[1]) ) {
                result.back()[1] = max(result.back()[1], (*pSelectItvl)[1]);
            }
            // (2) interval non overlap -> add to result
            else {
                result.push_back(*pSelectItvl);
            }
        }

        // finish
        return result;
    }
};
```