---
ParentTask:
  - "[[intervals]]"
---

# LeetCode
[57. Insert Interval](https://leetcode.com/problems/insert-interval/)

# Concept
- 直覺想法：把 new interval 丟到現有的 interval array 裡面，然後做 sort，再看需不需要 merge -> **速度很慢而且沒必要**
- 務實作法
	- 把 interval array 分成三個部分 -> **這三個部分依序處理**
	- 1）位在 new interval 左邊不重疊的：可以直接放到 result
	- 2）和 new interval 重疊的：必須做 merge 直到剩下一個 interval
	- 3）位在 new interval 右邊不重疊的：可以直接放到 result

# Answer
## V1：額外用一個 vector 裝答案
```Cpp
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        // new interval vector
        vector<vector<int>> result;

        // set additional interval as merge target
        auto &mergedInterval = newInterval;

        // check all interval indicator
        int idx = 0;

        // [non-overlap interval: store in new vector]
        // (1) intervals[i] prior to new one -> direct store to new vect
        for(; idx < intervals.size(); idx++) {
            if(intervals[idx][0] > mergedInterval[0]) break;

            if(intervals[idx][1] >= mergedInterval[0]) break;

            result.push_back(intervals[idx]);
        }

        // [overlapped merge]
        // (2) intervals[i] overlap with merged one
        // a. loop: merge intervals[i] with merged interval
        for(;idx < intervals.size(); idx++) {
            if(intervals[idx][0]> mergedInterval[1]) break;

            mergedInterval[0] = min(mergedInterval[0], intervals[idx][0]);
            mergedInterval[1] = max(mergedInterval[1], intervals[idx][1]);
        }
        // b. break: stor metged interval
        result.push_back(mergedInterval);

        // [non-overlap interval: store in new vector]
        // (3) intervals[i] later than merge one -> direct stor to new vect
        for(; idx < intervals.size(); idx++) {
            result.push_back(intervals[idx]);
        }

        // finish
        return result;
    }
};
```

## V2：直接改原始 interval
- **vector.erase: ( start iteration, end iteration (不包含) )**
```Cpp
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        // to indicate the interval num of result
        int resultLength = 0;

        // set additional interval as merge target
        auto &mergedInterval = newInterval;

        // check all interval indicator
        int idx = 0;

        // [non-overlap interval: store in new vector]
        // (1) intervals[i] prior to new one -> direct store to new vect
        for(; idx < intervals.size(); idx++) {
            if(intervals[idx][0] > mergedInterval[0]) break;

            if(intervals[idx][1] >= mergedInterval[0]) break;

            resultLength++;
        }

        // [overlapped merge]
        // (2) intervals[i] overlap with merged one
        // a. loop: merge intervals[i] with merged interval
        int mergeIntervReduceCnt = 0;
        for(;idx < intervals.size(); idx++, mergeIntervReduceCnt++) {
            if(intervals[idx][0]> mergedInterval[1]) break;

            mergedInterval[0] = min(mergedInterval[0], intervals[idx][0]);
            mergedInterval[1] = max(mergedInterval[1], intervals[idx][1]);
        }
        // b. break: store metged interval + handle the remained non-overlap interval
        if(mergeIntervReduceCnt) {
            // if merge & interval reduce was proceeded
            intervals[resultLength++] = mergedInterval;

            // the redundant interval that should be removed
            int intervalRemove = (mergeIntervReduceCnt-1);

            // remained clear the merged interval
            if(intervalRemove) intervals.erase(intervals.begin()+resultLength, intervals.begin()+resultLength+intervalRemove);
        }
        else {
            // if the new interval is not overlapped with any interval
            intervals.insert(intervals.begin()+resultLength, mergedInterval);
        }

        // finish
        return intervals;
    }
};
```