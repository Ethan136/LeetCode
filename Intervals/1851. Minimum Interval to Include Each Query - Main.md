# LeetCode
[1851. Minimum Interval to Include Each Query](https://leetcode.com/problems/minimum-interval-to-include-each-query/)

# Concept
Hint
- sort query + map index
- sort interval fast check include
- min length heap store interval contains current query
- heap top 使用 reference 必須加上 const

基本性質分析
- interval 很多個，query 很多個 -> *interval / query 都進行排序，然後依序處理，如果某個 interval 不包含 query，則這個 interval 也不包含後面的 query*
- interval 裡面找 length 最小的來搭配 query -> interval 包含某個 query 的有很多個，可以 sort 也可以 heap 來取得 length 最小的
- interval 很多個可以搭配 query[i]，這些 interval 可能也可以搭配 query[i + ...] -> 一旦找到某個 interval 涵蓋 query[i]，也要檢查後續的 query[i+...]
- 由於 result 是和 query 做配對，所以檢查的時候以 query 作為主 loop

做法
- interval 依照 start 排序
- query 依照 value 排序 -> query.value = interval 的內差數值
- min heap 記錄 min length interval contain query
- 從 query value 最小的（內差數值最小）開始檢查，檢查每個 sorted interval （依照 start index sort），可以確保每個 interval 一定只檢查一次
- 再用 min heap 記錄「包含當前 query 的最小 length 是多少」
- 取得每個 sorted query 對應的 interval length 後，要再把 sorted query 還原成 origin query 的順序，並回傳對應的 length
# Answer
## V1 - 第一次寫的
```Cpp
#define INVALID_INTERVAL_LEN    (-1)
class Solution {
private:
    struct queryInfo {
        int index;
        int value;
        int itvlLen;
    };
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        // sort intervals
        auto cmpItvlStart = [](auto &a, auto &b) {
            return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
        };

        sort(intervals.begin(), intervals.end(), cmpItvlStart);

        // store the query info as kind of a mapping to the origin order
        vector<queryInfo> queryInfoAll( queries.size() );
        for(int i = 0; i < queries.size(); i++) queryInfoAll[i] = {i, queries[i], INVALID_INTERVAL_LEN};

        // sort the query info
        auto cmpQuery = [](auto &a, auto &b) {
            return a.value < b.value;
        };

        sort(queryInfoAll.begin(), queryInfoAll.end(), cmpQuery);

        // a min heap to store the checked intervals (sort by interval length)
        auto cmpItvlLenGreater = [](auto &a, auto &b) {
            return (a[1] - a[0]) > (b[1] - b[0]);
        };

        priority_queue<vector<int>, vector<vector<int>>, decltype(cmpItvlLenGreater)> minHeapItvlContainQuery;

        // helper function to check whether the interval contains the query
        auto checkItvlContainQuery = [](vector<int> const &itvl, int query) {
            if(query < itvl[0]) return false;
            if(itvl[1] < query) return false;
            return true;
        };

        // check all interval and store the checked interval by the minimal length order
        int checkItvlIdx = 0;
        for(auto &queryInfo : queryInfoAll) {

            // if there're some intervals contain the previous query
            // -> take out the intervals that does not contain the current query
            while(  minHeapItvlContainQuery.size() && 
                    !checkItvlContainQuery( minHeapItvlContainQuery.top(), queryInfo.value)) {
                minHeapItvlContainQuery.pop();
            }

            // check all intervals contain the current query
            for(; checkItvlIdx < intervals.size(); checkItvlIdx++) {

                // the interval to be chcked
                auto &interval = intervals[ checkItvlIdx ];

                // if the query less than the in-order-sorted interval start point
                // -> the query not within any interval -> check next query
                if( queryInfo.value < interval[0]) break;

                // if the query greater than the in-order-sorted interval end point
                // -> this interval does not contain any query -> check next interval
                if( interval[1] < queryInfo.value) continue;

                // if the query within the in-order-sorted interval
                // push the interval end within the min length heap
                minHeapItvlContainQuery.push( interval );
            }

            // set the interval with minimal length for the query
            if(minHeapItvlContainQuery.size()) {
                auto &itvlWithMinLen = minHeapItvlContainQuery.top();
                queryInfo.itvlLen = (itvlWithMinLen[1] - itvlWithMinLen[0] + 1);
            }
         }

        // restore the sorted queryInfoAll back to the interval length corresponding to the order of origin queries
        vector<int> result( queries.size() );
        for(auto &queryInfo : queryInfoAll) result[ queryInfo.index ] = queryInfo.itvlLen;
        return result;
    }
};
```

## V2 - 複習1st（比較簡潔一點）
```Cpp
#define INVALID_INTERVAL_LEN    (-1)
class Solution {
private:
    struct queryInfo {
        int idx;
        int value;
        int intervalLen;
    };
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        // sort interval by start time
        auto cmpIntervalStart = [](auto &a, auto &b) {
            return a[0] < b[0];
        };
        sort(intervals.begin(), intervals.end(), cmpIntervalStart);

        // augmented query info vector
        vector<queryInfo> queryInfoVec(queries.size());
        for(int i = 0; i < queries.size(); i++) queryInfoVec[i] = {i, queries[i], INVALID_INTERVAL_LEN};

        // sort query info vector
        auto cmpQueryInfo = [](auto &a, auto &b) {
            return a.value < b.value;
        };
        sort(queryInfoVec.begin(), queryInfoVec.end(), cmpQueryInfo);

        // min heap to contain the qualified intervals of certain query
        auto cmpIntervalLen = [](auto &a, auto &b) {
            return (a[1] - a[0] + 1) > (b[1] - b[0] + 1);
        };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmpIntervalLen)> minLenIntervalHeap;

        // match the sorted query info with the sorted intervals
        int checkIntervalIdx = 0;
        for(auto &qInfo : queryInfoVec) {

            // pop out the checked intervals with smaller length witch does not include the target query value
            while(minLenIntervalHeap.size()) {
                // if the interval contains the query -> break & stop popping
                if( (minLenIntervalHeap.top().front() <= qInfo.value) && (qInfo.value <= minLenIntervalHeap.top().back()) ) break;

                // if the interval does not contain the query -> pop out
                minLenIntervalHeap.pop();
            }

            // check the interval
            for(; checkIntervalIdx < intervals.size(); checkIntervalIdx++) {
                // if the interval on the right side of the query -> check next query
                if(qInfo.value < intervals[ checkIntervalIdx ].front()) break;

                // if the interval on the left side of the query -> check next interval
                if(intervals[ checkIntervalIdx ].back() < qInfo.value) continue;

                // if the interval contains the query -> store in the heap
                minLenIntervalHeap.push(intervals[ checkIntervalIdx ]);
            }

            // get the interval containing the query with min length
            if(minLenIntervalHeap.size()) {
                qInfo.intervalLen = minLenIntervalHeap.top().back() - minLenIntervalHeap.top().front() + 1;
            }
        }

        // restore the interval-length of each query to the origin input order
        vector<int> minIntervalLenOfQuery(queryInfoVec.size());
        for(auto &qInfo : queryInfoVec) minIntervalLenOfQuery[ qInfo.idx ] = qInfo.intervalLen;

        // finish
        return minIntervalLenOfQuery;
    }
};
```

## V3 - 複習2nd
**速度比較慢，但不用額外定義資料結構，寫法比較簡潔**
```Cpp
class Solution {
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        // extend interval info with size
        for(auto &itvl : intervals) itvl.push_back( itvl[1] - itvl[0] + 1);

        // sort intervals by left
        auto cmpItvl = [](auto &a, auto &b) {return a[0] < b[0];};
        sort(intervals.begin(), intervals.end(), cmpItvl);

        // sort queries & build index mapping before & after sort
        vector<vector<int>> queryWithIdx(queries.size());
        for(int i = 0; i < queryWithIdx.size(); i++) queryWithIdx[i] = {queries[i], i};
        auto cmpQry = [](auto &a, auto &b) {return a[0] < b[0];};
        sort(queryWithIdx.begin(), queryWithIdx.end(), cmpQry);

		// to sort the intervals covering the current query by interval length
		auto cmpItvlLen = [](auto &a, auto &b) {return a[2] > b[2];};
		priority_queue<vector<int>, vector<vector<int>>, decltype(cmpItvlLen)> minItvlLenHeap;

        // init result0 with sorted queries
        vector<int> result(queryWithIdx.size());

        // check each intervals[i] with the query[j]
        int i = 0;
        for(int j = 0; j < queryWithIdx.size(); j++) {

            // init result of current query as invalid
            int &resultRef = result[ queryWithIdx[j][1] ];
            resultRef = -1;

            // add intervals that include query into heap
            for(; i < intervals.size(); i++) {
	            // interval after query
	            if(intervals[i][0] > queryWithIdx[j][0]) break;
	            // interval before query
	            if(intervals[i][1] < queryWithIdx[j][0]) continue;
		        // interval include query
	            minItvlLenHeap.push(intervals[i]);
            }

            // pop out intervals that does not include the query
            // until the first interval include the query (this one with min length)
            while(minItvlLenHeap.size() && (minItvlLenHeap.top()[1] < queryWithIdx[j][0])) {
	            minItvlLenHeap.pop();
            }

			// set the interval with min length including query to result
			resultRef = minItvlLenHeap.empty() ? (-1) : (minItvlLenHeap.top()[2]);
        }

        // finish
        return result;

    }
};
```

## V4 - 複習2nd 但 Heap 裡面儲存的內容優化（只存 interval index）
- heap 裡面的 lambda func 採用『可使用 func 外的 ref 的形式 [&]』
	- `auto cmpItvlLenByIdx = [&](auto &a, auto &b) {return intervals[a][2] > intervals[b][2];};`
	- Heap 裡面只存 interval index, compare func 從外部抓 intervals 來做計算操作
- **注意：這個方式設定 compare function的話，heap 初始化必須把 compare func 放到建構子參數裡面**
	- `priority_queue<int, vector<int>, decltype(cmpItvlLenByIdx)> minItvlLenHeap(cmpItvlLenByIdx);`
```Cpp
class Solution {
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        // extend interval info with size
        for(auto &itvl : intervals) itvl.push_back( itvl[1] - itvl[0] + 1);

        // sort intervals by left
        auto cmpItvl = [](auto &a, auto &b) {return a[0] < b[0];};
        sort(intervals.begin(), intervals.end(), cmpItvl);

        // sort queries & build index mapping before & after sort
        vector<vector<int>> queryWithIdx(queries.size());
        for(int i = 0; i < queryWithIdx.size(); i++) queryWithIdx[i] = {queries[i], i};
        auto cmpQry = [](auto &a, auto &b) {return a[0] < b[0];};
        sort(queryWithIdx.begin(), queryWithIdx.end(), cmpQry);

		// to sort the intervals covering the current query by interval length
		auto cmpItvlLenByIdx = [&](auto &a, auto &b) {return intervals[a][2] > intervals[b][2];};
		priority_queue<int, vector<int>, decltype(cmpItvlLenByIdx)> minItvlLenHeap(cmpItvlLenByIdx);

        // init result0 with sorted queries
        vector<int> result(queryWithIdx.size());

        // check each intervals[i] with the query[j]
        int i = 0;
        for(int j = 0; j < queryWithIdx.size(); j++) {

            // init result of current query as invalid
            int &resultRef = result[ queryWithIdx[j][1] ];
            resultRef = -1;

            // add intervals that include query into heap
            for(; i < intervals.size(); i++) {
	            // interval after query
	            if(intervals[i][0] > queryWithIdx[j][0]) break;
	            // interval before query
	            if(intervals[i][1] < queryWithIdx[j][0]) continue;
		        // interval include query
	            minItvlLenHeap.push(i);
            }

            // pop out intervals that does not include the query
            // until the first interval include the query (this one with min length)
            while(minItvlLenHeap.size() && (intervals[ minItvlLenHeap.top() ][1] < queryWithIdx[j][0])) {
	            minItvlLenHeap.pop();
            }

			// set the interval with min length including query to result
			resultRef = minItvlLenHeap.empty() ? (-1) : (intervals[ minItvlLenHeap.top() ][2]);
        }

        // finish
        return result;

    }
};
```

# Answer - 排序後逐一比對（類似 brute force）
```Cpp
class Solution {
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        // extend interval info with size
        for(auto &itvl : intervals) itvl.push_back( itvl[1] - itvl[0] + 1);

        // sort intervals by left
        auto cmpItvl = [](auto &a, auto &b) {return a[0] < b[0];};
        sort(intervals.begin(), intervals.end(), cmpItvl);

        // sort queries & build index mapping before & after sort
        vector<vector<int>> queryWithIdx(queries.size());
        for(int i = 0; i < queryWithIdx.size(); i++) queryWithIdx[i] = {queries[i], i};
        auto cmpQry = [](auto &a, auto &b) {return a[0] < b[0];};
        sort(queryWithIdx.begin(), queryWithIdx.end(), cmpQry);

        // init result0 with sorted queries
        vector<int> result(queryWithIdx.size());

        // check each intervals[i] with the query[j]
        int i = 0;
        for(int j = 0; j < queryWithIdx.size(); j++) {

            // init result of current query as invalid
            int &resultRef = result[ queryWithIdx[j][1] ];
            resultRef = -1;

            // skip intervals end before query
            while((i < intervals.size()) && (intervals[i][1] < queryWithIdx[j][0])) i++;

            // check intervals that may include query (still not check ending point)
            int chkEndIdx = i;
            while((chkEndIdx < intervals.size()) && (intervals[chkEndIdx][0] <= queryWithIdx[j][0])) chkEndIdx++;

            // check interval including query with min length
            for(int chkIdx = i; chkIdx < chkEndIdx; chkIdx++) {

                // if interval does not include query
                if(intervals[chkIdx][1] < queryWithIdx[j][0]) continue;
                
                // if the checked interval with larger size
                if((resultRef != -1) && (intervals[chkIdx][2] > resultRef) )continue;

                // store to result with un-mapped query idx
                resultRef = intervals[chkIdx][2];                
            }
        }

        // finish
        return result;

    }
};
```