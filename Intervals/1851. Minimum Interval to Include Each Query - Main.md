# LeetCode
[1851. Minimum Interval to Include Each Query](https://leetcode.com/problems/minimum-interval-to-include-each-query/)

# Concept
Hint
- sort query + map index
- sort interval fast check include
- min length heap store interval contains current query
- heap top 使用 reference 必須加上 const

做法
- interval 依照 start 排序
- query 依照 value 排序 -> query.value = interval 的內差數值
- min heap 記錄 min length interval contain query
- 從 query value 最小的（內差數值最小）開始檢查，檢查每個 sorted interval （依照 start index sort），可以確保每個 interval 一定只檢查一次
- 再用 min heap 記錄「包含當前 query 的最小 length 是多少」
- 取得每個 sorted query 對應的 interval length 後，要再把 sorted query 還原成 origin query 的順序，並回傳對應的 length
# Answer
## V1 - 第一次寫的
```Cpp
#define INVALID_INTERVAL_LEN    (-1)
class Solution {
private:
    struct queryInfo {
        int index;
        int value;
        int itvlLen;
    };
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        // sort intervals
        auto cmpItvlStart = [](auto &a, auto &b) {
            return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
        };

        sort(intervals.begin(), intervals.end(), cmpItvlStart);

        // store the query info as kind of a mapping to the origin order
        vector<queryInfo> queryInfoAll( queries.size() );
        for(int i = 0; i < queries.size(); i++) queryInfoAll[i] = {i, queries[i], INVALID_INTERVAL_LEN};

        // sort the query info
        auto cmpQuery = [](auto &a, auto &b) {
            return a.value < b.value;
        };

        sort(queryInfoAll.begin(), queryInfoAll.end(), cmpQuery);

        // a min heap to store the checked intervals (sort by interval length)
        auto cmpItvlLenGreater = [](auto &a, auto &b) {
            return (a[1] - a[0]) > (b[1] - b[0]);
        };

        priority_queue<vector<int>, vector<vector<int>>, decltype(cmpItvlLenGreater)> minHeapItvlContainQuery;

        // helper function to check whether the interval contains the query
        auto checkItvlContainQuery = [](vector<int> const &itvl, int query) {
            if(query < itvl[0]) return false;
            if(itvl[1] < query) return false;
            return true;
        };

        // check all interval and store the checked interval by the minimal length order
        int checkItvlIdx = 0;
        for(auto &queryInfo : queryInfoAll) {

            // if there're some intervals contain the previous query
            // -> take out the intervals that does not contain the current query
            while(  minHeapItvlContainQuery.size() && 
                    !checkItvlContainQuery( minHeapItvlContainQuery.top(), queryInfo.value)) {
                minHeapItvlContainQuery.pop();
            }

            // check all intervals contain the current query
            for(; checkItvlIdx < intervals.size(); checkItvlIdx++) {

                // the interval to be chcked
                auto &interval = intervals[ checkItvlIdx ];

                // if the query less than the in-order-sorted interval start point
                // -> the query not within any interval -> check next query
                if( queryInfo.value < interval[0]) break;

                // if the query greater than the in-order-sorted interval end point
                // -> this interval does not contain any query -> check next interval
                if( interval[1] < queryInfo.value) continue;

                // if the query within the in-order-sorted interval
                // push the interval end within the min length heap
                minHeapItvlContainQuery.push( interval );
            }

            // set the interval with minimal length for the query
            if(minHeapItvlContainQuery.size()) {
                auto &itvlWithMinLen = minHeapItvlContainQuery.top();
                queryInfo.itvlLen = (itvlWithMinLen[1] - itvlWithMinLen[0] + 1);
            }
         }

        // restore the sorted queryInfoAll back to the interval length corresponding to the order of origin queries
        vector<int> result( queries.size() );
        for(auto &queryInfo : queryInfoAll) result[ queryInfo.index ] = queryInfo.itvlLen;
        return result;
    }
};
```

## V2 - 複習時候寫的（比較簡潔一點）
```Cpp
#define INVALID_INTERVAL_LEN    (-1)
class Solution {
private:
    struct queryInfo {
        int idx;
        int value;
        int intervalLen;
    };
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        // sort interval by start time
        auto cmpIntervalStart = [](auto &a, auto &b) {
            return a[0] < b[0];
        };
        sort(intervals.begin(), intervals.end(), cmpIntervalStart);

        // augmented query info vector
        vector<queryInfo> queryInfoVec(queries.size());
        for(int i = 0; i < queries.size(); i++) queryInfoVec[i] = {i, queries[i], INVALID_INTERVAL_LEN};

        // sort query info vector
        auto cmpQueryInfo = [](auto &a, auto &b) {
            return a.value < b.value;
        };
        sort(queryInfoVec.begin(), queryInfoVec.end(), cmpQueryInfo);

        // min heap to contain the qualified intervals of certain query
        auto cmpIntervalLen = [](auto &a, auto &b) {
            return (a[1] - a[0] + 1) > (b[1] - b[0] + 1);
        };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmpIntervalLen)> minLenIntervalHeap;

        // match the sorted query info with the sorted intervals
        int checkIntervalIdx = 0;
        for(auto &qInfo : queryInfoVec) {

            // pop out the checked intervals with smaller length witch does not include the target query value
            while(minLenIntervalHeap.size()) {
                // if the interval contains the query -> break & stop popping
                if( (minLenIntervalHeap.top().front() <= qInfo.value) && (qInfo.value <= minLenIntervalHeap.top().back()) ) break;

                // if the interval does not contain the query -> pop out
                minLenIntervalHeap.pop();
            }

            // check the interval
            for(; checkIntervalIdx < intervals.size(); checkIntervalIdx++) {
                // if the interval on the right side of the query -> check next query
                if(qInfo.value < intervals[ checkIntervalIdx ].front()) break;

                // if the interval on the left side of the query -> check next interval
                if(intervals[ checkIntervalIdx ].back() < qInfo.value) continue;

                // if the interval contains the query -> store in the heap
                minLenIntervalHeap.push(intervals[ checkIntervalIdx ]);
            }

            // get the interval containing the query with min length
            if(minLenIntervalHeap.size()) {
                qInfo.intervalLen = minLenIntervalHeap.top().back() - minLenIntervalHeap.top().front() + 1;
            }
        }

        // restore the interval-length of each query to the origin input order
        vector<int> minIntervalLenOfQuery(queryInfoVec.size());
        for(auto &qInfo : queryInfoVec) minIntervalLenOfQuery[ qInfo.idx ] = qInfo.intervalLen;

        // finish
        return minIntervalLenOfQuery;
    }
};
```