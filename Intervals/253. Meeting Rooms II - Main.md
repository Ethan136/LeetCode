---
ParentTask:
  - "[[intervals]]"
---

# LeetCode
[253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

解答寫在 neetcode
https://neetcode.io/problems/meeting-schedule-ii?list=neetcode150
- 解法1：sort + check overlay & move to next term
- 解放2：sort + min heap to fast check
# Wrong Answer：用 double queue + 一次排一組，排不進的下一輪來排（有bug但剛好寫對）
- 裡面有一個 bug『當 interval1 / interval2 不重疊的時候，會把 interval1 排入 arragement，但 *interval 2 卻直接丟失*』
- 這邊有另外一個問題 -> *概念設計上的問題*
	- **依據 [[435. Non-Overlapping Intervals - Main]] 的方式來確保『每一天盡量排入大量的 meeting』**
	- **可能會造成『第一天排如最大量的 meeting，但後續的 meeting 卻都 overlap 導致天數拉長**
```Cpp
/**
 * Definition of Interval:
 * class Interval {
 * public:
 *     int start, end;
 *     Interval(int start, int end) {
 *         this->start = start;
 *         this->end = end;
 *     }
 * }
 */

class Solution {
public:
    int minMeetingRooms(vector<Interval>& intervals) {
        // if it's less than one interval: 1 interval -> 1 day / 0 interval -> 0 day
        if(intervals.size() <= 1) return intervals.size();
 
        // helper function to sort intervals
        auto cmpInterval = [](auto &a, auto &b) {
            return (a.start < b.start) || (a.start == b.start && a.end < b.end);
        };

        // sort intervals by start time
        sort(intervals.begin(), intervals.end(), cmpInterval);

        // helper function to check if two intervals are overlapped
        auto checkIntervalOverlap = [](auto &a, auto &b) {
            if(a.end <= b.start) return false;
            if(b.end <= a.start) return false;
            return true;
        };

        // the pending intervals which are waiting to be arranged
        deque<Interval> pendingItvlThisTerm; for(auto &itvl : intervals) pendingItvlThisTerm.push_back(itvl);
        deque<Interval> pendingItvlNextTerm;

        // the result of arrangement
        vector<vector<Interval>> arrangement;

        // do interval arrangement to prevent overlapping
        while(pendingItvlThisTerm.size()) {

            // extend the arrangement for the current term
            arrangement.resize( arrangement.size() + 1 );

            // arrange all the possible intervals
            while( pendingItvlThisTerm.size()) {

                // pop out the first interval
                Interval itvl1 = pendingItvlThisTerm.front();
                pendingItvlThisTerm.pop_front();

                // if the current interval is the last one
                // -> after pop out the current interval there's no pending interval
                if(pendingItvlThisTerm.empty()) {
                    arrangement.back().push_back(itvl1);
                    break;
                }

                // pop out the second interval
                Interval itvl2 = pendingItvlThisTerm.front();
                pendingItvlThisTerm.pop_front();

                // if the current interval does not overlapped with the next one
                if(checkIntervalOverlap(itvl1, itvl2) == false) {
                    arrangement.back().push_back(itvl1);
                    continue;
                }

                // if the current interval overlapped with the next one
                // (1) keep the one ending earlied in the pending of this term
                // (2) move the one ending later to the next term
                if( itvl1.end <= itvl2.end ) {
                    pendingItvlThisTerm.push_front(itvl1);
                    pendingItvlNextTerm.push_back(itvl2);

                }
                else {
                    pendingItvlThisTerm.push_front(itvl2);
                    pendingItvlNextTerm.push_back(itvl1);
                }
            }

            // swap the pending interval for the next term arrangement
            swap(pendingItvlThisTerm, pendingItvlNextTerm);
        }

        // return arrangement terms as the required days
        return arrangement.size();
    }
};

```

- **注意：使用 lambda function -> {} 結束的地方要加上 ';'**

# Correct Answer：Min Heap - 把所有 meeting 視為『多天數平行安排』

## 概念
- 一開始只排一天，如果能塞同一天就塞同一天
- 當發生『overlap』，則額外開一天
- **後續新的 meeting，則看『每一個天裡面的 last end time，看這 new meeting start time 離哪一天的 last end time 最接近，就把它接上去』**

## 實作
- 先把 meeting 依照 start time 排序，這樣後續比對『new meeting / last end time』的時候，才能確保安排的時間是最緊緻的
- 可以用一個 min heap，裡面紀錄『所開啟的每一天裡面的 last end time』 -> 可以隨時取出『last end time 最早結束的日子，把 new meeting 排進去』

## Code V1 - 註解比較詳細，寫比較繁瑣（看概念）
```Cpp
/**
 * Definition of Interval:
 * class Interval {
 * public:
 *     int start, end;
 *     Interval(int start, int end) {
 *         this->start = start;
 *         this->end = end;
 *     }
 * }
 */

class Solution {
public:
    int minMeetingRooms(vector<Interval>& intervals) {
        // if it's less than one interval: 1 interval -> 1 day / 0 interval -> 0 day
        if(intervals.size() <= 1) return intervals.size();
 
        // helper function to sort intervals
        auto cmpInterval = [](auto &a, auto &b) {
            return (a.start < b.start) || (a.start == b.start && a.end < b.end);
        };

        // sort intervals by start time
        sort(intervals.begin(), intervals.end(), cmpInterval);

        // min heap for the end time of each arrangement
        // -> serve the problem as min "N" rooms to finish all the meetings within one day
        // ->
        priority_queue<int, vector<int>, greater<int>> earliestEndTimeOfEachArrangement;

        // check each interval
        for(auto &itvl : intervals) {

            // if the interval start time is later than the "earliest end time of within the current arrangement"
            // -> set the interval in this arrangement and update the earliest end time of the arrangement
            if( earliestEndTimeOfEachArrangement.size() && 
                earliestEndTimeOfEachArrangement.top() <= itvl.start) {
                earliestEndTimeOfEachArrangement.pop();
                earliestEndTimeOfEachArrangement.push(itvl.end);
            }
            // if the interval start time overlaps with all the end time of all the arrangements
            // -> create new arrangement
            else {
                earliestEndTimeOfEachArrangement.push(itvl.end);
            }
        }

        // return arrangement terms as the required days
        return earliestEndTimeOfEachArrangement.size();
    }
};

```

## Code V2 - 寫比較簡潔，code 也比較好懂（看 code）
- **initial boundary condition 提取出來 index 0 處理，後續可以比較簡潔**
```Cpp
/**
 * Definition of Interval:
 * class Interval {
 * public:
 *     int start, end;
 *     Interval(int start, int end) {
 *         this->start = start;
 *         this->end = end;
 *     }
 * }
 */

class Solution {
public:
    int minMeetingRooms(vector<Interval>& intervals) {
        // for zero meeting or 1 meeting
        if(intervals.size() <= 1) {
            return intervals.size();
        }

        auto cmpItvl = [](auto& a, auto &b) {
            return a.start < b.start;
        };

        sort(intervals.begin(), intervals.end(), cmpItvl);

        priority_queue<int, vector<int>, greater<int>> minLastTimeHeap;
        minLastTimeHeap.push(intervals[0].end);

        for(int i = 1; i < intervals.size(); i++) {
            // time overlap -> open new room
            if(intervals[i].start < minLastTimeHeap.top()) {
                minLastTimeHeap.push(intervals[i].end);
            }
            // time non-overlap -> add to the room with earliest end time
            else {
                minLastTimeHeap.pop();
                minLastTimeHeap.push(intervals[i].end);
            }
        }

        return minLastTimeHeap.size();
    }

};

```


# Correct Answer：Sweep Line - 把 start / end time 拆開一起排序，掃描過去看是否中間需要開新房
- **sweep line（掃描線） 就是一種「把時間或空間攤平成一條軸，依序處理事件點」的通用技巧**
- 這個寫法蠻簡潔的，本身也是一種 greedy
- 概念是『start / end time 一起排序，並且 start time 搭配『需要 open 1 room』 / end time 搭配『close 1 room』
```Cpp
/**
 * Definition of Interval:
 * class Interval {
 * public:
 *     int start, end;
 *     Interval(int start, int end) {
 *         this->start = start;
 *         this->end = end;
 *     }
 * }
 */

class Solution {
private:
    struct meetingRoomUseChange {
        int time;
        int changeCnt;
    };
public:
    int minMeetingRooms(vector<Interval>& intervals) {
        if(intervals.size() <= 1) return intervals.size();

        vector<meetingRoomUseChange> meetingRoomChangeVec;
        meetingRoomChangeVec.reserve(2 * intervals.size());

        for(int i = 0; i < intervals.size(); i++) {
            meetingRoomChangeVec.push_back( {intervals[i].start, 1} );
            meetingRoomChangeVec.push_back( {intervals[i].end, -1} );
        }

        auto cmpMeetingRoomChange = [](auto &a, auto &b) {
            // earlier time
            if(a.time < b.time) return true;

            // same time -> end room before open new room
            if(a.time == b.time) return a.changeCnt < b.changeCnt;

            // later time
            return false;
        };
        sort(meetingRoomChangeVec.begin(), meetingRoomChangeVec.end(), cmpMeetingRoomChange);

        int curRoomUse = 0, maxRoomUse = 0;
        for(auto &meetingRoomChg : meetingRoomChangeVec) {
            curRoomUse += meetingRoomChg.changeCnt;
            maxRoomUse = max(maxRoomUse, curRoomUse);
        }

        return maxRoomUse;
    }
};
```