# LeetCode
[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

# Concept
- **有可能 rotate num = 0 -> 完全沒有 abnormal range**
# Answer: 判斷「Abnormal Range (平移後的左半邊)」
## V1：判斷 head to mid 是否為正常遞增 + target 是否在 head to mid 之間 -> 比較複雜
```Cpp
#define IN_RANGE(a,b,target) (a<=target && target<=b)
class Solution {
public:
	int search(vector<int>& nums, int target) {
		int l, m, r;
		for(l=0,r=nums.size()-1,m=(l+r)*0.5;
			l<r-1;
			m=(l+r)*0.5) {

			int L=nums[l],  M=nums[m], R=nums[r];
#ifdef DRBUG_EN
cout<<" l "<<l<<" m "<<m<<" r "<<r<<endl;
cout<<" L "<<L<<" M "<<M<<" R "<<R<<endl;
#endif

			// mid match target -> return result
			if(M==target) return m;

			// left side is normal region
			if(L<M) {
				// check if target in normal region
				if(IN_RANGE(L,M,target)) r=m;

				// target in right side abnormal region
				else l=m;
			}
			// right side is normal region
			else {
				// check if target in normal region
				if(IN_RANGE(M,R,target)) l=m;

				// target in left side abnormal region
				else r=m;
			}
		}

		if(nums[l]==target) return l;
		if(nums[r]==target) return r;
		return -1;
	}
};
```
- *Array 爲 Sorted Array 做 N 次平移*
- Rotate = Array 平移的特性
	- 平移 N 次 -> 往右做 N 次 shift
	- 和 [[153. Find Minimum in Rotated Sorted Array - Main]] 描述的機制相同
	- 可以把 Array 切一刀下去，分爲『正常區塊』和『異常區塊』
	- 正常區塊： 裏面的 element 完全遞增
	- 異常區塊： 裏面的 element 先遞增到 Max，然後瞬間變成 min 再逐步遞增
- **形式自由的 binary search**
	- **只要切一刀到 mid 後，後續知道可以往哪邊搜索，就能用 binary search**
- 這邊切一刀到 mid 後
	- 檢查正常遞增的那一邊：看 target 有沒有在裏面
	- 左邊是正常區塊 -> 檢查 target 是否在左邊
		- Yes: 更新 right ->mid (target 在左邊，右側收縮)
		- No:  更新 left -> mid (target 在右邊，左側收縮)
	- 右邊是正常區塊 -> 檢查 target 是否在右邊
		- Yes: 更新 left -> mid (target 在右邊，左側收縮)
		- No:  更新 right ->mid (target 在左邊，右側收縮)
	- **因爲異常區塊有凹點，無法藉由兩側數值來判斷 target 是否在裏面


## V2：把 rotated 後的左側「起始 element 不為 min 的區塊」視為 abnormal range + 「起始 element 為 min 的區塊」視為 normal range
```Cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // [mid2 -> MAX] [MIN -> mid1]: abnormal range + normal range
        // [mid2 -> try -> MAX] [MIN -> mid1]: nums[0] <= try && nums[end] < try
        // [mid2 -> MAX] [MIN -> try -> mid1]: nums[0] > try && nums[end] >= try

        // [MIN -> mid1] [mid2 -> MAX]: whole normal range
        // [MIN -> try -> mid1] [mid2 -> MAX]: nums[0] <= try && try <= nums[end]
        // [MIN -> mid1] [mid2 -> try -> MAX]: nums[0] <= try && try <= nums[end]

        // (1) in normal range: try <= nums[end] -> [MIN -> mid1 / MAX]
        // (2) in abnormal range: try > nums[end] -> [mid2 -> MAX]

        bool targetInAbnormalRange = (target > nums.back());

        int head, tail;
        for(head = 0, tail = nums.size()-1; 
            head < tail-1;) {

            int mid = (head + tail) * 0.5;

            // cond0: result found !
            if(nums[mid] == target) return mid;

            // check mid in abnormal range & target in abnormal range
            bool midInAbnormalRange = (nums[mid] > nums.back());

            // cond1: mid and target are in different section
            if( targetInAbnormalRange != midInAbnormalRange ) {
                // (a) target in abnormal range -> mid in normal range
                // [mid2 -> target -> MAX], [MIN -> mid -> mid1]
                if(targetInAbnormalRange) tail = mid;

                // (b) target in normal range -> mid in abnormal range
                // [mid2 -> mid -> MAX], [MIN -> target -> mid1]
                else head = mid;
            }

            // cond2: mid and target are in same section -> normal binary search
            else {
                if(nums[mid] < target) head = mid;
                else tail = mid;
            }
        }

        if(nums[head] == target) return head;
        if(nums[tail] == target) return tail;
        return -1;
    }
};
```
- **檢查 mid / target 是否在同一個range**
	- 同 range 內 -> 一般的 binary search
	- 不同 range 內 -> 把 mid 往另外一個 range 的方向收斂
- **這個做法之間兼容「沒有任何 rotate，整個 array 是一個 normal range 的情況」