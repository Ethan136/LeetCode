# LeetCode
[4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

# Concept
- 透過 mid point 兩邊數量對分，來搜尋其中一個比較短的 vector
- 比如説 num1 有 10個，num2 有 6 個 -> overall mid point 的左邊一定是 8個，右邊也是 8個
- 搜尋的點把它叫做 split point
	- 可以只搜尋 num1 -> 再依照 num1 split point 左右的數量，直接取得 num2 split point 左右的數量
- split point 1 把 num1 分為 Group_L1 / Group_R1，並且 split point1 包含在 Group_L1 內
- split point 2 把 num2 分為 Group_L2 / Group_R2，並且 split point2 包含在 Group_L2 內
- **注意：有可能搜尋的結果，是 num1 只有 Group_L1 或是只有 Group_R1**
	- num1 只有 Group_L1 -> split point 為在 num1 最後的位置 -> **代表 num1 全部數字都在 num2 左邊**
	- num1 只有 Group_R1 -> split point 為在 num1 index = -1 的地方 -> **代表 num1 全部數字在 num2 右邊**
# Answer
## V1: 比較複雜
```Cpp
class Solution {
public:
    void getLeftAndRightOfSplitPoint(vector<int>& nums, int spltIdx, int& valL, int& valR) {
#ifdef DEBUG_SPLIT_VALUE_GET_EN
        cout << "[getLeftAndRightOfSplitPoint]" << endl;
        cout << "spltIdx: " << spltIdx << endl;
        cout << "nums: "; for(auto num : nums) {cout << num << " ";} cout << endl << endl;
#endif
        valL = (spltIdx==0) ? (INT_MIN) : (nums[spltIdx-1]);
        valR = (spltIdx==nums.size()) ? INT_MAX : nums[spltIdx];
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        // --------------------[CONCEPT REGION START]------------------------

        // A. split in both nums1 & nums2 -> {nums1_LGroup, nums1_RGroup} , {nums2_LGroup, nums2_RGroup}
        // where nums1 = nums1_LGroup = [nums1 min ... nums1_spltL] + [nums1_spltR ... nums1 max] = nums1_RGroup
        // where nums2 = nums2_LGroup = [nums2 min ... nums2_spltL] + [nums2_spltR ... nums2 max] = nums2_RGroup

        // B. if the split point satisfies the following 
        // (1) nums1_spltL <= nums2_spltR
        // (2) nums2_spltL <= nums1_spltR

        // C. then the four splitted groups could be merged as two group
        // [Overall GroupL]  [Overall GroupR]
        // | nums1_LGroup |  | nums1_RGoup  |
        // | nums2_LGroup |  | nums2_RGoup  |
        // -> which means the two split point makes nums1 & nums2 be splitted into two equal groups
        // (or nums1 & nums2 are splitted into two groups with the left group has 1 more elements)
        
        // D. then the middle point would be
        // (1) if total elements of (nums1 + nums2) is odd
        //     -> middle point is the larget one within {nums1_LGroup, nums2_LGroup}
        //     -> middle point = max( nums1_spltL, nums2_spltL )
        // (2) if total elements of (nums1 + nums2) is even
        //     -> middle point is the average one of the two middlest point within {Overall GroupL, Overall GroupR}
        //     -> middle point = ( max(nums1_spltL, nums2_spltR) + min(nums1_spltR + nums2_spltR) ) / 2

        // E. since the split point have to make sure
        // if nums1 + nums2 = even elements -> {Overall GroupL} has equal elements as {Overall GroupR}
        // if nums1 + nums2 = odd elements  -> {Overall GroupL} has one more elementsover {Overall GroupR}
        // the split points of nums1 & nums2 have to satisfy (spltIdxL + spltIdxR) = (nums1.size() + nums2.size() + 1) / 2
        // -> we only need to find the split point on nums1 -> then the split point on nums2 can be calculated
        // -> therefore, just select the vector (or array) with shorter length among nums1 & nums2

        // NOTICE !
        // the split index i means "left side with i elements"
        // split index = 0 -> means "left side with 0 elements"
        // split index = size() -> means "left side with ALL elements"
        // therefore, the initial condition of binary search should be left=0 / right=array.size()

        // --------------------[CONCEPT REGION END]------------------------

        // to find the shorter one -> make it as nums1
        if(nums1.size() > nums2.size()) swap(nums1, nums2);

        // calculate the total element number
        int numTotalGroup = nums1.size() + nums2.size();

        // use binary search to find the split point on nums1 (shorter one)
        int numOverallGroupL = (numTotalGroup + 1)/2;
        int left, right, splt1, splt2;
        int nums1_spltL, nums1_spltR, nums2_spltL, nums2_spltR;
        for(/*initial cond*/
            left=0, right=nums1.size(), 
            splt1=(left+right)*0.5, splt2=numOverallGroupL-splt1;
            
            /*terminate cond*/
            left <= right;

            /*update after each loop*/
            splt1=(left+right)*0.5, splt2=numOverallGroupL-splt1) {

            // two values besides split point in num1
            getLeftAndRightOfSplitPoint(nums1, splt1, nums1_spltL, nums1_spltR);

            // two values besides split point in num2
            getLeftAndRightOfSplitPoint(nums2, splt2, nums2_spltL, nums2_spltR);

            // if the middle split points have been converged
            if((nums1_spltL <= nums2_spltR) && (nums2_spltL <= nums1_spltR)) {
                // (1) total num is odd
                if(numTotalGroup % 2) return double(max(nums1_spltL, nums2_spltL));
                // (2) total num is even
                else return 0.5 * double( max(nums1_spltL, nums2_spltL) + min(nums1_spltR, nums2_spltR) );
            }

            // if the middle split points have not been converged
            // (1) the split point lies too left -> find the split point on the right side
            //  -> move "left idx" to split point
            if(nums1_spltR < nums2_spltL) left=splt1+1;
            // (2) the split point lies too right -> find the split point on the left side
            //  -> move "right idx" to split point 
            else right=splt1-1;
        }

        // not expect to be here
        return -3345678;
    }
};
``` 
- **詳細機制見上方**
- [[4. Medium of Two Sorted Arrays.excalidraw]] 想法有錯，但就自己想想看
- 由於這題最後判斷 match 的情況很複雜
	- -> 所以不用萬用的『收斂條件 left < (right-1) | left / right 直接收斂到 mid | 最後直接 left / right 各判斷一次』大法
	- -> **上面這個名字還真長，詳見 BinarySearch 其他題目解法的收斂設定**

## V2: 概念一樣，但比較簡化
```Cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size() > nums2.size()) swap(nums1, nums2);

        int totalNumCnt = nums1.size() + nums2.size();
        int leftGroupNum = (totalNumCnt % 2) ? (totalNumCnt/2 + 1) : (totalNumCnt/2);
        int rightGroupNum = totalNumCnt - leftGroupNum;

        if(nums1.empty()) return (nums2.size() % 2) ? (nums2[leftGroupNum-1]) : (nums2[leftGroupNum-1] + nums2[leftGroupNum])*0.5;

        int num1SearchHead = -1, num1SearchTail = nums1.size();
        while(num1SearchHead <= num1SearchTail) {

            // num1 split from mid1 point: group_L1  / group_R1 -> group_L1 includes mid1
            int num1SearchMid = (num1SearchHead + num1SearchTail) * 0.5;
            int num1MidLeftVal = (num1SearchMid >= 0) ? (nums1[num1SearchMid]) : (INT_MIN);
            int num1MidRightVal = ((num1SearchMid+1) < nums1.size()) ? (nums1[num1SearchMid+1]) : (INT_MAX);

            // num2 calc corresponding mid2 point -> to ensure group_L1 + group_L2 = whole group left cnt
            int num1LeftGroupNum = num1SearchMid + 1;
            int num2LeftGroupNum = (leftGroupNum - num1LeftGroupNum);

            // num2 split from mid2 point: group_L2 / group_R2 -> group_L2 includes mid2
            int num2SearchMid = num2LeftGroupNum - 1;
            int num2MidLeftVal = (num2SearchMid >= 0) ? (nums2[num2SearchMid]) : (INT_MIN);
            int num2MidRightVal = ((num2SearchMid+1) < nums2.size()) ? (nums2[num2SearchMid+1]) : (INT_MAX);

            // if mid1 / mid2 represents the overall middle point of whole group
            // -> group_L1[end] <= group_R2[start]
            // -> group_L2[end] <= group_R1[start]
            if((num1MidLeftVal <= num2MidRightVal) && (num2MidLeftVal <= num1MidRightVal)) {
                int leftGroupLastVal = max(num1MidLeftVal, num2MidLeftVal);
                int rightGroupFirstVal = min(num1MidRightVal, num2MidRightVal);
                return (totalNumCnt % 2) ? (leftGroupLastVal) : (0.5*(leftGroupLastVal + rightGroupFirstVal));
            }

            // if mid1 point is too large (mid1 left val > mid2 right val)
            if(num1MidLeftVal > num2MidRightVal) {
                num1SearchTail = num1SearchMid-1;
            }
            // if mid1 point is too small (mid1 right val < mid2 left val)
            else {
                num1SearchHead = num1SearchMid+1;
            }
        }

        return 345678;
    }
};
```