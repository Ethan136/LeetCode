# LeetCode
[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

# Answer V1: 比較複雜 - 區塊分 head to mid / mid to tail，看哪一個區塊是 abnormal range
```Cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int head, mid, tail;
        for(head=0, tail=nums.size()-1, mid=(head+tail)*0.5; head<tail-1; mid=(head+tail)*0.5) {

			// left side is the abnormal region
            if(nums[head]>nums[mid]) tail=mid;

			// right side is the abnormal region
            else if(nums[mid]>nums[tail]) head=mid;

			// there's no abnormal region -> mid is the minimal point
            else return nums[head];
            
        }
        if(nums[head]<nums[tail]) return nums[head];
        else return nums[tail];
    }
};
``` 
- 題目情況：一個 sorted array 的index經過 N 次向右偏倚
	- N = 1 to ArraySize (偏倚 N 次會回到原點)
- 特性
	- 偏倚後 Array 可以分兩個區塊
	- 正常區塊： \[數值小到大遞增的區塊\]
	- 異常區塊： \[數值遞增到最大，然後突然變成最小值重新遞增 + 左側 > 右側\]
- 搜尋目標『異常區塊裏面的凹點 = 最小值』
	- **搜尋的時候如果 mid 在正常區塊 -> 把 head / tail 更新，讓下一次搜尋範圍爲異常區塊**
- 異常區塊判斷 -> **可以直接用條件一次判斷出來**
	- 左側異常：nums[head] > nums[mid]
	- 右側異常：nums[mid]  > nums[tail]
- 正常區塊判斷 -> **也可以用一次條件判斷出來**
	- 左側正常：nums[head] < nums[mid]
	- 右側正常：nums[mid]  < nums[tail]
	- **注意：異常區塊雖然中間有最低點，並且兩側比較高，但『最左側一定大於最右側』
		- 這是因爲『最左側是距離 Max Point 比較接近的遞增位置』
		- 而『最右側是距離 min Poitn 比較接近的遞增位置』
- 依據上述：**直接判斷異常區塊的條件，而不是找正常區塊的條件**
- **形式自由的 binary search**
	- **只要切一刀到 mid 後，後續知道可以往哪邊搜索，就能用 binary search**


# Answer V2: 比較好懂 - Abnormal Range 定義為「升高到 Max 後驟降為 min 的區塊」
- **這個區塊一定在左側**
- **這個區塊不一定存在（當 rotate num = 0 時整段都是 normal range）**
- **可以先檢查有沒有 rotate，如果沒有 rotate -> 直接回傳 nums[0] 為最小值**
- 如果存在 abnormal 區塊 -> 最小值的前一個 index 會比較大 -> ( NUM_MAX, num_min )

```Cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
	    // if there's no rotate
        if(nums.front() < nums.back()) return nums[0];

        int head, tail;
        for(head = 0, tail = nums.size()-1;
            head < tail-1;) {

			// if the min is hit
            int mid = (head + tail)*0.5;
            if((mid > 0) && (nums[mid-1] > nums[mid])) {
                return nums[mid];
            }

			// check whether the mid is in abnormal range
			// (the min is the first index of normal range)
            bool midInAbnormalRange = nums[mid] > nums.back();
            if(midInAbnormalRange) {
                head = mid;
            }
            else {
                tail = mid;
            }
        }

        return (nums[head] < nums[tail]) ? nums[head] : nums[tail];
    }
};
```

# Answer：V3 - 模板化寫法
```Cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];

        int head, tail, mid;
        for(head = 0, tail = (nums.size()-1), mid = (head+tail)/2;
            head < (tail-1);
            mid = (head+tail)/2) {
            
            // check section of mid
            bool midInRightSection = (nums[mid] <= nums[tail]);

            // try to shift mid to right section
            if(!midInRightSection) {
                head = mid;
            }
            // do binary search in right section
            else {
                tail = mid;
            }
        }
        return min(nums[head], nums[tail]);
    }
};
```