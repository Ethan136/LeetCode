---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[763. Partition Labels](https://leetcode.com/problems/partition-labels/)

# Concept
- 最多 26 個 partition（每個 partition 不能有互相重疊的 char）
- 從 index 0 開始掃描，每次檢查 partition 的情況
	- 目前 s[i] 屬於 新的 partition -> 開啟新的 partition
	- 目前 s[i] 屬於 last stored partition -> 最後一個 partition 長度延伸
	- 目前 s[i] 屬於更早之前 partition -> 從後往前 merge partition 直到包含 s[i] 的 partition 被 merge 為 last partition
- 需要記錄先前各個 partition 有哪些 char
	- 可以用 map
	- 也可以每個 partition 存一個 bitmap

# Answer：分三種情況「new partition / last partition extend / previous partition merge」
## V1：vector 記錄 partition length + map 記錄各個 char 所屬的 partition index
```Cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        unordered_map<char, int> charInPartitionIdxMap;

        vector<int> partition;
        for(int i = 0; i < s.size(); i++) {

            // (0) if this character didn't appear before
            // -> new partiion
            if(!charInPartitionIdxMap.count( s[i] )) {
                charInPartitionIdxMap[ s[i] ] = partition.size();
                partition.push_back( 1 );
                continue;
            }

            // extend the last partition
            partition.back() += 1;
            
            // (1) if the first appeared partition is the last partition
            // -> no need to merge partitions
            int partIdx = charInPartitionIdxMap[ s[i] ];
            if(partIdx == partition.size() - 1) continue;

            // (2) if the first appeard partition is not the last one
            // -> merge the partition
            int maxPartitionLen = partIdx + 1;
            while( partition.size() > maxPartitionLen) {
                int lastIdx = partition.size() - 1;
                partition[ lastIdx - 1 ] += partition[ lastIdx ];
                partition.pop_back();
            }

            // update the map after merging the partitions
            for(auto &[key, idxInPartition] : charInPartitionIdxMap) {
                if(idxInPartition < partIdx) continue;
                idxInPartition = partIdx;
            }
        }

        return partition;
    }
};
``` 

## V2：複習1st - 專用資料結構記錄 partition info \[startIdx, len, charBitMap\]
```Cpp
#define CHAR_TO_BIT(c) (1 << (c-'a'))
class Solution {
private:
    struct partitionInfo_t {
        int startIdx = 0;
        int len = 0;
        int charBitMap = 0;
    };
public:
    vector<int> partitionLabels(string s) {
        // all traversed char
        int allTravCharBitMap = 0;

        // all partitions
        vector<partitionInfo_t> partitions;
        partitions.reserve(26);

        // save first char to first partition
        partitions.push_back({.startIdx = 0, .len = 1, .charBitMap = CHAR_TO_BIT(s[0])});
        allTravCharBitMap |= partitions.back().charBitMap;

        for(int i = 1; i < s.size(); i++) {

            // bitmap of current char
            int curCharBit = CHAR_TO_BIT(s[i]);

            // belongs to new partition
            if(!(curCharBit & allTravCharBitMap)) {
                allTravCharBitMap |= curCharBit;
                partitions.push_back({.startIdx = i, .len = 1, .charBitMap = curCharBit});
                continue;
            }

            // belongs to previous partition
            if( curCharBit & partitions.back().charBitMap) {
                partitions.back().len++;
                continue;
            }

            // belongs to previous partition and trigger partition merge
            // (1) pop out last partition as merge target
            partitionInfo_t mergedPartition = partitions.back();
            partitions.pop_back();

            // (2) merge partitions until the merged partition includes the current bit
            while(!(mergedPartition.charBitMap & curCharBit)) {
                mergedPartition.startIdx = partitions.back().startIdx;
                mergedPartition.len += partitions.back().len;
                mergedPartition.charBitMap |= partitions.back().charBitMap;

                partitions.pop_back();
            };

            // (3) add new word to the merged partition
            mergedPartition.len += 1;

            // (4) store the merged partition
            partitions.push_back(mergedPartition);
        }

        // result: length of all partitions
        vector<int> result(partitions.size());
        for(int i = 0; i < result.size(); i++) {
            result[i] = partitions[i].len;
        }

        // finish
        return result;
    }
};
```

# Answer：複習2nd - 檢查每個 char 看是否會把先前的 partition 延伸到目前 index
```Cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        // Overview
        // one char type -> only appear in one paritiion -> store in one set

        // (1) partition char set & mapping to set
        // at most 26 partitions
        vector<vector<int>> partitions; partitions.reserve(26);
        vector<int> charToPartitionIdx(26, -1);

        // (2) check through the string by index
        for(int i = 0; i < s.size(); i++) {

            // char convert to idx
            int charIdx = s[i] - 'a';

            // char not in any partition -> add new partition
            if(charToPartitionIdx[ charIdx ] == -1) {
                charToPartitionIdx[ charIdx ] = partitions.size();
                partitions.push_back({i, i});
                continue;
            }

            // check char is any partition -> extend partition to current index
            // (a) check the affected char
            // (b) update mapping of affected char
            int basePartitionIdx = charToPartitionIdx[ charIdx ];
            for(int c = 0; c < 26; c++) {
                if(charToPartitionIdx[ c ] <= basePartitionIdx) continue;
                charToPartitionIdx[ c ] = basePartitionIdx;
            }
            // (c) partition merge
            partitions[ basePartitionIdx ][1] = i;
            while(partitions.size() > (basePartitionIdx + 1)) partitions.pop_back();         
        }

         // (3) record partition len in result
         vector<int> result(partitions.size());
         for(int i = 0; i < partitions.size(); i++) {
            result[i] = partitions[i][1] - partitions[i][0] + 1;
         }

         // (4) finish
         return result;   
    }
};
```