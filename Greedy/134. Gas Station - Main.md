---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[134. Gas Station](https://leetcode.com/problems/gas-station/)

# Concept
- **題目設定一定最多 1解，所以只要能找到一個 index 符合下列條件，就一定是解**
	- **這個 index 左邊： [0 to index-1] 的部分**
		- (index - 1) 的 gas 一定小於 cost (否則 index - 1 也會是一組解)
		- [ 0 to index-1 ]  裡面的 gas sum 一定小於 cost sum （否則這個區間內一定有另外一組解）
	- **這個 index 右邊：[index + 1 to end] 的部分
		- [index + 1 to end] 裡面的 gas sum 不一定小於 cost sum
		- 但是如果要考慮 ring back 的情況，則 [index + 1 to end] 裡面的 gas - cost，在走 ring back [0 to index-1] 的時候一定不夠
	- **整體來說，如果分成 [start index] 和 {other indices range} 兩個部分
		- 則 **start index 的 gas - cost 一定大於 0**
		- 且 {other indices range} 的 total gas - total cost 一定小於 0
- **從 index 0 開始往後找，第一個 index 能符合下列條件的就是 solution**
	- 「從這個 index to end index 的 total gas > total cost」
	- 這個條件是被「一定有解」而去「只有一解」所限制

# Answer：假設 idx0 是 start point 然後走整個路徑，一旦 gas 用完則把下一個 index 視為 new start point -> 只檢查到 last index

## V1 - 自訂資料結構 - 比較複雜
### 注意
- 這個做法是基於「一定有解，而且只有一解」
- 這個做法不會「先檢查是否total gas 足夠，而是直接做 traverse」

### 說明
- 使用自訂資料結構
- 一旦 total gas - total cost < 0 -> 代表從 section start 走到這邊會油耗不足 -> 把當前的 index 視為新的 start index
	- **這邊 total gas / total cost -> 都是這一次累積的 gas / cost，而不是這次累積的，這邊有點瑕疵**

### Code
```Cpp
class Solution {
private:
    struct tInterval {
        int startIdx = 0;
        int gasToCostSum = 0;
    };
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {

        // [initial condition] set inde0 to interval
        int totalGasToCost = gas[0] - cost[0];
        tInterval curInterval = {0, gas[0] - cost[0]};

        // [check each station]
        // check from the "2nd gas station"
        for(int i = 1; i < gas.size(); i++) {

            // gas to cost of current station
            int curGasToCost = gas[i] - cost[i];

            // total cost to gas
            totalGasToCost += curGasToCost;

            // -> choose the new index as interval start
            if(curInterval.gasToCostSum < 0) {
                curInterval.startIdx = i;
                curInterval.gasToCostSum = curGasToCost;
            }
            // if the gas to cost sum of current interval is not negative
            // -> add the new station to the interval
            else {
                curInterval.gasToCostSum += curGasToCost;
            }
        }

        // if solution does not exist
        if(totalGasToCost < 0) return -1;

        // finish
        return curInterval.startIdx;
    }
};
``` 


## V2 - 複習時候寫，寫法比較簡潔
```Cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        // no gas station at all
        if(gas.empty()) return -1;

        // assume start index is at 0
        int startIdx = 0, sectGasToCost = gas[0] - cost[0];

        // total gas to cost to check whether the solution is valid
        int totalGasToCost = gas[0] - cost[0];

        // check the remained gas station
        for(int i = 1; i < gas.size(); i++) {

            // section gas to cost after leaving previous station is not enough
            // -> try to set the current station as start point
            if(sectGasToCost < 0) {
                startIdx = i;
                sectGasToCost = 0;
            }

            // calculate gas to cost after leaving current station
            sectGasToCost += gas[i] - cost[i];

            // update total gas to cost
            totalGasToCost += gas[i] - cost[i];
        }

        return (totalGasToCost >= 0) ? (startIdx) : (-1);
    }
};

```

# Answer：假設 idx0 是 start point 然後走整個路徑，一旦 gas 用完則把下一個 index 視為 new start point -> 而且會確實檢查 ring back
## V1：寫法比較不好
### 注意
- **這個做法不算是 greedy，比較類似 brute force**
- 這個做法會先檢查 total gas 是否足夠，比較直觀
- 這個做法是基於：只要有解，則走完完整一個 ring back 來做檢查
- **這個做法在做 loop 檢查的時候，因為一開始是從 index i = 1 開始做 -> 一定要確保至少有兩個 station，才能進 loop 裡面**
- **而且必須確保一定有解，才能進 loop 裡面，在無解的情況下，進 loop 裡面會一直更換 start index 而無法達成 ring back**
- **計算 ring back 的方法，因為會一直檢查到 end index，如果本身無解，則可能會一邊檢查一邊一直更新 end index，所以必須要確保「進入迴圈前有解」**

### 說明
- 不使用自訂資料結構，而是直接用兩個變數儲存 sectionGasSum / SectionCostSum

### Code
```Cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        // no gas station at all
        if(gas.empty()) return -1;

        // only one gas station (index 0 or -1)
        if(gas.size() == 1) return (gas[0] < cost[0]) ? (-1) : (0);

        // check total gas & cost
        int totalGas = 0;
        for(int g : gas) totalGas += g;

        int totalCost = 0;
        for(int c : cost) totalCost += c;

        if(totalGas < totalCost) {
            return -1;
        }

        // set index 0 as section start
        int sectionStartIdx = 0, sectGasSum = gas[0], sectCostSum = cost[0];

        // travel through all gas station and update section start condition
        for(int i = 1; i != sectionStartIdx; i = ((i+1) % gas.size()) ) {

            // the condition that gas depleted -> set current index as new start section
            if(sectGasSum < sectCostSum) {
                sectGasSum = 0;
                sectCostSum = 0;
                sectionStartIdx = i;
            }

            // update gas / cost sum in the section
            sectGasSum += gas[i];
            sectCostSum += cost[i];
        }

        return sectionStartIdx;
    }
};
```

## V2：定義明確的寫法
### 注意
- **因為每次重設 startIdx，都會重置 travCnt 及 GasToCost**
	- **如果用 for loop，會強制更新 counter，不是那麼漂亮**
	- **這邊用 while loop，更能在「重置 start idx 的時候，停頓一下，而不會每個 loop 都一定要更新 trav cnt**
- **和檢查 index 確保 totally ring back 比起來 -> 檢查 traverse cnt 更能符合實際情況**
- **這邊定義行為如下（非常重要，關係到邊界條件）**
	- 從某個 station 離開的時候：先加油 gas[i]，再耗油 cost[i]
	- 抵達某個 station 前，先 preview 從這個 station 離開是否會油不足 -> **如果會，則把 next station 設為新的 start index**
	- **想法類似跳格子，在進入某個 station 前，先 preview 後續情況，再來決定是否要重新選 start idx**

### Code
```Cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        // no gas station at all
        if(gas.empty()) return -1;

        // assume start index is at 0
        int startIdx = 0, sectGasToCost = 0, travCnt = 0;

        // check through all the gas stations
        // rule1: add gas first
        // rule2: leave station and reduce cost
        while(travCnt < gas.size()) {

            // index of current gas station (should consider ring back)
            int idx = (startIdx + travCnt) % gas.size();

            // check whether the Gas to Cost Idx from the current station will be not enough
            if( (sectGasToCost + gas[idx] - cost[idx]) < 0) {

                // try to set the next station as start point
                int nextIdx = (idx + 1) % gas.size();

                // check if the next station had been checked as start poin before
                if(nextIdx <= startIdx) return -1;

                // set the next station as new start point
                startIdx = nextIdx;
                sectGasToCost = 0;
                travCnt = 0;
                continue;
            }

            // update gas / cost sum after leaving current station
            sectGasToCost += (gas[idx] - cost[idx]);

            // update travel cnt
            travCnt++;
        }

        return startIdx;
    }
};
```
