---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[846. Hand of Straights](https://leetcode.com/problems/hand-of-straights/)


# Concept
- bulk sort - 用一個資料結構，統計每個數字有幾個
- 從 sort 後的第一個 num 開始，依序試著把 num[i] 當作 pivot num 來湊順子
	- *假設 num[i] 還有 N 張，則從 num[i] 開始往後 K 個 num，把湊成順子的牌挑出來（num[i to i+K-1] statistic cnt 減去 N)*
	- 如果某個 num[i] 張數剩餘不為 0，但無法往後湊順子 -> return false
	- **注意：前面的 number 湊順子的時候，會消耗後面的 number 的數量**

# Answer - 奇怪的做法（當作練習）
- **這個做法不是看順子第一個 num[i] 有幾張，而是一張一張往後湊，看能不能湊到 K 張**
```Cpp
#define DEBUG_EN (false)
class Solution {
private:
    struct tPendingStraightInfo {
        deque<int> numCntOffsetFromFirst;
        int firstNum;
        int groupSize;
    };


    bool addNumToPendingStraight(int num, tPendingStraightInfo &pendingStraightInfo) {

        // if the on check straight is empty
        if(pendingStraightInfo.numCntOffsetFromFirst.empty()) {
            pendingStraightInfo.firstNum = num;
            pendingStraightInfo.numCntOffsetFromFirst.push_back( 1 );
            return true;
        }

        // if the insert numaber is out of straight range
        int numOffset = num - pendingStraightInfo.firstNum;
        if(numOffset < 0 || numOffset >= pendingStraightInfo.groupSize) {
            return false;
        }
        if(numOffset > pendingStraightInfo.numCntOffsetFromFirst.size()) {
            return false;
        }

        // insert the number to expand straight
        if(numOffset == pendingStraightInfo.numCntOffsetFromFirst.size()) {
            pendingStraightInfo.numCntOffsetFromFirst.push_back( 1 );
        }
        // increate existed num in straight
        else {
            pendingStraightInfo.numCntOffsetFromFirst[ numOffset ]++;
        }
        
        // if the number is the end of the straight -> check match whole straight
        if(numOffset == pendingStraightInfo.groupSize - 1) {
            int matchedStraightNum = INT_MAX;
            for(auto straightNumCnt : pendingStraightInfo.numCntOffsetFromFirst) {
                matchedStraightNum = min( matchedStraightNum, straightNumCnt );
            }

            for(auto &straightNumCnt : pendingStraightInfo.numCntOffsetFromFirst) {
                straightNumCnt -= matchedStraightNum;
            }

            while(pendingStraightInfo.numCntOffsetFromFirst[0] == 0) {
               pendingStraightInfo.firstNum ++;
               pendingStraightInfo.numCntOffsetFromFirst.pop_front();
            }
        }

        return true;
    }


#if DEBUG_EN
    void debugPrintStraightNum(string title, int num, tPendingStraightInfo &pendingStraightInfo) {
        cout << title << num << endl; 
        for(int i = 0; i < pendingStraightInfo.numCntOffsetFromFirst.size(); i++) {
            cout << (pendingStraightInfo.firstNum + i) << " : " << pendingStraightInfo.numCntOffsetFromFirst[i] << endl;;
        }
        cout << endl;
    }
#else
    #define debugPrintStraightNum(_DUMMY0_, _DUMMY1_, _DUMMY2_)
#endif
public:
    bool isNStraightHand(vector<int>& hand, int groupSize) {

        // quick check
        if(hand.size() % groupSize) return false;
        if(hand.size() == 1) return true;
        if(groupSize == 1) return true;
        
        // sort all the numbers
        sort(hand.begin(), hand.end());

        // use a structure to store the on check info
        tPendingStraightInfo pendingStraightInfo;
        pendingStraightInfo.groupSize = groupSize;

        // check each number
        for(auto num : hand) {

            debugPrintStraightNum("add num start: ", num, pendingStraightInfo);
            
            if(!addNumToPendingStraight(num, pendingStraightInfo)) return false;
            
            debugPrintStraightNum("add num end: ", num, pendingStraightInfo);
        }

        return pendingStraightInfo.numCntOffsetFromFirst.size() == 0;
    }
};
```

# Answer - Bulk Sort -> 寫法最簡單直覺
## V1 - 使用 map - 速度很慢
```Cpp
class Solution {
public:
    bool isNStraightHand(vector<int>& hand, int groupSize) {

        // quick check
        if(hand.size() % groupSize) return false;
        if(hand.size() == 1) return true;
        if(groupSize == 1) return true;

        // statistic of each number
        map<int, int> numStatistic;
        for(auto num : hand) numStatistic[num]++;

        // check straight
        for(auto [num, cnt] : numStatistic) {

            // if the count of current number had been reduced to zero
            if( !cnt ) continue;

            // straight head / end
            int straightHeadNum = num;
            int straightEndNum = num + (groupSize-1);

            // check from straight head
            for( int straightNum = straightHeadNum; straightNum <= straightEndNum; straightNum++) {
                if( numStatistic.count( straightNum ) == 0 ) return false;
                if( numStatistic[ straightNum ] < cnt ) return false;
                numStatistic[ straightNum ] -= cnt;
            }
        }
        return true;
        
    }
};
```

## V2 - 複習1st：使用 vector - 速度快很多
```Cpp
class Solution {
private:
    struct numCnt {
        int val;
        int cnt;
    };
public:
    bool isNStraightHand(vector<int>& hand, int groupSize) {
        if(hand.size() % groupSize) return false;

        sort(hand.begin(), hand.end());

        vector<numCnt> numStatistic;
        numStatistic.reserve(hand.size());

        for(int i = 0, curNumCnt = 0; i < hand.size(); i+= curNumCnt) {
            curNumCnt = 1;
            while( ( (i + curNumCnt) < hand.size() ) && (hand[i] == hand[i+curNumCnt]) ) curNumCnt++;

            numStatistic.push_back({.val = hand[i], .cnt = curNumCnt});
        }

        for(int i = 0; i < numStatistic.size(); i++) {
            if(numStatistic[i].cnt == 0) continue;

            int pivotNumVal = numStatistic[i].val;
            int pivotNumCnt = numStatistic[i].cnt;
            for(int idx = 0; idx < groupSize; idx++) {
                if( (i+idx) >= numStatistic.size() ) return false;
                if( numStatistic[i+idx].val != (pivotNumVal+idx) ) return false;
                if( numStatistic[i+idx].cnt < pivotNumCnt ) return false;
                numStatistic[i+idx].cnt -= pivotNumCnt;
            }
        }

        return true;
    }
};
```

## V3：複習2nd
```Cpp
class Solution {
private:
	struct handNumAndCnt{
		int num;
		int cnt;
	};
public:
    bool isNStraightHand(vector<int>& hand, int groupSize) {
	    if(groupSize == 1) return true;
		if(hand.size() % groupSize) return false;

		vector<handNumAndCnt> handNumWithCnt;
		handNumWithCnt.reserve(hand.size());

		sort(hand.begin(), hand.end(), less<int>());
		for(int i = 0; i < hand.size(); i++) {
			if(handNumWithCnt.empty() || (hand[i] != handNumWithCnt.back().num) ) {
				handNumWithCnt.push_back({.num = hand[i], .cnt = 1});
			}
			else {
				handNumWithCnt.back().cnt++;
			}
		}

		for(int numIdx = 0; numIdx < handNumWithCnt.size(); numIdx++) {
			// straight with current num on 1st card
			auto [pivotNum, straightCnt] = handNumWithCnt[ numIdx ];
			if(straightCnt == 0) continue;

			// collect the remained num of current straights
			for(int i = 1; i < groupSize; i++) {
				if(handNumWithCnt[ numIdx + i ].num != (pivotNum + i)) return false;
				if(handNumWithCnt[ numIdx + i ].cnt < straightCnt) return false;
				handNumWithCnt[ numIdx + i ].cnt -= straightCnt;
			}
		}
		return true;
    }
};
```