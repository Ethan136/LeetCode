---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)

# Concept
- **踩到 last index 就算走完 -> nums[ i ] 只要檢查 0 to (last index - 1) -> 不用檢查 last index**
- 每次跳之前，先預看「這次跳到哪邊，下一次才可以跳最遠」
	- 如果可以跳到 last index -> 結束
	- 如果不能靠到 last index -> 從這次可以跳到範圍中，找出「跳到哪個位置下次能跳最遠」

# Answer
## V1 - 寫比較複雜，但說明詳細
```Cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        // if there's onl one num -> start point = finish point
        if(nums.size() == 1) return 0;

        // the min steps to reach end
        int minStep = 0;

        // check from first index to last index
        int curIdx = 0;
        while( curIdx < nums.size() ) {

            // increase step
            minStep += 1;

            // the furtherst index reachable from the current index
            int curJumpFurthestIdx = curIdx + nums[ curIdx ];

            // if the final position can be jumped from the current position
            if(curJumpFurthestIdx >= nums.size()-1) break;

            // the index after the current jump: init from the one next the currrent
            int nextIdx = curIdx + 1, nextJumpFurthestIdx = nextIdx + nums[ nextIdx ];

            // check all the available indices after the current jump
            for(int i = nextIdx + 1; i <= curJumpFurthestIdx && i < nums.size(); i++ ) {

                // next furthest index jump from the candidate
                int candidateJumpFurthestIdx = i + nums[i];

                // if the candidate of the next index can't jumper further
                if( candidateJumpFurthestIdx  <= nextJumpFurthestIdx ) continue;

                // if the candicate of the next index can jump further than the other candidates
                nextJumpFurthestIdx = candidateJumpFurthestIdx;
                nextIdx = i;
            }

            // jump the the index which can go furthest in the next term
            curIdx = nextIdx;

        }

        // finish
        return minStep;
    }
};
```
## V2 - 寫比較簡單 -> 採用這個
```Cpp
class Solution {
public:
    int jump(vector<int>& nums) {

        int jumpCnt = 0;

        // WARNING: STEP AT LAST INDEX (nums.size() - 1) -> REACH END
        for(int i = 0, jumpToIdx = 0; i < (nums.size()-1); i = jumpToIdx) {

            // update jump cnt
            jumpCnt++;

            // check if current jump could reach the end index
            int maxCurJumpIdx = (i + nums[i]);
            if( maxCurJumpIdx >= (nums.size() - 1) ) break;

            // preview the next jump and select the furthest one for the current jump
            int maxNextJumpIdx = 0;
            for(int nextIdx = i; nextIdx <= maxCurJumpIdx; nextIdx++) {
    
                int nextJumpIdx = nextIdx + nums[nextIdx];
                if(nextJumpIdx < maxNextJumpIdx) continue;
                
                maxNextJumpIdx = nextJumpIdx;
                jumpToIdx = nextIdx;
            }
        }

        return jumpCnt;
    }
};
``` 