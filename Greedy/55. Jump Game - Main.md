---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[55. Jump Game](https://leetcode.com/problems/jump-game/)

# Concept
- 從 index 0 開始走，隨時檢查最遠可以走多遠
- 如果當前的 index 是可以走的最遠距離 -> 停止往後走
- 最後回傳最遠可以走的距離是否 >= last idx

# Answer
## V1：複習 1st
```Cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxReachIdx = 0;
        for(int i = 0; (i <= maxReachIdx) && (i < nums.size()); i++) {
            maxReachIdx = max(maxReachIdx, i + nums[i]);
        }
        return maxReachIdx >= (nums.size() - 1);
    }
};
``` 

## V2：複習 2nd
```Cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {

        // no need to check the methods to last index
        // only need to check whether last index is possible -> only most further index is important

        // (1) start on idx 0
        int maxReachIdx = 0;

        // (2) check through all indices
        for(int i = 0; i <= maxReachIdx; i++) {
            if(maxReachIdx >= (nums.size() - 1)) return true;
            maxReachIdx = max(maxReachIdx, i + nums[i]);
        }

        return false;
    }
};
```