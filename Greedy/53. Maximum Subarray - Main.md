---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

# Concept
- 假設「當前數字加入 current sum，current sum 反而比當前數字小」 -> 當前數字設為新的 current sum 的開頭
- 每次更新 current sum 後 -> 更新 max sum

# Warning
- **max / min 沒辦法用在 long long
- **max / min 可以用在 long / int / double / float / char

# Answer
## V1：複習 1st
```Cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {

	    // set first num to sum
        int curSum = nums[0];
        int maxSum = nums[0];

        for(int i = 1; i < nums.size(); i++) {
            // check whether to
            // (1) add num to current sum
            // (2) or to build a new sum from current num
            curSum = max(curSum+nums[i], nums[i]);

            // update the max sum by the current sub-array-sub
            maxSum = max(curSum, maxSum);
        }

        return maxSum;
    }
};
``` 

## V2：複習 2nd（這個寫法比較好）
- **這題是考基本性質分析，看能不能定義某一種狀態，來確保各種情況都包含進去**
```Cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {

        // init result
        int maxSum = INT_MIN;

        // check max sum sub-array
        int maxSumToCurIdx = INT_MIN;
        for(int i = 0; i < nums.size(); i++) {
            // if current sum < 0: -> set new sub-array start from curNum
            if(maxSumToCurIdx < 0) {
                maxSumToCurIdx = nums[i];
            }
            // if current sum >= 0: -> add num to sub-array
            else {
                maxSumToCurIdx += nums[i];
            }

            // update max
            maxSum = max( maxSum, maxSumToCurIdx );
        }

        // finish
        return maxSum;
    }
};
```