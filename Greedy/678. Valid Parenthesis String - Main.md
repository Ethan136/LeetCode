---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)

# Answer: Brute Force DFS - O( 2^d * (N-d) )
- d = * 的數目
- 會發生 timeout
```Cpp
class Solution {
private:
    bool dfsCheckValid(string &s, int startIdx, int leftBracketNum) {

        for(int i = startIdx; i < s.size(); i++) {
            if(leftBracketNum < 0) return false;
            switch(s[i]) {
            case '(':
                leftBracketNum++;
                break;
            case ')':
                leftBracketNum--;
                break;
            default:
                // serve as '('
                if(dfsCheckValid(s, i+1, leftBracketNum+1)) return true;

                // serve as ''
                if(dfsCheckValid(s, i+1, leftBracketNum)) return true;

                // serve as ')'
                if(dfsCheckValid(s, i+1, leftBracketNum-1)) return true;

                // all above check fail
                return false;
            }
        }

        return (leftBracketNum == 0);
    }
public:
    bool checkValidString(string s) {
        return dfsCheckValid(s, 0, 0);
    }
};
```
# Answer: Greedy - O(N)
- 唯一需要考量的，是遇到 * 的時候，要當作 ( 還是 ) 還是 empty
- 掛號匹配是 左右 match 而且必須是 () 而不能是 )( -> 有順序性
- * 的三種情況
	- case '(' -> 讓左掛號數量增加
	- case ')' -> 讓右掛號數量減少
	- case 'empty' -> 掛號數量不變
- -> **會讓左掛號的數量，在一個可能的範圍內** \[minValidLeftSign, maxPossibleLeftBracket\]
	- minValidLeftSign -> 在顧及 valid bracket pair 的情況下盡量讓 * 視為 )，消除左掛號
	- maxPossibleLeftBracket -> 不考慮 valid bracket pair 的情況下完全讓 * 視為 (，儲備起來之後消除右掛號
	- 一旦發生 maxPossibleLeftBracket 不足以消除當下檢查到的 ) -> return false
	- 檢查後確保 minValidLeftSign 可以為 0

## V1：複習1st
```Cpp
class Solution {
public:
    bool checkValidString(string s) {
        int maxPossibleLeftBracket = 0;
        int minValidLeftBracket = 0;
        for(char c : s) {

            switch(c) {

            case '(':
                maxPossibleLeftBracket++;
                minValidLeftBracket++;
                break;

            case ')':
                // if max possible left bracket is not enough
                if(maxPossibleLeftBracket == 0) return false;
                maxPossibleLeftBracket--;

                // use * to cancel right bracket
                if(minValidLeftBracket > 0) minValidLeftBracket--;
                break;

            case '*':
                // serve as left bracket
                maxPossibleLeftBracket++;

                // serve as right bracket if there's any left bracket
                // or serve as empty
                if(minValidLeftBracket > 0) minValidLeftBracket--;
                break;
            }
        }

        return (minValidLeftBracket == 0);
    }
};
``` 


## V2：複習2nd
```Cpp
class Solution {
public:
    bool checkValidString(string s) {

        // branch upper bound & lower bound
        int maxOpenBracket = 0;
        int minOpenBracket = 0;
        
        for(char c : s) {
            switch (c) {
            case '(':
                maxOpenBracket++;
                minOpenBracket++;
                break;

            case ')':
                if(--maxOpenBracket < 0) return false;
                if(minOpenBracket > 0) minOpenBracket--;
                break;

            case '*':
                maxOpenBracket++;
                if(minOpenBracket > 0) minOpenBracket--;
                break;
            }
        }

        return (minOpenBracket == 0);
    }
};
```