---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[1899. Merge Triplets to Form Target Triplet](https://leetcode.com/problems/merge-triplets-to-form-target-triplet/)

# Concept
- 目標： **某個 index 在 triplet[i] 等於 target[i]，其他 index triplet[i] 必須 <= target[i]**
- **直覺會想到用 sort，但其實沒辦法sort 1 次完成，而是必須「每個 element idx i 特別針對 triplet[i] sort 一次」**

# Answer：以 treplet vector index 為 base，依序檢查每個 triplet
## V1：不嚴謹檢查，檢查兩次（奇怪的做法）
不嚴謹檢查 triplet，檢查兩次（奇怪的做法，自己想的）
- **檢查的時候：只要檢查到「1個符合目標 target[i] 的就回傳 true」** 
- **檢查的時候：只要大於 target[i] 的都剔除**
- 這個檢查不嚴謹，有可能前面 triplets[ i ] 檢查 pass，後面的 triplets[ t ] 其實 invalid
```Cpp
class Solution {
private:
    bool checkTripletsAndPopOutLarger(vector<vector<int>>& triplets, int tripletIdx, int targetNum) {

        bool checkPass = false;
        for(int i = triplets.size()-1; i >= 0; i--) {

            // back swap pop out the triplet with value larget than the target
            if(triplets[i][ tripletIdx ] > targetNum) {
                swap(triplets[i], triplets.back());
                triplets.pop_back();
                continue;
            }

            // for the triplet with value equal to the target
            if(triplets[i][ tripletIdx ] == targetNum) {
                checkPass = true;
            }            
        }

        return checkPass;
    }
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
        
        // kick out the un-qualified triplets for each triplet index
        for(int i = 0; i < target.size(); i++) {
            if(!checkTripletsAndPopOutLarger(triplets, i, target[i])) return false;
        }

        // check the remained triplets
        for(int i = 0; i < target.size(); i++) {
            if(!checkTripletsAndPopOutLarger(triplets, i, target[i])) return false;
        }
        return true;
    }
};
```

## V2：檢查每個 index (嚴謹檢查) + bitmap 看是否所有 target[i] 都符合
```Cpp
#define BIT(N) (1 << (N))
class Solution {
private:
    unsigned int checkTripletMergeCandidate(vector<int>& triplet, vector<int> &target) {
        unsigned int matchIdxBitmap = 0;
        for(int i = 0; i < triplet.size(); i++) {
            if(triplet[i] > target[i]) return 0;
            if(triplet[i] == target[i]) matchIdxBitmap |= BIT(i);
        }
        return matchIdxBitmap;
    }
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {

        // the bitmap of the all matched indices
        unsigned int targetMatchIdxBitmap = 0;
        for(int i = 0; i < target.size(); i++) targetMatchIdxBitmap |= BIT(i);

        // to indicate whether all index of the target can be merged
        unsigned int overallMatchIdxBitmap = 0;

        // check all triplets
        for(auto triplet : triplets) {

            // check whether the current triplet can be the element of merge
            overallMatchIdxBitmap |= checkTripletMergeCandidate(triplet, target);

        }

        // check whether all the indices of the target can be merged
        return (overallMatchIdxBitmap == targetMatchIdxBitmap);
    }
};
```


## V3：檢查每個 index + bitmap 看是否所有 target 符合 + early match return
```Cpp
#define BIT(N) (1 << N)
class Solution {
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
        // the bitmap of all target[i] are matched
        unsigned int checkAllPassBitMap = 0;
        for(int i = 0; i < target.size(); i++) checkAllPassBitMap |= BIT(i);

        // check all triplets
        unsigned int checkResultBitMap = 0;
        for(auto &triplet : triplets) {

            // the checking condition of current triplet
            int matchBitMap = 0;
            bool validTriplet = true;

            // check each index of the target
            for(int i = 0; i < triplet.size(); i++) {

                if(triplet[i] > target[i]) {
                    validTriplet = false;
                    break;
                }

                if(triplet[i] == target[i]) {
                    matchBitMap |= BIT(i);
                }
            }

            // if the triplet is valid & match any target[i]
            if(validTriplet && matchBitMap) {
                checkResultBitMap |= matchBitMap;
            }

            // if all target[i] are matched
            if(checkResultBitMap == checkAllPassBitMap) {
                return true;
            }
        }

        // for the condition that the target can't be formed
        return false;
    }
};
```


# Answer：以 triplet element index 為 base，依序檢查每個 element
- 依序檢查每個 triplet element index -> 如果某個 element triplet index 找不到符合的 -> return false
- **某個 element index i 檢查後剔除 triplet -> triplet[i] > target[i]**
- 檢查 element index 的時候，是從「當下的 base index i 往後檢查，必須要 <= target[i]」
```Cpp
#define TRIPLET_ELEMENT_NUM (3)
class Solution {
private:
    bool checkValidTripletAfterIdx(auto &triplet, auto &target, int idx) {

        for(int i = idx; i < TRIPLET_ELEMENT_NUM; i++) {
            if(triplet[i] > target[i]) return false;
        }

        return true;
    }
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {

        // assume all triplets are valid
        vector<int> validTripletIdxVec(triplets.size());
        for(int i = 0; i < validTripletIdxVec.size(); i++) validTripletIdxVec[i] = i;

        // check from element 0 to 2, filter valid triplet in each term of checking process
        for(int i = 0; i < TRIPLET_ELEMENT_NUM; i++) {

            // check triplet with value[i=k] = target[i] && value[i < k] less than target [i]
            bool anyTripletMatchIdx = false;
            for(int t = (int)(validTripletIdxVec.size())-1; t >= 0; t--) {

                // the index to be checked
                int checkIdx = validTripletIdxVec[t];

                // check whether the triplet is valid
                if(!checkValidTripletAfterIdx(triplets[ checkIdx ], target, i)) {

                    // swap & pop back the invalid triplet
                    swap(validTripletIdxVec[t], validTripletIdxVec.back());
                    validTripletIdxVec.pop_back();

                    // skip index value match and check next triplet
                    continue;
                }

                // update if there's any triplet match the target index
                anyTripletMatchIdx = (anyTripletMatchIdx || triplets[checkIdx][i] == target[i]);
            }

            // if there's no triplet match the current index i
            if(!anyTripletMatchIdx) return false;
        }

        // if the remained triplets could form the target
        return validTripletIdxVec.size() > 0;
    }
};
```

# Answer：試著用模板 - 把 invalid index 剔除（複習2nd）
## V1：使用 set 剔除 invalid idx
- **想法很簡單，實作速度慢（用到 set）**
- 先剔除iinvalid 的
- 再檢查省下的能不能湊出 target
```Cpp

class Solution {
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
	    unordered_set<int> invalidIdxSet;
	    vector<int> trpIdxForEachTargetElmt(target.size(), 0);

		// take out invalid triplet
		for(int e = 0; e < target.size(); e++) {
			for(int i = 0; i < triplets.size(); i++) {
				if(invalidIdxSet.count(i)) {
					continue;
				}

				if(triplets[i][e] > target[e]) {
					invalidIdxSet.insert(i);
				}
			}
		}

		// fetch valid for each element
		for(int e = 0; e < target.size(); e++) {
			for(int i = 0; i < triplets.size(); i++) {
				if(invalidIdxSet.count(i)) {
					continue;
				}

				if(triplets[i][e] == target[e]) {
					trpIdxForEachTargetElmt[e]++;
				}
			}

			if(trpIdxForEachTargetElmt[e] == 0) {
				return false;
			}
		}
		return true;
    }
};
```

## V2：使用 vector 記錄可用的 index

```Cpp

class Solution {
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
		vector<int> validIdx(triplets.size());
		for(int i = 0; i < validIdx.size(); i++) validIdx[i] = i;

	    vector<int> trpIdxForEachTargetElmt(target.size(), 0);

		// take out invalid triplet
		for(int e = 0; e < target.size(); e++) {
			for(int i = 0; i < validIdx.size(); i++) {

				int tripletIdx = validIdx[i];
				if(tripletIdx == -1) continue;
	
				if(triplets[ tripletIdx ][e] > target[e]) {
					validIdx[i] = -1;
				}
			}
		}

		// fetch valid for each element
		for(int e = 0; e < target.size(); e++) {
			for(int i = 0; i < validIdx.size(); i++) {

				int tripletIdx = validIdx[i];
				if(tripletIdx == -1) continue;
	
				if(triplets[ tripletIdx ][e] == target[e]) {
					trpIdxForEachTargetElmt[e]++;
				}
			}

			if(trpIdxForEachTargetElmt[e] == 0) {
				return false;
			}
		}
		return true;
    }
};
```

# Answer：試著用模板 - Match 的情況用 bit map 記錄起來交集（複習2nd）
- **lambda func 裡面的 return 0 (const) 預設是 int**，如果裡面又有 return unsigned int -> 會發生衝突
```Cpp

class Solution {
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
		
		auto getValidMatchBMP(auto &triplet, auto &target) {
			unsigned int matchBMP = 0;
			for(int i = 0; i < target.size(); i++) {
				if(triplet[i] > target[i]) return (unsigned int)0;
				if(triplet[i] == target[i]) matchBMP |= (1 << i);
			}
			return matchBMP;
		}

		unsigned int targetMatchBMP = 0;
		for(int i = 0; i < target.size(); i++) targetMatchBMP |= (1 << i);

		unsigned int overallMatchBMP = 0;
		for(int i = 0; i < triplets.size(); i++) {
			unsigned int matchBMP = getValidMatchBMP(triplets[i], target);
			if(matchBMP == 0) continue;
			
			overallMatchBMP |= matchBMP;
			if(overallMatchBMP == targetMatchBMP) return true;
		}

		return false;
    }
};
```