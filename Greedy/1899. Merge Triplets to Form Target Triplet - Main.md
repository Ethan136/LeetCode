---
ParentTask:
  - "[[greedy]]"
---

# LeetCode
[1899. Merge Triplets to Form Target Triplet](https://leetcode.com/problems/merge-triplets-to-form-target-triplet/)

# Concept
- 目標： **某個 index 在 triplet[i] 等於 target[i]，其他 index triplet[i] 必須 <= target[i]**
- **直覺會想到用 sort，但其實沒辦法sort 1 次完成，而是必須「每個 element idx i 特別針對 triplet[i] sort 一次」**

# Answer：以 treplet vector index 為 base，依序檢查每個 triplet
## V1：不嚴謹檢查，檢查兩次（奇怪的做法）
不嚴謹檢查 triplet，檢查兩次（奇怪的做法，自己想的）
- **檢查的時候：只要檢查到「1個符合目標 target[i] 的就回傳 true」** 
- **檢查的時候：只要大於 target[i] 的都剔除**
- 這個檢查不嚴謹，有可能前面 triplets[ i ] 檢查 pass，後面的 triplets[ t ] 其實 invalid
```Cpp
class Solution {
private:
    bool checkTripletsAndPopOutLarger(vector<vector<int>>& triplets, int tripletIdx, int targetNum) {

        bool checkPass = false;
        for(int i = triplets.size()-1; i >= 0; i--) {

            // back swap pop out the triplet with value larget than the target
            if(triplets[i][ tripletIdx ] > targetNum) {
                swap(triplets[i], triplets.back());
                triplets.pop_back();
                continue;
            }

            // for the triplet with value equal to the target
            if(triplets[i][ tripletIdx ] == targetNum) {
                checkPass = true;
            }            
        }

        return checkPass;
    }
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
        
        // kick out the un-qualified triplets for each triplet index
        for(int i = 0; i < target.size(); i++) {
            if(!checkTripletsAndPopOutLarger(triplets, i, target[i])) return false;
        }

        // check the remained triplets
        for(int i = 0; i < target.size(); i++) {
            if(!checkTripletsAndPopOutLarger(triplets, i, target[i])) return false;
        }
        return true;
    }
};
```

## V2：檢查每個 index (嚴謹檢查) + bitmap 看是否所有 target[i] 都符合
```Cpp
#define BIT(N) (1 << (N))
class Solution {
private:
    unsigned int checkTripletMergeCandidate(vector<int>& triplet, vector<int> &target) {
        unsigned int matchIdxBitmap = 0;
        for(int i = 0; i < triplet.size(); i++) {
            if(triplet[i] > target[i]) return 0;
            if(triplet[i] == target[i]) matchIdxBitmap |= BIT(i);
        }
        return matchIdxBitmap;
    }
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {

        // the bitmap of the all matched indices
        unsigned int targetMatchIdxBitmap = 0;
        for(int i = 0; i < target.size(); i++) targetMatchIdxBitmap |= BIT(i);

        // to indicate whether all index of the target can be merged
        unsigned int overallMatchIdxBitmap = 0;

        // check all triplets
        for(auto triplet : triplets) {

            // check whether the current triplet can be the element of merge
            overallMatchIdxBitmap |= checkTripletMergeCandidate(triplet, target);

        }

        // check whether all the indices of the target can be merged
        return (overallMatchIdxBitmap == targetMatchIdxBitmap);
    }
};
```


## V3：檢查每個 index + bitmap 看是否所有 target 符合 + early match return
```Cpp
#define BIT(N) (1 << N)
class Solution {
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
        // the bitmap of all target[i] are matched
        unsigned int checkAllPassBitMap = 0;
        for(int i = 0; i < target.size(); i++) checkAllPassBitMap |= BIT(i);

        // check all triplets
        unsigned int checkResultBitMap = 0;
        for(auto &triplet : triplets) {

            // the checking condition of current triplet
            int matchBitMap = 0;
            bool validTriplet = true;

            // check each index of the target
            for(int i = 0; i < triplet.size(); i++) {

                if(triplet[i] > target[i]) {
                    validTriplet = false;
                    break;
                }

                if(triplet[i] == target[i]) {
                    matchBitMap |= BIT(i);
                }
            }

            // if the triplet is valid & match any target[i]
            if(validTriplet && matchBitMap) {
                checkResultBitMap |= matchBitMap;
            }

            // if all target[i] are matched
            if(checkResultBitMap == checkAllPassBitMap) {
                return true;
            }
        }

        // for the condition that the target can't be formed
        return false;
    }
};
```


# Answer：以 triplet element index 為 base，依序檢查每個 element
- 依序檢查每個 triplet element index -> 如果某個 element triplet index 找不到符合的 -> return false
- **某個 element index i 檢查後剔除 triplet -> triplet[i] > target[i]**
- 檢查 element index 的時候，是從「當下的 base index i 往後檢查，必須要 <= target[i]」
```Cpp
#define TRIPLET_ELEMENT_NUM (3)
class Solution {
private:
    bool checkValidTripletAfterIdx(auto &triplet, auto &target, int idx) {

        for(int i = idx; i < TRIPLET_ELEMENT_NUM; i++) {
            if(triplet[i] > target[i]) return false;
        }

        return true;
    }
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {

        // assume all triplets are valid
        vector<int> validTripletIdxVec(triplets.size());
        for(int i = 0; i < validTripletIdxVec.size(); i++) validTripletIdxVec[i] = i;

        // check from element 0 to 2, filter valid triplet in each term of checking process
        for(int i = 0; i < TRIPLET_ELEMENT_NUM; i++) {

            // check triplet with value[i=k] = target[i] && value[i < k] less than target [i]
            bool anyTripletMatchIdx = false;
            for(int t = (int)(validTripletIdxVec.size())-1; t >= 0; t--) {

                // the index to be checked
                int checkIdx = validTripletIdxVec[t];

                // check whether the triplet is valid
                if(!checkValidTripletAfterIdx(triplets[ checkIdx ], target, i)) {

                    // swap & pop back the invalid triplet
                    swap(validTripletIdxVec[t], validTripletIdxVec.back());
                    validTripletIdxVec.pop_back();

                    // skip index value match and check next triplet
                    continue;
                }

                // update if there's any triplet match the target index
                anyTripletMatchIdx = (anyTripletMatchIdx || triplets[checkIdx][i] == target[i]);
            }

            // if there's no triplet match the current index i
            if(!anyTripletMatchIdx) return false;
        }

        // if the remained triplets could form the target
        return validTripletIdxVec.size() > 0;
    }
};
```