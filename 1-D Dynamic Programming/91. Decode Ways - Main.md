---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[91. Decode Ways](https://leetcode.com/problems/decode-ways/)
- recursive pure
- recursive + DP top to bottom
- DP bottom to top
- DP bottom to top + memory optz

# Answer：Top Down
## V1：Backtracking DFS (沒使用 DP)
```Cpp
class Solution {
private:
int checkCombinaionFromtIdx(string &s, int Idx) {
    // input index is invalid
    if (Idx < 0 || Idx >= s.size()) return 0;

    // calculate the current number
    int curNum = s[Idx] - '0';
    
    // start num is invalid
    if(!curNum) return 0;
    
    // curnum is the end of string
    if(Idx == s.size() - 1) return 1;
    
    // get next num
    int nextNum = s[Idx+1] - '0';

    // (1) current number single
    int combinationIfCurNumSingle = 0;
    if(nextNum > 0 ) {
        combinationIfCurNumSingle = (Idx+1 < s.size()) ? checkCombinaionFromtIdx(s, Idx + 1) : 1;
    }
    
    // (2) current number combined with next number
    int combinationIfWithNextNum = 0;
    if((curNum == 1) || ( (curNum == 2) && (nextNum <= 6) )) {
        combinationIfWithNextNum = (Idx + 2 < s.size()) ? checkCombinaionFromtIdx(s, Idx + 2) : 1;
    }
    
    return combinationIfCurNumSingle + combinationIfWithNextNum;
}
public:
    int numDecodings(string s) {
        return checkCombinaionFromtIdx(s, 0);
    }
};
``` 

## V2：Backtracking DFS + DP
```Cpp
class Solution {
private:
int checkCombinaionFromtIdx(string &s, int Idx, vector<int>& finishIdxCombinationCntMap) {
    // input index is invalid
    if (Idx < 0 || Idx >= s.size()) return 0;
    
    // check if the index had been calculated before
    if( finishIdxCombinationCntMap[Idx] != -1 ) return finishIdxCombinationCntMap[Idx];

    // calculate the current number
    int curNum = s[Idx] - '0';
    
    // start num is invalid
    if(!curNum) return 0;
    
    // curnum is the end of string
    if(Idx == s.size() - 1) return 1;
    
    // get next num
    int nextNum = s[Idx+1] - '0';

    // (1) current number single
    int combinationIfCurNumSingle = (Idx+1 < s.size()) ? checkCombinaionFromtIdx(s, Idx + 1, finishIdxCombinationCntMap) : 1;
    
    // (2) current number combined with next number
    int combinationIfWithNextNum = 0;
    if((curNum == 1) || ( (curNum == 2) && (nextNum <= 6) )) {
        combinationIfWithNextNum = (Idx + 2 < s.size()) ? checkCombinaionFromtIdx(s, Idx + 2, finishIdxCombinationCntMap) : 1;
    }
    
    finishIdxCombinationCntMap[Idx] = combinationIfCurNumSingle + combinationIfWithNextNum;
    return finishIdxCombinationCntMap[Idx];
}
public:
    int numDecodings(string s) {
        vector<int> finishIdxCombinationCntMap(s.size(), -1);
        return checkCombinaionFromtIdx(s, 0, finishIdxCombinationCntMap);
    }
};
```

## V3：Backtracking DFS + DP (複習時候寫的，簡潔版本)
```Cpp
class Solution {
private:
    int numDecodingsFromIdx(string &s, int startIdx, auto &numDecRecord) {
        if(startIdx >= s.size()) {
            return 1;
        }

        if(numDecRecord[startIdx] >= 0) {
            return numDecRecord[startIdx];
        }

        if(s[startIdx] == '0') {
            return 0;
        }

        // decode cnt result
        int decWays = 0;

        // single num decode
        decWays += numDecodingsFromIdx(s, startIdx+1, numDecRecord);

        // double num decode
        int nextIdx = startIdx+1;
        if( (nextIdx < s.size()) && 
           ((s[startIdx] == '1') || ((s[startIdx] == '2') && (s[nextIdx] <= '6')) ) ) {
            decWays += numDecodingsFromIdx(s, startIdx+2, numDecRecord);
        }

        numDecRecord[startIdx] = decWays;
        return decWays;
    };
public:
    int numDecodings(string s) {
        vector<int> numDecRecord(s.size(), -1);
        return numDecodingsFromIdx(s, 0, numDecRecord);
    }
};
```

# Answer：Bottom Up
## V1：Iteration Bottom Up + DP
```Cpp
#define CHAR_NUM_TO_INT(c) ((c) - '0')

class Solution {
private:

    enum eDecodeMethod {
        CANT_DECODE_FROM_HERE,
        DECODE_THIS_DIGIT_ONLY,
        DECODE_MUST_WITH_NEXT_DIGIT,
        DECODE_SINGLE_OR_WITH_NEXT_DIGIT
    };

    eDecodeMethod CheckTwoDigitDecodeMethod(string &s, int startIdx) {
        // start idx out of range
        if (startIdx >= s.size()) return CANT_DECODE_FROM_HERE;

        // only one element left
        if (startIdx == s.size() - 1)
            return CHAR_NUM_TO_INT(s[startIdx])
                    ? DECODE_THIS_DIGIT_ONLY
                    : CANT_DECODE_FROM_HERE;

        // check two elements
        switch (CHAR_NUM_TO_INT(s[startIdx])) {
            case 0:
                return CANT_DECODE_FROM_HERE;

            case 1:
                if (CHAR_NUM_TO_INT(s[startIdx + 1]) == 0) return DECODE_MUST_WITH_NEXT_DIGIT;
                else return DECODE_SINGLE_OR_WITH_NEXT_DIGIT;

            case 2:
                if (CHAR_NUM_TO_INT(s[startIdx + 1]) == 0) return DECODE_MUST_WITH_NEXT_DIGIT;
                if (CHAR_NUM_TO_INT(s[startIdx + 1]) >= 7) return DECODE_THIS_DIGIT_ONLY;
                else return DECODE_SINGLE_OR_WITH_NEXT_DIGIT;
                
            default:
                return DECODE_THIS_DIGIT_ONLY;
        }
    }

public:
    int numDecodings(string s) {
        // if there's no digit
        if (s.empty()) return 0;

        // the decode ways of index N when checking from last inde to the first one
        // augment two combination at the end (to deal with the indices of i+1, i+2 in the initial condition)
        // s.size() = lastIdx + 1 -> the 1st character after the digit series -> serve as "only one way to handle"
        // s.size() + 1 = lastIdx + 2 -> the 2nd character after the digit series -> serve as "only one way to handle"
        vector<int> combination(s.size() + 2);
        combination[s.size()] = 1;
        combination[s.size()+1] = 1;

        // check the decode ways from the last to the first
        for (int i = int(s.size()) - 1; i >= 0; i--) {

            // if both the combination of two indices later are zero -> the previous combination method will be zero
            if(!combination[i + 1] && !combination[i + 2]) return 0;

            // che the combination methods based on the decode condition and the "already checked combination on later index"
            switch (CheckTwoDigitDecodeMethod(s, i)) {
                case DECODE_THIS_DIGIT_ONLY:
                    combination[i] = combination[i + 1];
                    break;

                case DECODE_MUST_WITH_NEXT_DIGIT:
                    combination[i] = combination[i + 2];
                    break;

                case DECODE_SINGLE_OR_WITH_NEXT_DIGIT:
                    combination[i] = combination[i + 1] + combination[i + 2];
                    break;

                case CANT_DECODE_FROM_HERE:
                default:
                    combination[i] = 0;
                    break;
            }
        }
        return combination[0];  
    }
};
```

## V2：Iteration Bottom Up + DP Space Optz
```Cpp
#define CHAR_NUM_TO_INT(c) ((c) - '0')

class Solution {
private:

    enum eDecodeMethod {
        CANT_DECODE_FROM_HERE,
        DECODE_THIS_DIGIT_ONLY,
        DECODE_MUST_WITH_NEXT_DIGIT,
        DECODE_SINGLE_OR_WITH_NEXT_DIGIT
    };

    eDecodeMethod CheckTwoDigitDecodeMethod(string &s, int startIdx) {
        // start idx out of range
        if (startIdx >= s.size()) return CANT_DECODE_FROM_HERE;

        // only one element left
        if (startIdx == s.size() - 1)
            return CHAR_NUM_TO_INT(s[startIdx])
                    ? DECODE_THIS_DIGIT_ONLY
                    : CANT_DECODE_FROM_HERE;

        // check two elements
        switch (CHAR_NUM_TO_INT(s[startIdx])) {
            case 0:
                return CANT_DECODE_FROM_HERE;

            case 1:
                if (CHAR_NUM_TO_INT(s[startIdx + 1]) == 0) return DECODE_MUST_WITH_NEXT_DIGIT;
                else return DECODE_SINGLE_OR_WITH_NEXT_DIGIT;

            case 2:
                if (CHAR_NUM_TO_INT(s[startIdx + 1]) == 0) return DECODE_MUST_WITH_NEXT_DIGIT;
                if (CHAR_NUM_TO_INT(s[startIdx + 1]) >= 7) return DECODE_THIS_DIGIT_ONLY;
                else return DECODE_SINGLE_OR_WITH_NEXT_DIGIT;
                
            default:
                return DECODE_THIS_DIGIT_ONLY;
        }
    }

public:
    int numDecodings(string s) {
        // if there's no digit
        if (s.empty()) return 0;

        // the decode ways of index N when checking from last inde to the first one
        // augment two combination at the end (to deal with the indices of i+1, i+2 in the initial condition)
        // s.size() = lastIdx + 1 -> the 1st character after the digit series -> serve as "only one way to handle"
        // s.size() + 1 = lastIdx + 2 -> the 2nd character after the digit series -> serve as "only one way to handle"
        int combinationOfIdx = 0;
        int combinationOfIdxNext1 = 1;
        int combinationOfIdxNext2 = 1;

        // check the decode ways from the last to the first
        for (int i = int(s.size()) - 1; i >= 0; i--) {

            // if both the combination of two indices later are zero -> the previous combination method will be zero
            if(!combinationOfIdxNext1 && !combinationOfIdxNext2) return 0;

            // che the combination methods based on the decode condition and the "already checked combination on later index"
            switch (CheckTwoDigitDecodeMethod(s, i)) {
                case DECODE_THIS_DIGIT_ONLY:
                    combinationOfIdx = combinationOfIdxNext1;
                    break;

                case DECODE_MUST_WITH_NEXT_DIGIT:
                    combinationOfIdx = combinationOfIdxNext2;
                    break;

                case DECODE_SINGLE_OR_WITH_NEXT_DIGIT:
                    combinationOfIdx = combinationOfIdxNext1 + combinationOfIdxNext2;
                    break;

                case CANT_DECODE_FROM_HERE:
                default:
                    combinationOfIdx = 0;
                    break;
            }

            // update the combination of next & next2 indices
            combinationOfIdxNext2 = combinationOfIdxNext1;
            combinationOfIdxNext1 = combinationOfIdx;
        }
        return combinationOfIdx;  
    }
};
```
