# LeetCode
[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

# Concept
- **解題基底影響 DP 的形式及效果**
- **如何湊出不同數字的組合，而且每個 index 只能使用一次，是關鍵**
- **檢查某個數字是否能從 num[i] 湊出來 -> 可以用 DP**
- **因為一個數字只能用一次，檢查 available subset sum 的時候要由 high to low 檢查**

# Answer：DFS - 硬解
## Brute Force
- 用這個來做會很粗暴，而且無法輕易的 DP
```Cpp
#define MARK_USED_NUM   (0)
class Solution {
private:
    bool hasSubSetForTargetSum(auto &nums, int subSetSum) {

        if(subSetSum == 0) return true;
        if(subSetSum < 0) return false;

        bool checkPass = false;
        for(int i = 0; (!checkPass) && (i < nums.size()); i++) {
            if(nums[i] == MARK_USED_NUM) continue;
            int useNum = nums[i];

            nums[i] = MARK_USED_NUM;

            checkPass = hasSubSetForTargetSum(nums, subSetSum - useNum);

            nums[i] = useNum;
        }

        return checkPass;
    }
public:
    bool canPartition(vector<int>& nums) {
        int totalSum = 0;
        for(int num : nums) totalSum += num;

        if(totalSum % 2) return false;
        int subSetSum = totalSum / 2;

        for(int num : nums) {
            if(num > subSetSum) return false;
            if(num == subSetSum) return true;
        }

        return hasSubSetForTargetSum(nums, subSetSum);
    }
};
``` 

## DFS + DP - 不是很好的 DP，DP 必須是「當前使用的 set indices」
- **把「當前使用的 index 改用 string 來表示」，搭配 Map 來實現 DP**
- **速度超慢，必定 timeout**
- 這個 DP 的數量，是 2^(nums size) -> **超多**
```Cpp
class Solution {
private:
    bool hasSubSetForTargetSum(auto &nums, int subSetSum, 
                                string &subSetNumIdxBMP, auto &validSubSetIdxBMP) {

        if(subSetSum == 0) return true;
        if(subSetSum < 0) return false;
        if(validSubSetIdxBMP.count(subSetNumIdxBMP)) return validSubSetIdxBMP[subSetNumIdxBMP];

        bool checkPass = false;
        for(int i = 0; i < nums.size(); i++) {
            if(subSetNumIdxBMP[i] == 1) continue;
            subSetNumIdxBMP[i] = 1;

            checkPass = hasSubSetForTargetSum(nums, subSetSum - nums[i], subSetNumIdxBMP, validSubSetIdxBMP);
            subSetNumIdxBMP[i] = 0;

            if(checkPass) break;
        }

        validSubSetIdxBMP[subSetNumIdxBMP] = checkPass;
        return checkPass;
    }
public:
    bool canPartition(vector<int>& nums) {
        int totalSum = 0;
        for(int num : nums) totalSum += num;

        if(totalSum % 2) return false;
        int subSetSum = totalSum / 2;

        for(int num : nums) {
            if(num > subSetSum) return false;
            if(num == subSetSum) return true;
        }

        string subSetNumIdxBMP(nums.size(), 0);
        unordered_map<string, bool> validSubSetIdxBMP;

        return hasSubSetForTargetSum(nums, subSetSum, subSetNumIdxBMP, validSubSetIdxBMP);
    }
};
```


# Answer：正規 DP 做法
## V1 - 第一次寫，比較複雜
```Cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // check total sum
        int totalSum = 0;
        for(auto num : nums) totalSum += num;

        // validate total sum
        if(totalSum % 2) return false;

        // check the target sum of "the equal subset"
        int sumOfEqualSubset = totalSum / 2;

        // check all the possible sum from any combination
        // -> if it's possible to be equal to sumOfSubset
        // -> the numbers can be separated in two equal groups
        // (0) augment 0 as one possible condition -> subset without element
        // (1) index: the "available sum from any comb."
        // (2) value: whether it's possible to have this sum
        vector<bool> subSetSumMap(totalSum+1, false);
        subSetSumMap[0] = true;

        // check each possible sum
        // THE OUTER LOOP SHOULD BE THE ELEMENT OF NUMS
        // BECAUSE EACH ELEMENT CAN ONLY BE USED ONCE
        for(auto num : nums) {

            // check the possible sum
            // shoud check from larget sum to smaller
            // otherwise the "checked possible smaller sum" will influence the checking condition of the larger sum
            for(int subSetSum = subSetSumMap.size() - 1; subSetSum >= 0; subSetSum--) {

                // previous sum + current num = current sum
                // (1)check if the "previous sum" is valid
                int prevSubSetSum = subSetSum - num;
                if(prevSubSetSum < 0) continue;

                // (2)check if the "previous sum" can be combined from any subset
                if( !subSetSumMap[prevSubSetSum] ) continue;

                // (3)update the possible sum
                subSetSumMap[ subSetSum ] = true;
            }
        }
        
        // return if the target sum can't be combined        
        return subSetSumMap[ sumOfEqualSubset ];

    }
};
```

## V2 - 複習時候寫，比較簡潔
- **檢查 sum 的時候，從 large -> low 的順序檢查，這個是關鍵，以避免 nums[i] 重複使用**
```Cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int totalSum = 0;
        for(int num : nums) totalSum += num;

        if(totalSum % 2) return false;
        int subSetSum = totalSum / 2;

        vector<bool> numFromSubSet(subSetSum+1, false);
        numFromSubSet[0] = true;

        for(int num : nums) {
            for(int sum = subSetSum; sum >= 0; sum--) {
                if(sum - num < 0) break;
                if(numFromSubSet[sum - num] == false) continue;

                numFromSubSet[sum] = true;
            }
        }
        return numFromSubSet[subSetSum];
    }
};
```

## V2.2 - 複習時候寫，換個方式來處理以避免 num[i] 重複使用
- **透過 unordered_set 來避免 num[i] 重複使用**
- **因為用到 unordered_set，操作速度比較慢**
```Cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int totalSum = 0;
        for(int num : nums) totalSum += num;

        if(totalSum % 2) return false;
        int subSetSum = totalSum / 2;

        vector<int> sumFromSubSet;
        unordered_set<int> sumSet;

        sumFromSubSet.push_back(0);
        sumSet.insert(0);

        for(int num : nums) {
            int checkCnt = sumFromSubSet.size();
            for(int i = 0; i < checkCnt; i++) {
                int newSum = sumFromSubSet[i] + num;
    
                if(sumSet.count(newSum)) continue;
                if(newSum > subSetSum) continue;

                if(newSum == subSetSum) return true;
                sumFromSubSet.push_back(newSum);
                sumSet.insert(newSum);
            }
        }

        return false;
    }
};
```

# Answer：複習2nd - 模板化寫法
```Cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // check solution exist
        int totalSum = 0;
        for(int num : nums) totalSum += num;
        if(totalSum % 2) return false;

        // check num[i] to match targetSum
        int targetSum = totalSum / 2;

        // fast check subSum = targetSum - nums[i]
        unordered_set<int> subSumSet, nextSubSumSet;
        for(int i = 0; i < nums.size(); i++) {
            // check if target sum can be matched
            if(subSumSet.count(targetSum - nums[i])) return true;

            // expand to next subsum set
            for(int subSum : subSumSet) {
                nextSubSumSet.insert(subSum);
                nextSubSumSet.insert(subSum + nums[i]);
            }
            nextSubSumSet.insert(nums[i]);

            // swap for next calculation
            swap(nextSubSumSet, subSumSet);
        }

        // finish
        return subSumSet.count(targetSum);
    }
};
```