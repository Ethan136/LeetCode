---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[322. Coin Change](https://leetcode.com/problems/coin-change/)

# Answer：DFS + Top Down
## V1：DFS + TopDown (不使用 DP)
```Cpp
#define INVALID_COIN_NUM (-1)
class Solution {
private:
    int findMinUseCoinChange(vector<int>& sortedCoins, int amount) {

        // if the amout is zero -> change finish
        if(amount == 0) return 0;

        // if the amount is not legal
        if(amount < 0) return INVALID_COIN_NUM;

        // try each coin size
        int minUseCoinNum = INVALID_COIN_NUM;
        for(int i = 0; i < sortedCoins.size(); i++) {

            // try to use the selected coin
            int useCoinNumForRemainedAmount = findMinUseCoinChange(sortedCoins, (amount - sortedCoins[i]));

            // if the coin num of the remained amount is invalid
            if(useCoinNumForRemainedAmount == INVALID_COIN_NUM) continue;

            // the min used coin number with the selected coin
            int minUseWithSelectedCoin = useCoinNumForRemainedAmount + 1;

            // update the min use of coin num
            minUseCoinNum = (minUseCoinNum == INVALID_COIN_NUM) ? (minUseWithSelectedCoin) : min(minUseCoinNum, minUseWithSelectedCoin);
        }

        // return the result
        // (if there's no valid coin change of the amount -> the value would be INVALID)
        return minUseCoinNum;
    }
public:
    int coinChange(vector<int>& coins, int amount) {
        // if there's no coins
        if(coins.empty()) return -1;

        // find the minimum num of coin use
        return findMinUseCoinChange(coins, amount);
    }
};
```

## V2：DFS + TopDown DP
```Cpp
#define INVALID_COIN_NUM (-1)
class Solution {
private:
    bool findMinUseCoinChange(vector<int>& sortedCoins, int amount, int &useCoinNum, vector<int>& minCoinNumOfEachAmount) {

        // if the amout is zero -> change finish
        if(amount == 0) return true;

        // if the amount is not legal
        if(amount < 0) return false;

        // if the amount on the map had been set to invalid
        if(minCoinNumOfEachAmount[amount] == INVALID_COIN_NUM) return false;

        // if the amount of the map had been calculated
        if(minCoinNumOfEachAmount[amount] > 0) {
            useCoinNum = minCoinNumOfEachAmount[amount];
            return true;
        }

        // try each coin size
        int minUseCoinNum = INVALID_COIN_NUM;
        for(int i = 0; i < sortedCoins.size(); i++) {

            // reset the used coin num
            int usedRemainCoinNum = useCoinNum;

            // try to use the selected coin
            if(!findMinUseCoinChange(sortedCoins, (amount - sortedCoins[i]), usedRemainCoinNum, minCoinNumOfEachAmount)) continue;

            // if the selected coin can finally fit the condition
            usedRemainCoinNum++;

            // update the min use of coin num
            minUseCoinNum = (minUseCoinNum == INVALID_COIN_NUM) ? usedRemainCoinNum : min(minUseCoinNum, usedRemainCoinNum);
        }

        // export the min use of coint num
        useCoinNum = minUseCoinNum;

        // record the min coin change of this amount (if there's no valid coin change of the amount -> the value would be INVALID)
        minCoinNumOfEachAmount[amount] = minUseCoinNum;

        // coin change finish
        return (minUseCoinNum != INVALID_COIN_NUM);
    }
public:
    int coinChange(vector<int>& coins, int amount) {
        // if there's no coins
        if(coins.empty()) return -1;
        //sort(coins.begin(), coins.end(), greater<int>());

        // initialize an vector to record all the calculated min-use of coin -> init as 0 means "not calculated state"
        vector<int> minCoinNumOfEachAmount(amount+1, 0);

        // find the minimum num of coin use
        int minUseCoinNum = 0;
        if(!findMinUseCoinChange(coins, amount, minUseCoinNum, minCoinNumOfEachAmount)) return -1;
        return minUseCoinNum;
    }
};
``` 

# Answer：BFS + DP
## BFS + TopDown DP
```Cpp
#define INVALID_COIN_NUM (-1)
#define INVALID_AMOUNT (-1)
class Solution {

public:
    int coinChange(vector<int>& coins, int amount) {
        // if there's no coins
        if(coins.empty()) return INVALID_COIN_NUM;

        // must sort the coins at first
        // this is to to check from the larget amount of coint to smaller amount
        sort(coins.rbegin(), coins.rend());

        // record the "coin number to reach the amount with value as index"
        // ex: index = 0 -> need 0 amount of coint to reach here
        vector<int> minNeedCoinToAmount(amount + 1, INVALID_COIN_NUM);

        // initialize the index "to amount 0 (idx 0) requires no coins"
        minNeedCoinToAmount[0] = 0;

        // add the target amount of the pending amount to be checked to reach the target
        deque<int> pendingCheckAmount;
        pendingCheckAmount.push_back(0);

        // check each the pending amount until there's no remained
        while(!pendingCheckAmount.empty()) {

            // pop one pending amount from the pending
            // the popped one should be the max pending amount
            int curAmount = pendingCheckAmount.front();
            pendingCheckAmount.pop_front();

            // update the index of the amount which is one coin distance after the current amount
            for(auto oneCoinAmount : coins) {

                // check whether the one coin distance amount is valid (should not less than zero)
                // !!! need to do overflow protection
                int oneCoinAfterAmount = (curAmount <= INT_MAX - oneCoinAmount) ? (curAmount + oneCoinAmount) : (INVALID_AMOUNT);
                if(oneCoinAfterAmount > amount || oneCoinAfterAmount == INVALID_AMOUNT) continue;

                // update the amount
                if(minNeedCoinToAmount[ oneCoinAfterAmount ] != INVALID_COIN_NUM) continue;
                minNeedCoinToAmount[ oneCoinAfterAmount ] = 1 + minNeedCoinToAmount[ curAmount ];

                // check next term
                pendingCheckAmount.push_back( oneCoinAfterAmount );
            }
        }

        return minNeedCoinToAmount[ amount ];
    }
};
```
## BFS + BottomUp DP
```Cpp
#define INVALID_COIN_NUM (-1)
class Solution {

public:
    int coinChange(vector<int>& coins, int amount) {
        // if there's no coins
        if(coins.empty()) return INVALID_COIN_NUM;

        // must sort the coins at first
        // this is to to check from the larget amount distance (start with smaller coin) to smaller amount (with larger coin size)
        sort(coins.begin(), coins.end());

        // record the "minimal additional" coin num "from current amount (= index)"
        // -1: can't accumulate to the target amount from current amount
        // the solution will be at index 0 -> which means the min coin num from 0 to target num
        vector<int> minNeedCoinNumFromAmount(amount + 1, INVALID_COIN_NUM);

        // initialize the index "from target amount to target amount requires 0 additional coins"
        minNeedCoinNumFromAmount[amount] = 0;

        // add the target amount of the pending amount to be checked to reach the target
        deque<int> pendingCheckAmount;
        pendingCheckAmount.push_back(amount);

        // check each the pending amount until there's no remained
        while(!pendingCheckAmount.empty()) {

            // pop one pending amount from the pending
            // the popped one should be the max pending amount
            int curAmount = pendingCheckAmount.front();
            pendingCheckAmount.pop_front();

            // update the index of the amount which is one coin distance to the current amount
            for(auto oneCoinAmount : coins) {

                // check whether the one coin distance amount is valid (should not less than zero)
                int oneCoinDistAmount = curAmount - oneCoinAmount;
                if(oneCoinDistAmount < 0) continue;

                // update the amount
                if(minNeedCoinNumFromAmount[ oneCoinDistAmount ] != INVALID_COIN_NUM) continue;
                minNeedCoinNumFromAmount[ oneCoinDistAmount ] = 1 + minNeedCoinNumFromAmount[ curAmount ];
                pendingCheckAmount.push_back( oneCoinDistAmount );
            }
        }

        return minNeedCoinNumFromAmount[0];
    }
};
```

# Answer：Forward Iteration + DP
## V1：寫比較繁瑣
```Cpp
#define INVALID_COIN_NUM (-1)
class Solution {

public:
    int coinChange(vector<int>& coins, int amount) {
        // if there's no coins
        if(coins.empty()) return INVALID_COIN_NUM;

        // record the "coin number to reach the amount with value as index"
        // ex: index = 0 -> need 0 amount of coint to reach here
        vector<int> minNeedCoinToAmount(amount + 1, INVALID_COIN_NUM);

        // initialize the index "to amount 0 (idx 0) requires no coins"
        minNeedCoinToAmount[0] = 0;

        // check each amount from "each coin size of previous amount"
        for(int curAmount = 1; curAmount <= amount; curAmount++) {

            // check each coin size
            for(auto oneCoinSize : coins) {

                // check the amount "one coin less than the current" is valid
                int prevOneCoinAmount = curAmount - oneCoinSize;
                if(prevOneCoinAmount < 0 || minNeedCoinToAmount[ prevOneCoinAmount ] == INVALID_COIN_NUM) continue;


                // update the coin to reach current amount with the minimal one
                if(minNeedCoinToAmount[ curAmount ] == INVALID_COIN_NUM) {
                    minNeedCoinToAmount[ curAmount ] = minNeedCoinToAmount[ prevOneCoinAmount ] + 1;
                }
                else {
                    minNeedCoinToAmount[ curAmount ] = min( minNeedCoinToAmount[ curAmount ], 
                                                            minNeedCoinToAmount[ prevOneCoinAmount ] + 1 );
                }
            }
        }

        return minNeedCoinToAmount[ amount ];
    }
};
```

## V2：寫比較簡潔（複習時候重新想到的 + 速度是這幾個解法最快的）
```Cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // sort coin size
        sort(coins.begin(), coins.end());

        // DP memo for each amount
        vector<int> minCoinForAmount(amount+1, -1);

        // initial condition: 0 amount needs 0 coins
        minCoinForAmount[0] = 0;

        // check from 0 amount of coin to target amount
        for(int i = 0; i <= amount; i++) {

            // if current amount can't be satisfied
            if(minCoinForAmount[i] == -1) continue;

            // expand coin num from the current amount
            for(int j = 0; j < coins.size(); j++) {

                // check next amount (nextAmount = (coin[j] + i) -> check whether exceed target amount
                // use "minus" to prevent overflow
                if(coins[j] > (amount - i) ) break;
                int nextAmount = i + coins[j];

                // next amount coin need
                if(minCoinForAmount[nextAmount] == -1) minCoinForAmount[nextAmount] = minCoinForAmount[i] + 1;
                else minCoinForAmount[nextAmount] = min(minCoinForAmount[nextAmount], minCoinForAmount[i] + 1);
            }
        }

        // return leas coint for target amount
        return minCoinForAmount.back();
    }
};
```

# Answer：複習2nd - 模板化寫法
**注意題目的邊界條件，避免 overflow**
```Cpp
#define INVALID_AMOUNT (-1)
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
	    sort(coins.begin(), coins.end());

        vector<int> minCoinNumToAmount(amount+1, INVALID_AMOUNT);
        minCoinNumToAmount[0] = 0;

		for(int num = 0; num < amount; num++) {
			if(minCoinNumToAmount[num] == INVALID_AMOUNT) continue;
	
			for(int coin : coins) {
				if(num > (INT_MAX - coin)) break;
	
				int nextNum = num + coin;
				if(nextNum > amount) break;

				if(minCoinNumToAmount[nextNum] == INVALID_AMOUNT) minCoinNumToAmount[nextNum] = minCoinNumToAmount[num] + 1;
				else minCoinNumToAmount[nextNum] = min(minCoinNumToAmount[nextNum], minCoinNumToAmount[num] + 1);
			}
		}

		return minCoinNumToAmount[amount];
    }
};
```