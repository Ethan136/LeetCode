---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[139. Word Break](https://leetcode.com/problems/word-break/)

# Concept
- **從 index 0 開始檢查，看 Dict 裡面每個 word 是否能從 index 往後延伸，可以的話則 index + word.size() 所在的 index 視為「這個 index 的前面」可以被切分**
- **最後檢查  s.size() 所在的 index （string last index 下一格）是以左的部分是否可以切分**

# Answer：複習1st
```Cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> idxBeforeCanBeSegment(s.size()+1, false);
        idxBeforeCanBeSegment[0] = true;

        for(int i = 0; i < s.size(); i++) {
            if(idxBeforeCanBeSegment[i] == false) continue;

            for(auto &word : wordDict) {
                if((i+word.size()) >= idxBeforeCanBeSegment.size()) continue;
                if(s.substr(i, word.size()) != word) continue;
                idxBeforeCanBeSegment[i+word.size()] = true;
            }
        }

        return idxBeforeCanBeSegment.back();
    }
};
``` 

# Answer：複習2nd - 模板寫法
```Cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> canTravToIdxByWord(s.size()+1, false);
        canTravToIdxByWord[0] = true;

        for(int i = 0; i < s.size(); i++) {
            if(canTravToIdxByWord[i] == false) continue;

            for(auto &word : wordDict) {
                if((i+word.size()) > s.size()) continue;
                if(s.substr(i, word.size()) != word) continue;
                canTravToIdxByWord[i+word.size()] = true;
            }
        }

        return canTravToIdxByWord.back();
    }
};
```