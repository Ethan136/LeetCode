---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

# Answer：Brute Force 檢查每個 index 視為 palindrome start idx + 檢查順序優化 (N^3)
```Cpp
class Solution {
private:
    bool checkPalinDrome(string &s, int startIdx, int endIdx) {
        if(startIdx > endIdx) return false;

        for(int l = startIdx, r = endIdx; l < r; l++, r--) {
            if(s[l] != s[r]) return false;
        }
        return true;
    }

    int longestPalindromeLen(string &s, int startIdx) {

        for(int i = (int)(s.size()) - 1; i > startIdx; i--) {

            if(!checkPalinDrome(s, startIdx, i)) continue;
            return (i - startIdx + 1);
        }
        return 1;
    }
public:
    string longestPalindrome(string s) {

        int palinMaxStartIdx, palinMaxLen = 0;
        for(int i = (int)(s.size())-1; i >= 0; i--) {
            int palinDromeLen = longestPalindromeLen(s, i);
            if(palinDromeLen <= palinMaxLen) continue;

            palinMaxLen = palinDromeLen;
            palinMaxStartIdx = i;
        }
        return s.substr(palinMaxStartIdx, palinMaxLen);
    }
};
``` 

# Answer：檢查每個 index 視為 palindrome start idx + DP (N^2)
**速度比Brute force 慢，因為初始化 DP 的空間花太多時間**
```Cpp
class Solution {
private:
    bool checkPalinDrome(string &s, int startIdx, int endIdx, auto &isPalinDrome) {
        if(startIdx > endIdx) return false;

        for(int l = startIdx, r = endIdx; l < r; l++, r--) {
            if(isPalinDrome[l][r] != -1) {
                isPalinDrome[startIdx][endIdx] = isPalinDrome[l][r];
                return isPalinDrome[startIdx][endIdx];
            }
            if(s[l] != s[r]) {
                isPalinDrome[startIdx][endIdx] = 0;
                return false;
            }
        }

        isPalinDrome[startIdx][endIdx] = 1;
        return true;
    }

    int longestPalindromeLen(string &s, int startIdx, auto &isPalinDrome) {

        for(int i = (int)(s.size()) - 1; i > startIdx; i--) {

            if(!checkPalinDrome(s, startIdx, i, isPalinDrome)) continue;
            return (i - startIdx + 1);
        }
        return 1;
    }
public:
    string longestPalindrome(string s) {

        vector<vector<int>> isPalinDrome(s.size(), vector<int>(s.size(), -1));

        int palinMaxStartIdx, palinMaxLen = 0;
        for(int i = (int)(s.size())-1; i >= 0; i--) {
            int palinDromeLen = longestPalindromeLen(s, i, isPalinDrome);
            if(palinDromeLen <= palinMaxLen) continue;

            palinMaxLen = palinDromeLen;
            palinMaxStartIdx = i;
        }
        return s.substr(palinMaxStartIdx, palinMaxLen);
    }
};
```


# Answer：檢查每個 index 視為 center point + two pointer expansion
## V1：第一次寫的
```Cpp
class Solution {
private:

    int findMaxPlaindromeFromCenterIdx(string& s, int leftCenterIdx, int rightCenterIdx, int &leftExpendIdx, int &rightExpandIdx) {

        // (0) check size of string & whether the center index is valid
        if(s.empty() || leftCenterIdx < 0 || rightCenterIdx >= s.size() || s[leftCenterIdx] != s[rightCenterIdx]) return 0;

        // (1) Even Len ABBA
        int evenLenExpandRightSide = 0;
        int checkEvenLenExpandOneSide = 1;
        while( (leftCenterIdx - checkEvenLenExpandOneSide) >= 0 && (rightCenterIdx + checkEvenLenExpandOneSide) < s.size() ) {
            
            // preview the expanded str from center index
            if( s[leftCenterIdx - checkEvenLenExpandOneSide] != s[rightCenterIdx + checkEvenLenExpandOneSide] ) break;
            
            // rexord the check pass extend length
            evenLenExpandRightSide = checkEvenLenExpandOneSide;
            
            // lengthen the check range
            checkEvenLenExpandOneSide++;
        }

        // (2) export result
        leftExpendIdx = leftCenterIdx - evenLenExpandRightSide;
        rightExpandIdx = rightCenterIdx + evenLenExpandRightSide;
        return (rightExpandIdx - leftExpendIdx + 1);
    }

    int findMaxABACenterFromIdx(string& s, int leftCenterIdx, int &leftExpendIdx, int &rightExpandIdx) {

        // (1) check odd length expansion
        int oddLenLeftIdx, oddLenRightIdx;
        int maxLenOddABA = findMaxPlaindromeFromCenterIdx(s, leftCenterIdx, leftCenterIdx, oddLenLeftIdx, oddLenRightIdx);

        // (1) check even length expansion
        int evenLenLeftIdx, evenLenRightIdx;
        int maxLenEvenABBA = findMaxPlaindromeFromCenterIdx(s, leftCenterIdx, (leftCenterIdx+1), evenLenLeftIdx, evenLenRightIdx);

        // (2) compare expansion to odd & even length
        if( maxLenOddABA >= maxLenEvenABBA) {
            leftExpendIdx = oddLenLeftIdx;
            rightExpandIdx = oddLenRightIdx;
            return maxLenOddABA;
        }
        else {
            leftExpendIdx = evenLenLeftIdx;
            rightExpandIdx = evenLenRightIdx;
            return maxLenEvenABBA;
        }
    }
    
public:
    string longestPalindrome(string s) {
        int maxABALen = 0;
        int maxABAStartIdx, maxABAEndIdx;
        
        for(int i = 0; i < s.size(); i++) {
            int leftIdx, rightIdx;
            int maxLenFromIdx = findMaxABACenterFromIdx(s, i, leftIdx, rightIdx);
            if( maxLenFromIdx < maxABALen ) continue;

            maxABALen = maxLenFromIdx;
            maxABAStartIdx = leftIdx;
            maxABAEndIdx = rightIdx;
        }
        
        return s.substr(maxABAStartIdx, maxABALen);
    }
};
```

## V2：複習時候寫的，比較簡單
- **如果要保留 check valid max condition：可以用一個 check_l  / check_r 做檢查，檢查pass一次則存到 l / r 一次**
```Cpp
class Solution {
private:

    int longestPalindromeFromCenter(string &s, int center, int &leftIdx) {

        // odd len
        int l1, r1, len1 = 0;
        for(int chk_l1 = center, chk_r1 = center; (chk_l1 >= 0) && (chk_r1 < s.size()); chk_l1--, chk_r1++) {
            if(s[chk_l1] != s[chk_r1]) break;
            l1 = chk_l1, r1 = chk_r1;
            len1 = (r1 - l1 + 1);
        }

        // even len
        int l2, r2, len2 = 0;
        for(int chk_l2 = center, chk_r2 = center+1; (chk_l2 >= 0) && (chk_r2 < s.size()); chk_l2--, chk_r2++) {
            if(s[chk_l2] != s[chk_r2]) break;
            l2 = chk_l2, r2 = chk_r2;
            len2 = (r2 - l2 + 1);
        }

        // fetch the longer one
        leftIdx = (len1 > len2) ? (l1) : (l2);
        return max(len1, len2);
    }
public:
    string longestPalindrome(string s) {

        int palinMaxStartIdx, palinMaxLen = 0;
        for(int i = 0; i < s.size(); i++) {
            int leftIdx;
            int palinDromeLen = longestPalindromeFromCenter(s, i, leftIdx);
            if(palinDromeLen <= palinMaxLen) continue;

            palinMaxLen = palinDromeLen;
            palinMaxStartIdx = leftIdx;
        }
        return s.substr(palinMaxStartIdx, palinMaxLen);
    }
};
```