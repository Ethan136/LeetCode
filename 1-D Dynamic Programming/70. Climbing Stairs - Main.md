---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

# Answer V1：DP + memo all step ways
```Cpp
class Solution {
public:
    int climbStairs(int n) {
        // if n <= 1
        if(n <= 1) return 1;
    
        // a vector to record the step methods to 0, 1 , 2...n
        vector<int> climbMethodToN(n+1, 0);
        
        // init the method num to stair 1 / stair 2
        climbMethodToN[1] = 1;
        climbMethodToN[2] = 2;
        
        // calculate the remained climd methods
        // to any stair N, the methods(N) = methods(N-1) + methods(N-2)
        // climb to N methods = [(climb to N-1) then climb 1] + [(climb to N-2) then climb 2]
        for(int stair = 3; stair <= n; stair++) {
            climbMethodToN[ stair ] = climbMethodToN[ stair-1 ] + climbMethodToN[ stair-2 ];
        }
        return climbMethodToN[n];
    }
};
``` 

# Answer V2：DP + space optz (only record necessary step ways)
```Cpp
class Solution {
public:
    int climbStairs(int n) {
        // if n is special
        if(n <= 2) return n;

        // 0: current step -> start from n = 2
        // 1: step[-1] (prev) -> start from n = 1
        // 2: step[-2] (prev prev) -> start from n = 0
        int prev_i_Ways[3] = {2, 1, 0};

        // check all ways from start point
        for(int i = 3; i <= n; i++) {
            // update prev ways for current calculation
            // (1) shift step[n-1] to step[n-2]
            prev_i_Ways[2] = prev_i_Ways[1];

            // (2) shift step[n] to step[n-1]
            prev_i_Ways[1] = prev_i_Ways[0];

            // current step ways = ways of step[-1] + ways of step[-2]
            prev_i_Ways[0] = prev_i_Ways[1] + prev_i_Ways[2];          
        }

        // finish
        return prev_i_Ways[0];
    }
};
```