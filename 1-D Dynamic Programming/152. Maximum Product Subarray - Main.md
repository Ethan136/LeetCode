---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

# Answer V1：Brute Force + DP - O(N^2)
```Cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {

        // to temporary store the nums multiply of the previous layer
        // layer N = right expand numbers to do multiply 
        // N = 0 -> only the number on the element
        vector<int> numsMultiply(nums.size(), 1);

        // check expand num from 0 (only origin element) to whole array (size - 1)
        int maxProductResult = INT_MIN;
        for(int rightExpNum = 0; rightExpNum < nums.size(); rightExpNum++) {

            // calculate expand multiply result from each index
            for(int i = 0; i < (nums.size() - rightExpNum); i++) {
                numsMultiply[i] *= nums[i + rightExpNum];
                maxProductResult = max(maxProductResult, numsMultiply[i]);
            }
        }

        // return the max product
        return maxProductResult;
    }
};
``` 

# Answer V2：Greedy + DP - O(N)
```Cpp
#define MAX3(V1, V2, V3) max(V1, max(V2, V3))
#define MIN3(V1, V2, V3) min(V1, min(V2, V3))

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int overallMaxProd = INT_MIN;

        int minProdToIdx = 1;
        int maxProdToIdx = 1;
        for(int i = 0; i < nums.size(); i++) {
            int prodToIdx1 = minProdToIdx * nums[i];
            int prodToIdx2 = maxProdToIdx * nums[i];
            int prodToIdx3 = nums[i];

            maxProdToIdx = MAX3(prodToIdx1, prodToIdx2, prodToIdx3);
            minProdToIdx = MIN3(prodToIdx1, prodToIdx2, prodToIdx3);

            nums[i] = maxProdToIdx;
            overallMaxProd = max(overallMaxProd, maxProdToIdx);
        }

        return overallMaxProd;
    }
};
```