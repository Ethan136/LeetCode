---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)

# Answer V1：DP + memo all costs
```Cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        if(cost.size() <= 1) return 0;
        vector<int> minCostToN(cost.size()+1, 0);
        for(int i = 2; i < minCostToN.size(); i++) {
            int minCostFromPrev1Step = minCostToN[i-1]+cost[i-1];
            int minCostFromPrev2Step = minCostToN[i-2]+cost[i-2];
            minCostToN[i] = min(minCostFromPrev1Step , minCostFromPrev2Step);
        }
        return minCostToN.back();
    }
};
``` 

# Answer V2：DP + space optz (only record necessary cost of prev two steps)
```Cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // special condition
        if(cost.size() <= 1) return 0;

        // index 0 -> cost 0 -> prev[2]
        // index 1 -> cost 0 -> prev[1]
        // index 2 -> min( cost[0], cost[1] ) -> current (prev[0])
        int prev_i_minCost[3] = {min(0 + cost[0], 0 + cost[1]), 0, 0};

        // calculate climb costs to top
        for(int i = 3; i <= cost.size(); i++) {
            // update previous min cost
            prev_i_minCost[2] = prev_i_minCost[1];
            prev_i_minCost[1] = prev_i_minCost[0];

            // calculate cost of current step
            prev_i_minCost[0] = min(cost[i-1] + prev_i_minCost[1], cost[i-2] + prev_i_minCost[2]);
        }

        // finish
        return prev_i_minCost[0];
    }
};
```

# Answer V3：複習2nd - 模板
```Cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {

        // min cost to idx n (next to last of cost))
        vector<int> minCostToIdx(cost.size() + 1, INT_MAX);

        // starting points
        minCostToIdx[0] = 0;
        minCostToIdx[1] = 0;

        // check min cost to reach last idx (from idx -1 to end)
        for(int i = 0; i < cost.size(); i++) {

            for(int step = 1; step <= 2; step++) {
                int reachIdx = i + step;
                if(reachIdx >= minCostToIdx.size()) break;

                minCostToIdx[reachIdx] = min(minCostToIdx[i] + cost[i], minCostToIdx[reachIdx]);
            }
        }

        // finish
        return minCostToIdx.back();
    }
};
```
 