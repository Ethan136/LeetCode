---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

# Concept
- **DP：取得先前數字可以從小到大的 selected num vector**
- **加速：binary search 取得當前的的 selected num vector 要更新哪一個位置**

# Answer V1 - 一開始寫的
## DP + Linear Search
```Cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // index = N Increasing nums
        // value = least tail num of all the checked "N icreasing num" series
        vector<int> leastTailNumOfIncSeries;
        
        // init cond "any num would be larger than 0 increasibg num
        leastTailNumOfIncSeries.push_back( INT_MIN );
        
        // check through the nuns
        for(int num :  nums) {
        
            // if the current num can extend the increasibg series
            if( num > leastTailNumOfIncSeries.back() ) {
                leastTailNumOfIncSeries.push_back( num );
                continue;
            }
            
            // otherwise: update the least.num of inc tail
            // note that there's no need to check incNum = 0
            for( int incNum = 1; incNum < leastTailNumOfIncSeries.size(); incNum++) {
                if( num <= leastTailNumOfIncSeries[ incNum - 1 ] || num >= leastTailNumOfIncSeries[ incNum ] ) continue;
                
                // the first larger tail num is the insert index
                leastTailNumOfIncSeries[ incNum ] = num;
                break;
            }
        }
        
        // return the max increase num, which is the last index of leastTailNumOfIncSeries
        return leastTailNumOfIncSeries.size() - 1;
    }
};
``` 

## DP + Binary Search
```Cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // index = N Increasing nums
        // value = least tail num of all the checked "N icreasing num" series
        vector<int> leastTailNumOfIncSeries;
        
        // init cond "any num would be larger than 0 increasibg num
        leastTailNumOfIncSeries.push_back( INT_MIN );
        
        // check through the nuns
        for(int num :  nums) {
        
            // if the current num can extend the increasibg series
            if( num > leastTailNumOfIncSeries.back() ) {
                leastTailNumOfIncSeries.push_back( num );
                continue;
            }
            
            // otherwise: update the least.num of inc tail
            // note that there's no need to check incNum = 0
            int incNumL, incNumR, incNumMid;
            for( incNumL = 1, incNumR = leastTailNumOfIncSeries.size()-1, incNumMid = (incNumL+incNumR)*0.5;
                incNumL < incNumR - 1;
                incNumMid = (incNumL+incNumR)*0.5) {
                
                if(leastTailNumOfIncSeries[incNumMid] < num) incNumL = incNumMid;
                else incNumR = incNumMid;
            }
            
            // check binarys earch result
            if(num <= leastTailNumOfIncSeries[ incNumL ]) leastTailNumOfIncSeries[ incNumL ] = num;
            else leastTailNumOfIncSeries[ incNumR ] = num;
        }
        
        // return the max increase num, which is the last index of leastTailNumOfIncSeries
        return leastTailNumOfIncSeries.size() - 1;
    }
};
```

# Answer V2 - 複習時候寫的（比較簡潔）
## DP + Linear Search - 其實 DP 幾乎無效，直接計算結果差不多
```Cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> MaxLISToIdx(nums.size(), 1);

        int MaxLISOverall = 1;
        for(int i = 1; i < nums.size(); i++) {

            for(int j = i-1; j >= 0; j--) {
                // less
                if(nums[j] > nums[i]) continue;

                // same value
                if(nums[j] == nums[i]) MaxLISToIdx[i] = max(MaxLISToIdx[i], MaxLISToIdx[j]);

                // larger
                else MaxLISToIdx[i] = max(MaxLISToIdx[i], MaxLISToIdx[j]+1);

            }

            // update max LIS overall
            MaxLISOverall = max(MaxLISOverall, MaxLISToIdx[i]);
        }

        return MaxLISOverall;
    }
};
```

## DP + Binary Search
 - **注意：這邊 binary search 是找到第一個 >= nums[i] 的 index**
 - **注意：這邊 head 包含，tail 不包含**
	 - binaary search
		 - if MaxLISNumVec[mid] < nums[i] 的時候， mid 一定不是 target index -> 更新 head = mid + 1
		 - else 的時候，mid 可能是 target index 也可能不是 -> 更新 tail = mid (可能會導致 tail 把 target index 剔除)
	 - 離開 binary search
		 - 先檢查 mid 是否符合條件 -> 因為是找「第一個大於 num[i] 的，所以 mid 先找」
		 - 再檢查 mid+1 是否符合條件 -> 由於 head + tail / 2 計算的 mid 一定是 head tail 相鄰的時候收斂到 head，所以這邊檢查 mid + 1
```Cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> MaxLISNumVec;
        MaxLISNumVec.reserve(nums.size());

        MaxLISNumVec.push_back(nums[0]);
        for(int i = 1; i < nums.size(); i++) {

            // new num is larger
            if(MaxLISNumVec.back() < nums[i]) {
                MaxLISNumVec.push_back(nums[i]);
            }

            // new num is less -> update the 1st num in LISVector (greater or eaual) to nums[i]
            if(MaxLISNumVec.back() > nums[i]) {
                int mid;
                for(int head = 0, tail = MaxLISNumVec.size(); head < tail; ) {
                    mid = (head + tail) / 2;

                    if(mid == head) break;
                    if(MaxLISNumVec[mid] == nums[i]) break;

                    if(MaxLISNumVec[mid] < nums[i]) head = mid+1;
                    else tail = mid;
                }

                if(MaxLISNumVec[mid] >= nums[i]) MaxLISNumVec[mid] = nums[i];
                else MaxLISNumVec[mid+1] = nums[i];
            }
        }

        return MaxLISNumVec.size();
    }
};
```