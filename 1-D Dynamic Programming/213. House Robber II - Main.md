---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[213. House Robber II](https://leetcode.com/problems/house-robber-ii/)

# Answer V1：DP + memo 記錄所有 rob 情況 + rob 情況分三種 initial cond 處理
```Cpp
class Solution {
private:
    int robInRange(vector<int>& nums, int startIdx, int endIdx) {
        if(startIdx < 0 || startIdx > endIdx || endIdx >= nums.size()) return 0;
        if((startIdx == nums.size() - 1) || (startIdx == endIdx)) return nums[startIdx];
        if((startIdx == nums.size() - 2) || (startIdx == endIdx-1)) return max(nums[startIdx], nums[startIdx+1]);
        
        
        vector<int> maxInconeOnIdx(nums.size(), 0);
        maxInconeOnIdx[startIdx + 0] = nums[startIdx + 0];
        maxInconeOnIdx[startIdx + 1] = nums[startIdx + 1];
        maxInconeOnIdx[startIdx + 2] = nums[startIdx + 2] + nums[startIdx + 0];
        
        for(int i = startIdx+3; i <= endIdx; i++) {
            maxInconeOnIdx[i] = nums[i] + max( maxInconeOnIdx[i - 2] , maxInconeOnIdx[i - 3] );
        }
        
        return max( maxInconeOnIdx[endIdx] , maxInconeOnIdx[endIdx-1] );
    }
public:
    int rob(vector<int>& nums) {
        // if nums size is very limited
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max( nums[0] , nums[1]);
        
        // max income start from idx 0, 1, 2
        vector<int> maxIncome(3);
        
        // calculate income from different start point
        int lastHouseIdx = nums.size() - 1;
        maxIncome[0] = robInRange(nums, 0, lastHouseIdx-1);
        maxIncome[1] = robInRange(nums, 1, lastHouseIdx);
        maxIncome[2] = robInRange(nums, 2, lastHouseIdx);
        
        // sort the income and return the max
        sort(maxIncome.begin() , maxIncome.end());
        return maxIncome.back();
    }
};
``` 

# Answer V2：DP + space optz + rob 情況分兩種處理
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // special cases
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        if(nums.size() == 3) return max(nums[0], max(nums[1], nums[2]));
        if(nums.size() == 4) return max(nums[0] + nums[2], nums[1] + nums[3]);

        // rob index 0 to last-1
        int maxRob0[4] = {nums[3] + max(nums[1], nums[0]), nums[2] + max(nums[0], 0), nums[1], nums[0]};
        for(int i = 4; i < nums.size()-1; i++) {
            for(int j = 3; j > 0; j--) maxRob0[j] = maxRob0[j-1];

            maxRob0[0] = nums[i] + max(maxRob0[2], maxRob0[3]);
        }

        // rob index 1 to last
        int maxRob1[4] = {nums[4] + max(nums[2], nums[1]), nums[3] + max(nums[1], 0), nums[2], nums[1]};
        for(int i = 5; i < nums.size(); i++) {
            for(int j = 3; j > 0; j--) maxRob1[j] = maxRob1[j-1];

            maxRob1[0] = nums[i] + max(maxRob1[2], maxRob1[3]);
        }

        // return max condition of rob[0 to last-1] / rob[1 to last]
        return max( max(maxRob0[0], maxRob0[1]), max(maxRob1[0], maxRob1[1]) );
    }
};
```