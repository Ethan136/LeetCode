---
ParentTask:
  - "[[1-d_dynamic_programming]]"
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[213. House Robber II](https://leetcode.com/problems/house-robber-ii/)

# Answer V1：DP + memo 記錄所有 rob 情況 + rob 情況分三種 initial cond 處理
```Cpp
class Solution {
private:
    int robInRange(vector<int>& nums, int startIdx, int endIdx) {
        if(startIdx < 0 || startIdx > endIdx || endIdx >= nums.size()) return 0;
        if((startIdx == nums.size() - 1) || (startIdx == endIdx)) return nums[startIdx];
        if((startIdx == nums.size() - 2) || (startIdx == endIdx-1)) return max(nums[startIdx], nums[startIdx+1]);
        
        
        vector<int> maxInconeOnIdx(nums.size(), 0);
        maxInconeOnIdx[startIdx + 0] = nums[startIdx + 0];
        maxInconeOnIdx[startIdx + 1] = nums[startIdx + 1];
        maxInconeOnIdx[startIdx + 2] = nums[startIdx + 2] + nums[startIdx + 0];
        
        for(int i = startIdx+3; i <= endIdx; i++) {
            maxInconeOnIdx[i] = nums[i] + max( maxInconeOnIdx[i - 2] , maxInconeOnIdx[i - 3] );
        }
        
        return max( maxInconeOnIdx[endIdx] , maxInconeOnIdx[endIdx-1] );
    }
public:
    int rob(vector<int>& nums) {
        // if nums size is very limited
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max( nums[0] , nums[1]);
        
        // max income start from idx 0, 1, 2
        vector<int> maxIncome(3);
        
        // calculate income from different start point
        int lastHouseIdx = nums.size() - 1;
        maxIncome[0] = robInRange(nums, 0, lastHouseIdx-1);
        maxIncome[1] = robInRange(nums, 1, lastHouseIdx);
        maxIncome[2] = robInRange(nums, 2, lastHouseIdx);
        
        // sort the income and return the max
        sort(maxIncome.begin() , maxIncome.end());
        return maxIncome.back();
    }
};
``` 

# Answer V2：DP + space optz + rob 情況分兩種處理
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // special cases
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        if(nums.size() == 3) return max(nums[0], max(nums[1], nums[2]));
        if(nums.size() == 4) return max(nums[0] + nums[2], nums[1] + nums[3]);

        // rob index 0 to last-1
        int maxRob0[4] = {nums[3] + max(nums[1], nums[0]), nums[2] + max(nums[0], 0), nums[1], nums[0]};
        for(int i = 4; i < nums.size()-1; i++) {
            for(int j = 3; j > 0; j--) maxRob0[j] = maxRob0[j-1];

            maxRob0[0] = nums[i] + max(maxRob0[2], maxRob0[3]);
        }

        // rob index 1 to last
        int maxRob1[4] = {nums[4] + max(nums[2], nums[1]), nums[3] + max(nums[1], 0), nums[2], nums[1]};
        for(int i = 5; i < nums.size(); i++) {
            for(int j = 3; j > 0; j--) maxRob1[j] = maxRob1[j-1];

            maxRob1[0] = nums[i] + max(maxRob1[2], maxRob1[3]);
        }

        // return max condition of rob[0 to last-1] / rob[1 to last]
        return max( max(maxRob0[0], maxRob0[1]), max(maxRob1[0], maxRob1[1]) );
    }
};
```

# Answer V3：模板化寫法
## Forward Induction: idx0 / idx1 各 try 一次
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // if nums.size is not greater than 2
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);

        // init DP states
        vector<int> maxProfitRobOnIdx(nums.size(), 0);
        vector<int> maxProfitNotRobOnIdx(nums.size(), 0);

        // rub start from index 0
        maxProfitRobOnIdx[0] = nums[0];

        // from idx 1 to end-1
        int endIdx = nums.size()-2;
        for(int i = 1; i <= endIdx; i++) {
            maxProfitRobOnIdx[i] = nums[i] + maxProfitNotRobOnIdx[i-1];

            maxProfitNotRobOnIdx[i] = max(maxProfitNotRobOnIdx[i-1], maxProfitRobOnIdx[i-1]);
        }

        // max profit
        int maxProfitStartIdx0 = max(maxProfitRobOnIdx[endIdx], maxProfitNotRobOnIdx[endIdx]);

        // reset states
        for(int i = 0; i < nums.size(); i++) {
            maxProfitRobOnIdx[i] = 0;
            maxProfitNotRobOnIdx[i] = 0;
        }

        // rub start from index 1
        maxProfitRobOnIdx[1] = nums[1];

        // from idx 2 to end
        endIdx = nums.size() - 1;
        for(int i = 2; i <= endIdx; i++) {
            maxProfitRobOnIdx[i] = nums[i] + maxProfitNotRobOnIdx[i-1];

            maxProfitNotRobOnIdx[i] = max(maxProfitNotRobOnIdx[i-1], maxProfitRobOnIdx[i-1]);
        }

        // max profit
        int maxProfitStartIdx1 = max(maxProfitRobOnIdx[endIdx], maxProfitNotRobOnIdx[endIdx]);

        // finish
        return max(maxProfitStartIdx0, maxProfitStartIdx1);
    }
};
```

## Backward Induction: idx [end-1 , 0] / idx [end, 1] 各 try 一次
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // if nums.size is not greater than 2
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);

        // init DP states
        vector<int> maxProfitCanRubOnIdx(nums.size()+2, 0);
        vector<int> maxProfitCantRubOnIdx(nums.size()+2, 0);

        // from idx end-1 to 0
        int lastIdx = nums.size()-2;
        int firstIdx = 0;
        for(int i = lastIdx; i >= firstIdx; i--) {
            maxProfitCanRubOnIdx[i] = max(maxProfitCanRubOnIdx[i+1], nums[i] + maxProfitCantRubOnIdx[i+1]);

            maxProfitCantRubOnIdx[i] = maxProfitCanRubOnIdx[i+1];
        }

        // max profit
        int maxProfitStartIdx0 = maxProfitCanRubOnIdx[firstIdx];

        // reset states
        for(int i = 0; i < nums.size(); i++) {
            maxProfitCanRubOnIdx[i] = 0;
            maxProfitCantRubOnIdx[i] = 0;
        }

        // from idx end to 1
        lastIdx = nums.size()-1;
        firstIdx = 1;
        for(int i = lastIdx; i >= firstIdx; i--) {
            maxProfitCanRubOnIdx[i] = max(maxProfitCanRubOnIdx[i+1], nums[i] + maxProfitCantRubOnIdx[i+1]);

            maxProfitCantRubOnIdx[i] = maxProfitCanRubOnIdx[i+1];
        }

        // max profit
        int maxProfitStartIdx1 = maxProfitCanRubOnIdx[firstIdx];

        // finish
        return max(maxProfitStartIdx0, maxProfitStartIdx1);
    }
};
```