---
ParentTask:
  - "[[1-d_dynamic_programming]]"
---

# LeetCode
[198. House Robber](https://leetcode.com/problems/house-robber/)

# Answer：DP + record all index max rob
## Additional Vector for memo
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()<=1) return nums[0];
        if(nums.size()<=2) return max(nums[0], nums[1]);
        
        vector<int> maxIncomeOnIdx(nums.size(), 0);

        maxIncomeOnIdx[0] = nums[0];
        maxIncomeOnIdx[1] = nums[1];
        maxIncomeOnIdx[2] = maxIncomeOnIdx[0] + nums[2];
        
        for(int i = 3; i < maxIncomeOnIdx.size(); i++) {
            maxIncomeOnIdx[i] = nums[i] + max( maxIncomeOnIdx[i-3], maxIncomeOnIdx[i-2] );
        }

        int lastIdx = maxIncomeOnIdx.size() - 1;
        return max( maxIncomeOnIdx[lastIdx], maxIncomeOnIdx[lastIdx-1]);
    }
};
``` 

## Modify Input for memo
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()<=1) return nums[0];
        if(nums.size()<=2) return max(nums[0], nums[1]);

        nums[2] = nums[0] + nums[2];
        
        for(int i = 3; i < nums.size(); i++) {
            nums[i] += max( nums[i-3], nums[i-2] );
        }

        int lastIdx = nums.size() - 1;
        return max( nums[lastIdx], nums[lastIdx-1]);
    }
};
```

# Answer：DP + Space Optz (only record necessary max rob)
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // for special nums size
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        if(nums.size() == 3) return max(nums[2] + nums[0], nums[1]);

        // maxRob[0] = index 3
        // maxRob[1] = index 2
        // maxRob[2] = index 1
        // maxRob[3] = index 0
        int maxRob0 = nums[0];
        int maxRob1 = nums[1];
        int maxRob[4] = {nums[3] + max(maxRob1, maxRob0), nums[2] + max(maxRob0, 0), maxRob1, maxRob0};

        // calculate max rob from index = 4
        for(int i = 4; i < nums.size(); i++) {
            // shift right maxRob[] before calculate current index
            // (current becomes prev_1 / prev_1 becomes prev_2)
            for(int j = 3; j > 0; j--) maxRob[j] = maxRob[j-1];

            // calculate current max rob
            maxRob[0] = nums[i] + max(maxRob[2], maxRob[3]);
        }

        // finish: return the max of rob last house OR rob last-1 house
        return max( maxRob[0], maxRob[1] );
    }
};
```