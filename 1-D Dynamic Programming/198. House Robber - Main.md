---
ParentTask:
  - "[[1-d_dynamic_programming]]"
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[198. House Robber](https://leetcode.com/problems/house-robber/)

# Answer：DP + record all index max rob
## Additional Vector for memo
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()<=1) return nums[0];
        if(nums.size()<=2) return max(nums[0], nums[1]);
        
        vector<int> maxIncomeOnIdx(nums.size(), 0);

        maxIncomeOnIdx[0] = nums[0];
        maxIncomeOnIdx[1] = nums[1];
        maxIncomeOnIdx[2] = maxIncomeOnIdx[0] + nums[2];
        
        for(int i = 3; i < maxIncomeOnIdx.size(); i++) {
            maxIncomeOnIdx[i] = nums[i] + max( maxIncomeOnIdx[i-3], maxIncomeOnIdx[i-2] );
        }

        int lastIdx = maxIncomeOnIdx.size() - 1;
        return max( maxIncomeOnIdx[lastIdx], maxIncomeOnIdx[lastIdx-1]);
    }
};
``` 

## Modify Input for memo
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()<=1) return nums[0];
        if(nums.size()<=2) return max(nums[0], nums[1]);

        nums[2] = nums[0] + nums[2];
        
        for(int i = 3; i < nums.size(); i++) {
            nums[i] += max( nums[i-3], nums[i-2] );
        }

        int lastIdx = nums.size() - 1;
        return max( nums[lastIdx], nums[lastIdx-1]);
    }
};
```

# Answer：DP + Space Optz (only record necessary max rob)
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // for special nums size
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        if(nums.size() == 3) return max(nums[2] + nums[0], nums[1]);

        // maxRob[0] = index 3
        // maxRob[1] = index 2
        // maxRob[2] = index 1
        // maxRob[3] = index 0
        int maxRob0 = nums[0];
        int maxRob1 = nums[1];
        int maxRob[4] = {nums[3] + max(maxRob1, maxRob0), nums[2] + max(maxRob0, 0), maxRob1, maxRob0};

        // calculate max rob from index = 4
        for(int i = 4; i < nums.size(); i++) {
            // shift right maxRob[] before calculate current index
            // (current becomes prev_1 / prev_1 becomes prev_2)
            for(int j = 3; j > 0; j--) maxRob[j] = maxRob[j-1];

            // calculate current max rob
            maxRob[0] = nums[i] + max(maxRob[2], maxRob[3]);
        }

        // finish: return the max of rob last house OR rob last-1 house
        return max( maxRob[0], maxRob[1] );
    }
};
```

# Answer：DP 模板
## Forward induction：action 設為 DP（action 要能反應所有 state）
```Cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);

        // forward induction
        vector<int> earnMaxIfRubIdx(nums.size(), 0);
        vector<int> earnMaxIfNotRubIdx(nums.size(), 0);

        // initial condition
        earnMaxIfRubIdx[0] = nums[0];
        earnMaxIfRubIdx[1] = nums[1];
        earnMaxIfNotRubIdx[1] = earnMaxIfRubIdx[0];

        // check along all points
        for(int i = 2; i < nums.size(); i++) {
            // if rub on index -> do rub
            earnMaxIfRubIdx[i] = nums[i] + earnMaxIfNotRubIdx[i-1];

            // if dont rub on index
            earnMaxIfNotRubIdx[i] = max(earnMaxIfNotRubIdx[i-1], earnMaxIfRubIdx[i-1]);
        }

        // finish
        return max(earnMaxIfRubIdx.back(), earnMaxIfNotRubIdx.back());
    }
};
```

## Backward Induction：state 設為 DP
參考 [[2-d_dynamic_programming]] 的模板
```Cpp
    class Solution {
    public:
        int rob(vector<int>& nums) {
            if(nums.size() == 1) return nums[0];
            if(nums.size() == 2) return max(nums[0], nums[1]);

            // forward induction
            vector<int> earnMaxIfCanRubIdx(nums.size()+2, 0);
            vector<int> earnMaxIfCantRubIdx(nums.size()+2, 0);

            // append nums
            int endIdx = nums.size()-1;
            nums.push_back(0);

            // check along all points
            for(int i = endIdx; i >= 0; i--) {
                // if can rub on index -> do rub / not rub on current
                earnMaxIfCanRubIdx[i] = max(nums[i] + earnMaxIfCantRubIdx[i+1], earnMaxIfCanRubIdx[i+1]);

                // if can't rub on index -> next idx can rub
                earnMaxIfCantRubIdx[i] = earnMaxIfCanRubIdx[i+1];
            }

            // finish
            return earnMaxIfCanRubIdx[0];
        }
    };
```