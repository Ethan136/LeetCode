---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

# Answer：第一次寫的
## V1：Recursive TopDown Brute Force
```Cpp
#define DEBUG_EN (0)
class Solution {
private:
#if DEBUG_EN
    int m_callDepth = 0;
#endif

    int longestCommonSubsequence(string &text1, string &text2, int text1StartIdx, int text2StartIdx) {
        // if any of the assigned index out of the range
        if(text1StartIdx >= text1.size() || text2StartIdx >= text2.size()) {
            return 0;
        }

        // if the char on the assigned indices are matched
        // -> check along the path until difference occurs
        int i = text1StartIdx, j = text2StartIdx, matchCntCurrent = 0;
        while(i < text1.size() && j < text2.size() && text1[ i ] == text2[ j ]) {
            // ONLY UPDATE THE INDEX IF THE TEXT ARE MATCHED
            i++; j++;

            // RECORD THE MATCH CNT
            matchCntCurrent++;
        }

        // debug check
#if DEBUG_EN
        cout << "call start: [longestCommonSubsequence] " << m_callDepth++ << endl;
        cout << "text1StartIdx: " << text1StartIdx << " | text2StartIdx: " << text2StartIdx << endl;
        cout << "matchCntCurrent: " << matchCntCurrent << endl;
#endif

        // check the match count after the difference occurs
        // -> check both text1 / text2 skip one index and select the larget one
        int matchCntAfter = max(
                                longestCommonSubsequence(text1, text2, i+1, j),
                                longestCommonSubsequence(text1, text2, i, j+1)
        );

        // update debug counter
#if DEBUG_EN
        cout << "Finish start: [longestCommonSubsequence] " << --m_callDepth << endl;
#endif

        return (matchCntCurrent + matchCntAfter);
    }
public:
    int longestCommonSubsequence(string text1, string text2) {
        return longestCommonSubsequence(text1, text2, 0, 0);
    }
};
```

## V2：Recursive TopDown + 2D DP
```Cpp
class Solution {
private:

    int longestCommonSubsequence(string &text1, string &text2, int text1StartIdx, int text2StartIdx, vector<vector<int>> &checkedCondRecord) {
        // if any of the assigned index out of the range
        if(text1StartIdx >= text1.size() || text2StartIdx >= text2.size()) {
            return 0;
        }

        // check if current setting had been checked before
        if(checkedCondRecord[text1StartIdx][text2StartIdx] != -1) {
            return checkedCondRecord[text1StartIdx][text2StartIdx];
        }

        // make it easier to read the following code
        int i = text1StartIdx, j = text2StartIdx;
        int matchCnt = 0;

        // if the char on the assigned indices are matched
        // -> check along the path until difference occurs
        if(text1[i] == text2[j]) {
            matchCnt = 1 + longestCommonSubsequence(text1, text2, i+1, j+1, checkedCondRecord);
        }

        // check the match count after the difference occurs
        // -> check both text1 / text2 skip one index and select the larget one
        else {
            matchCnt = max(
                        longestCommonSubsequence(text1, text2, i+1, j, checkedCondRecord),
                        longestCommonSubsequence(text1, text2, i, j+1, checkedCondRecord)
            );
        }

        // record check result in DP & return result
        checkedCondRecord[text1StartIdx][text2StartIdx] = matchCnt;
        return checkedCondRecord[text1StartIdx][text2StartIdx];
    }
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> checkedCondRecord( text1.size(), vector<int>(text2.size(), - 1) );
        return longestCommonSubsequence(text1, text2, 0, 0, checkedCondRecord);
    }
};
```

## V3：Iteraion BottomUp + 2D DP
```Cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        // expand text1 index & text2 index to a grid like board
        // grid(i, j) = max common sub sequence from text1[i] & text2[j]
        // set longer text in column direction (and use dp in row direction)
        // (1) text1: column direction
        // (2) text2: row direction
        if(text1.size() < text2.size()) swap(text1, text2);

        // set all grid[i, j] (expand additional grid of text1.size()+1 / text2.size()+1)
        vector<vector<int>> longestCommonSubSeqBoard(text1.size()+1, vector<int>(text2.size()+1, 0));

        // search from right bottom grid back to left top grid
        // (1) search from last row
        for(int i = (int)(text1.size()) - 1; i >= 0; i--) {

            // (2) search from rightest grid within the row
            for(int j = (int)(text2.size()) - 1; j >= 0; j--) {

                // (a) if text match -> accumulate match cnt from next index of both text1 / text2
                if(text1[i] == text2[j]) {
                    longestCommonSubSeqBoard[i][j] = 1 + longestCommonSubSeqBoard[i+1][j+1];
                }
                // (b) if not match -> pick the larger match cnt between "text1 shift one" v.s. "text2 shift one"
                else {
                    longestCommonSubSeqBoard[i][j] = max(longestCommonSubSeqBoard[i+1][j], longestCommonSubSeqBoard[i][j+1]);
                }
            }
        }

        // return the max match cnt from text1[0] & text2[0]
        return longestCommonSubSeqBoard[0][0];
    }
};
```

## V4：Iteration BottomUp + 1D DP x2
```Cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        // expand text1 index & text2 index to a grid like board
        // grid(i, j) = max common sub sequence from text1[i] & text2[j]
        // set longer text in column direction (and use dp in row direction)
        // (1) text1: column direction
        // (2) text2: row direction
        if(text1.size() < text2.size()) swap(text1, text2);

        // set all row[j] (expand additional grid of (text2.size()+1)
        vector<int> longestCommonSubSeqCurRow(text2.size()+1, 0);
        vector<int> longestCommonSubSeqNextRow(text2.size()+1, 0);

        // init the result
        int result = 0;

        // search from right bottom row back to left top row
        // (1) search from last row
        for(int i = (int)(text1.size()) - 1; i >= 0; i--) {

            // reset current row to all zero
            longestCommonSubSeqCurRow.clear();

            // (2) search from rightest grid within the row
            for(int j = (int)(text2.size()) - 1; j >= 0; j--) {

                // (a) if text match -> accumulate match cnt from next index of both text1 / text2
                if(text1[i] == text2[j]) {
                    longestCommonSubSeqCurRow[j] = 1 + longestCommonSubSeqNextRow[j+1];
                }
                // (b) if not match -> pick the larger match cnt between "text1 shift one" v.s. "text2 shift one"
                else {
                    longestCommonSubSeqCurRow[j] = max(longestCommonSubSeqNextRow[j], longestCommonSubSeqCurRow[j+1]);
                }
            }

            // the result is on the leftest grid of current row
            result = longestCommonSubSeqCurRow[0];

            // swap current row & next row
            swap(longestCommonSubSeqCurRow, longestCommonSubSeqNextRow);
        }

        // return the max match cnt from text1[0] & text2[0]
        return result;
    }
};
```

# Answer：複習時候寫的
## V3：Iteration BotomUp + 2D DP
```Cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {

        // DP memo: record the common str len from text1[i] & text2[j]
        vector<vector<int>> maxLenFromIdx(text1.size() + 1,
                                          vector<int>(text2.size() + 1, 0));

        // check longest common str len
        // from text1[last] & text2[last]
        // record compare result backwardly
        // later idx check result can be used for previous idx check
        int maxCommLen = 0;
        for (int i = text1.size() - 1; i >= 0; i--) {
            
            for (int j = text2.size() - 1; j >= 0; j--) {
                // if text1[i] = text2[j] -> extend result from text1[i+1] &
                // text2[j+1]
                if (text1[i] == text2[j]) maxLenFromIdx[i][j] = 1 + maxLenFromIdx[i + 1][j + 1];

                // else -> convey result from (text1[i+1] & text2[j]) OR (text1[i] & text2[j+1])
                else maxLenFromIdx[i][j] = max(maxLenFromIdx[i + 1][j], maxLenFromIdx[i][j + 1]);

                maxCommLen = max(maxCommLen, maxLenFromIdx[i][j]);

                // DBG CODE
                // cout << i << "|" << j << " | " << maxLenFromIdx[i][j] << endl;
            }
        }

        // finish
        return maxCommLen;
    }
};
```

## V4：Iteration BottomUp + 1D DP x2
```Cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {

        // use the shorter one as text2
        if(text1.size() < text2.size()) swap(text1, text2);

        // DP memo: record the common str len from text2[j] of current text1[i]
        vector<int> maxLenFromIdxOfTxt2(text2.size() + 1, 0);
        vector<int> maxLenFromIdxOfTxt2Prev(maxLenFromIdxOfTxt2);

        // check longest common str len
        // from text1[last] & text2[last]
        // record compare result backwardly
        // later idx check result can be used for previous idx check
        int maxCommLen = 0;
        for (int i = text1.size() - 1; i >= 0; i--) {
            // swap previous result & current result
            swap(maxLenFromIdxOfTxt2Prev, maxLenFromIdxOfTxt2);
            
            for (int j = text2.size() - 1; j >= 0; j--) {
                // if text1[i] = text2[j] -> extend result from text1[i+1] & text2[j+1]
                if (text1[i] == text2[j]) maxLenFromIdxOfTxt2[j] = 1 + maxLenFromIdxOfTxt2Prev[j+1];

                // else -> convey result from (text1[i+1] & text2[j]) OR (text1[i] & text2[j+1])
                else maxLenFromIdxOfTxt2[j] = max(maxLenFromIdxOfTxt2Prev[j], maxLenFromIdxOfTxt2[j + 1]);

                maxCommLen = max(maxCommLen, maxLenFromIdxOfTxt2[j]);

                // DBG CODE
                // cout << i << "|" << j << " | " << maxLenFromIdxOfTxt2[j] << endl;
            }
        }

        // finish
        return maxCommLen;
    }
};
```