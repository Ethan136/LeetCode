---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

# Answer：第一次寫的
## V1：DFS Tow Down + Brute Force
```Cpp 
#define CD_DAY_AFTER_SELL   (1)
#define DAY_CAN_BUY_AFTER_SELL  (CD_DAY_AFTER_SELL+1)
class Solution {
private:
    int maxProfitAfter(vector<int>& prices, int startIdx) {
        // if index out of range / is the last price day (can't sell after)
        if(startIdx >= ((int)(prices.size()) - 1)) {
            return 0;
        }

        // max profit check from the start index
        int maxProfit = 0;

        // check the max profit if buy on current day & sell later
        for(int sellIdx = startIdx + 1; sellIdx < prices.size(); sellIdx++) {
            // if there's no profit -> check next day
            if(prices[startIdx] > prices[sellIdx]) {
                continue;
            }

            // if there're some profit
            int curProfit = (prices[sellIdx] - prices[startIdx]);
            int laterProfit = maxProfitAfter(prices, sellIdx + DAY_CAN_BUY_AFTER_SELL);
            int profitTotal = curProfit + laterProfit;
            maxProfit = max( maxProfit, profitTotal );
        }

        // check the max profit if buy on next day & sell later
        maxProfit = max( maxProfit, maxProfitAfter(prices, startIdx+1));

        // return overall max profit
        return maxProfit;
    }
public:
    int maxProfit(vector<int>& prices) {
        return maxProfitAfter(prices, 0);
    }
};
```

## V2：DFS Top Down + 1D DP - maxProfitBuyOnIdx
```Cpp
#define CD_DAY_AFTER_SELL   (1)
#define DAY_CAN_BUY_AFTER_SELL  (CD_DAY_AFTER_SELL+1)
#define INVALID_PROFIT_VALUE    (-1)
class Solution {
private:
    int maxProfitAfter(vector<int>& prices, int startIdx, vector<int> &maxProfitBuyOnIdx) {
        // if index out of range / is the last price day (can't sell after)
        if(startIdx >= ((int)(prices.size()) - 1)) {
            return 0;
        }

        // if buying on the assigned index had been calculated before
        if(maxProfitBuyOnIdx[startIdx] != INVALID_PROFIT_VALUE) {
            return maxProfitBuyOnIdx[startIdx];
        }

        // max profit check from the start index (should be greater than zero)
        int maxProfit = 0;

        // check the max profit if buy on current day & sell later
        for(int sellIdx = startIdx + 1; sellIdx < prices.size(); sellIdx++) {
            // if there's no profit -> check next day
            if(prices[startIdx] > prices[sellIdx]) {
                continue;
            }

            // if there're some profit
            int curProfit = (prices[sellIdx] - prices[startIdx]);
            int laterProfit = maxProfitAfter(prices, sellIdx + DAY_CAN_BUY_AFTER_SELL, maxProfitBuyOnIdx);
            int profitTotal = curProfit + laterProfit;
            maxProfit = max( maxProfit, profitTotal );
        }

        // check the max profit if buy on next day & sell later
        maxProfit = max( maxProfit, maxProfitAfter(prices, startIdx+1, maxProfitBuyOnIdx));

        // record the profit
        maxProfitBuyOnIdx[startIdx] = maxProfit;

        // return overall max profit
        return maxProfit;
    }
public:
    int maxProfit(vector<int>& prices) {
        vector<int> maxProfitBuyOnIdx(prices.size(), INVALID_PROFIT_VALUE);
        return maxProfitAfter(prices, 0, maxProfitBuyOnIdx);
    }
};
```

## V3：DFS Top Down + 2D DP - maxProfitBuySellOnIdx (速度比 1D DP 慢)
```Cpp
#define CD_DAY_AFTER_SELL   (1)
#define DAY_CAN_BUY_AFTER_SELL  (CD_DAY_AFTER_SELL+1)
#define INVALID_PROFIT_VALUE    (-1)
class Solution {
private:
    int maxProfitAfter(vector<int>& prices, int buyIdx, int trySellIdx, vector<vector<int>> &maxProfitBuySellOnIdx) {
        // if index out of range / is the last price day (can't sell after)
        if(buyIdx >= ((int)(prices.size()) - 1)) {
            return 0;
        }

        // if sell index is out of range
        if(trySellIdx >= (int)(prices.size()) ) {
            return 0;
        }

        // if the supposed sell index is not valid after buying -> regulate the try-sell index
        if(trySellIdx <= buyIdx) {
            return maxProfitAfter(prices, buyIdx, buyIdx+1, maxProfitBuySellOnIdx);
        }

        // if buying on the assigned index had been calculated before
        if(maxProfitBuySellOnIdx[buyIdx][trySellIdx] != INVALID_PROFIT_VALUE) {
            return maxProfitBuySellOnIdx[buyIdx][trySellIdx];
        }

        // max profit check from the start index (should be greater than zero)
        int maxProfit = 0;

        // check the max profit if buy and sell on the assigned index
        int nextBuyIdx = trySellIdx + DAY_CAN_BUY_AFTER_SELL;
        maxProfit = max( maxProfit, ((prices[trySellIdx] - prices[buyIdx]) + maxProfitAfter(prices, nextBuyIdx, nextBuyIdx, maxProfitBuySellOnIdx)) );

        // check the max profit if buy on the assigned index & sell later
        maxProfit = max( maxProfit, maxProfitAfter(prices, buyIdx, trySellIdx+1, maxProfitBuySellOnIdx) );
        
        // check the max profit if buy on next day & sell later
        maxProfit = max( maxProfit, maxProfitAfter(prices, buyIdx+1, trySellIdx, maxProfitBuySellOnIdx) );

        // record the profit
        maxProfitBuySellOnIdx[buyIdx][trySellIdx] = maxProfit;

        // return overall max profit
        return maxProfit;
    }
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> maxProfitBuySellOnIdx(prices.size(), vector<int>(prices.size(), INVALID_PROFIT_VALUE));
        return maxProfitAfter(prices, 0, 0, maxProfitBuySellOnIdx);
    }
};
```

## V4：Iteration Bottom Up + 1D DP x 2
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        // check day num
        int totalDay = prices.size();
        if (totalDay <= 1) return 0;

        // calc last day idx
        int lasyDayIdx = totalDay - 1;

        // if pos not entry when bar open
        vector<int> maxProfitIfPosEmptyWhenBarOpen(totalDay+2, 0);

        // if pos already entry when bar open
        vector<int> maxProfitIfPosEntryWhenBarOpen(totalDay+2, 0);

        for (int i = lasyDayIdx; i >= 0; --i) {
            // Cond1: pos empty when bar open
            maxProfitIfPosEmptyWhenBarOpen[i] = max(
                maxProfitIfPosEmptyWhenBarOpen[i + 1],
                -prices[i] + maxProfitIfPosEntryWhenBarOpen[i + 1]
            );

            // Cond2: has pos when bar open
            maxProfitIfPosEntryWhenBarOpen[i] = max(
                maxProfitIfPosEntryWhenBarOpen[i + 1],
                prices[i] + maxProfitIfPosEmptyWhenBarOpen[i + 2]
            );
        }
        return maxProfitIfPosEmptyWhenBarOpen[0];
    }
};
```

# Answer：複習1st 時候寫的
## V4：Iteraion Bottom Up + 1D DP x 2
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        // state transition vector
        vector<int> maxIncomeAfterIfPosEmptyWhenOpen(prices.size()+2, 0);
        vector<int> maxIncomeAfterIfEntryWhenOpen(prices.size()+2, 0);

        // check in backward order
        for(int i = prices.size()-1; i >= 0; i--) {
            // cond1: pos empty when bar open
            maxIncomeAfterIfPosEmptyWhenOpen[i] = max(
                maxIncomeAfterIfPosEmptyWhenOpen[i+1], 
                -prices[i] + maxIncomeAfterIfEntryWhenOpen[i+1]
            );


            // cond2: pos already entry when bar open
            maxIncomeAfterIfEntryWhenOpen[i] = max(
                maxIncomeAfterIfEntryWhenOpen[i+1],
                prices[i] + maxIncomeAfterIfPosEmptyWhenOpen[i+2]
            );
        }

        // finish
        return maxIncomeAfterIfPosEmptyWhenOpen[0];
    }
};
```

## V5：Iteration Bottom Up + 1D DP x2 + Space Optz
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        // state transition vector: current(0) / nextDay(1) / nextnextDay(2)
        vector<int> maxIncomeAfterIfPosEmptyWhenOpen(3, 0);
        vector<int> maxIncomeAfterIfEntryWhenOpen(3, 0);

        // check in backward order
        for(int i = prices.size()-1; i >= 0; i--) {

            // shift current day to next day (next day to next next day)
            for(int i = 2; i > 0; i--) {
                maxIncomeAfterIfPosEmptyWhenOpen[i] = maxIncomeAfterIfPosEmptyWhenOpen[i-1];
                maxIncomeAfterIfEntryWhenOpen[i] = maxIncomeAfterIfEntryWhenOpen[i-1];
            }

            // cond1: pos empty when bar open
            maxIncomeAfterIfPosEmptyWhenOpen[0] = max(
                maxIncomeAfterIfPosEmptyWhenOpen[1], 
                -prices[i] + maxIncomeAfterIfEntryWhenOpen[1]
            );


            // cond2: pos already entry when bar open
            maxIncomeAfterIfEntryWhenOpen[0] = max(
                maxIncomeAfterIfEntryWhenOpen[1],
                prices[i] + maxIncomeAfterIfPosEmptyWhenOpen[2]
            );
        }

        // finish
        return maxIncomeAfterIfPosEmptyWhenOpen[0];
    }
};
```

# Answer：複習2nd - 模板化處理
## Backward Induction：使用 state 作為 DP
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 1) return 0;
        
        // [state transition matrix]
        // -> position size when bar open !!
        // maxProfitWithPosWhenBarOpen[i]
        // maxProfitWOPosWhenBarOpen[i] -> idx0 is result

        // [iteration]
        // maxProfitWithPosWhenBarOpen[i] = max of
        // (1) keep pos to next bar: maxProfitWithPosWhenBarOpen[i+1]
        // (2) sell on this bar, not enty until next2 bar: price[i] + maxProfitWOPosWhenBarOpen[i+2])
        // maxProfitWOPosWhenBarOpen[i] = 
        // (1) buy on this bar: -price[i] + maxProfitWithPosWhenBarOpen[i+1]
        // (2) keep empty on this bar: maxProfitWOPosWhenBarOpen[i+1]

        // DP transition matrix
        vector<int> maxProfitWithPosWhenBarOpen(prices.size()+2, 0); 
        vector<int> maxProfitWOPosWhenBarOpen(prices.size()+2, 0);

        // check from (last-1) bar back to first bar
        for(int i = prices.size() - 1; i >= 0; i--) {
            maxProfitWithPosWhenBarOpen[i] = 
                max(
                    maxProfitWithPosWhenBarOpen[i+1], 
                    prices[i] + maxProfitWOPosWhenBarOpen[i+2]
                );
    
            maxProfitWOPosWhenBarOpen[i] = 
                max(
                    -prices[i] + maxProfitWithPosWhenBarOpen[i+1], 
                    maxProfitWOPosWhenBarOpen[i+1]
                );
        }
        // finish -> return max prifit when start (without any position)
        return maxProfitWOPosWhenBarOpen[0];
    }
};
```

## Forwad Induction：使用 action 作為 DP（Action 要能反應所有 state）
```Cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 1) return 0;
        
        // DP transition matrix
        vector<int> maxProfitIfBuyOnIdx(prices.size(), 0);
        vector<int> maxProfitIfSellOnIdx(prices.size(), 0);
        vector<int> maxProfitIfHoldPosOnIdx(prices.size(), 0);
        vector<int> maxProfitIfIdleOnIdx(prices.size(), 0);

        // initial condition
        maxProfitIfBuyOnIdx[0] = -prices[0];
        maxProfitIfBuyOnIdx[1] = -prices[1];
        maxProfitIfSellOnIdx[1] = prices[1] + maxProfitIfBuyOnIdx[0];
        maxProfitIfHoldPosOnIdx[1] = maxProfitIfBuyOnIdx[0];

        // check from first bar to last bar
        for(int i = 2; i < prices.size(); i++) {
            maxProfitIfBuyOnIdx[i] = -prices[i] + max(maxProfitIfSellOnIdx[i-2], maxProfitIfIdleOnIdx[i-1]);

            maxProfitIfSellOnIdx[i] = prices[i] + max(maxProfitIfBuyOnIdx[i-1], maxProfitIfHoldPosOnIdx[i-1]);

            maxProfitIfHoldPosOnIdx[i] = max(maxProfitIfBuyOnIdx[i-1], maxProfitIfHoldPosOnIdx[i-1]);

            maxProfitIfIdleOnIdx[i] = max(maxProfitIfSellOnIdx[i-1], maxProfitIfIdleOnIdx[i-1]);
        }
        // finish -> return max prifit when start (without any position)
        return max(maxProfitIfIdleOnIdx.back(), maxProfitIfSellOnIdx.back());
    }
};
```