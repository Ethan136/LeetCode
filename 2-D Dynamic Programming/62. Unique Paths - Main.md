---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[62. Unique Paths](https://leetcode.com/problems/unique-paths/)

# Answer - Math (使用排列組合 - 組合 C(m+n) 取 (m 或 n) )
從總共 \(n+m\) 個步數中，選出 \(n\) 個位置給「右」走，剩下的 \(m\) 個位置自然就分配給「下」走。這就是從 \(n+m\) 步中選出 \(n\) 步來向右走的組合數
```Cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1) return 1;

        int downMove = (m-1);
        int rightMove = (n-1);

        int totalMove = downMove + rightMove;
        int selectMove = min(downMove, rightMove);

        unsigned long long result = 1;
        for(int i = 0; i < selectMove; i++) {
            unsigned long long Denominator = (totalMove - i);
            result *= Denominator;

            unsigned long long Numerator = (1 + i);
            result /= Numerator;
        }

        return result;
    }
};
```

# Answer - DP Bottom Up (第一次寫，說明詳細)
```Cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // path to the target of "a single row"
        vector<int> PathToTargetOfCurCheckRow(n);

        // check backward from the "last row" to the first row
        // (1) last row: each grid only have "1" path to the target (go right)
        for(auto &path : PathToTargetOfCurCheckRow) path = 1;

        // (2) check from "last row - 1" to first row
        int lastRowIdx = m - 1;
        for(int r = lastRowIdx - 1; r >= 0; r--) {

            // check from "rightest grid - 1" to the "leftest grid"
            int lastColIdx = int(PathToTargetOfCurCheckRow.size()) - 1;
            for(int c = lastColIdx - 1; c >= 0; c--) {
                // Path of this grid in this row = [Path of grid down on next row] + [Path of right grid]
                // (a) before update: Path of the grid on next row
                // (b) after update: Path of the grid on this row
                PathToTargetOfCurCheckRow[c] = PathToTargetOfCurCheckRow[c] + PathToTargetOfCurCheckRow[c+1];
            }
        }

        // (3) return the path methods from "leftest grid on top"
        return PathToTargetOfCurCheckRow[0];
    }
};
```

# Answer - DP Top Down

## V1：複習1st時候寫的，簡潔
```Cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // indicate the path num to certail col grid in the current row
        vector<int> pathNumToCol(n, 0);

        // check from row 0 to m-1
        for(int r = 0; r < m; r++) {

            // col 0 in each row -> has only one way to reach
            pathNumToCol[0] = 1;

            // check from col 1 to n - 1
            for(int c = 1; c < n; c++) {
                // grid[r, c] = grid[r-1, c] + grid[r, c-1]
                pathNumToCol[c] = pathNumToCol[c] + pathNumToCol[c-1];
            }
        }

        // finish: grid[m-1, n-1]
        return pathNumToCol[n-1];
    }
};
```

## V2：複習2nd 時候寫的 - 模板化處理
```Cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // grid[r][c] method = grid[r-1][c] + grid[r][c-1]
        // -> method[r][c] (current) = method[r][c] (prev) + method[r][c-1]
        vector<int> methodNum(n, 0);
        methodNum[0] = 1;

        for(int r = 0; r < m; r++) {
            for(int c = 0; c < n; c++) {
                if(!c) methodNum[c] = methodNum[c];
                else methodNum[c] = methodNum[c] + methodNum[c-1];
                
            }
        }

        return methodNum.back();
    }
};
```