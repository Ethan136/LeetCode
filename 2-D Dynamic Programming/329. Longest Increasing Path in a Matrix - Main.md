---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)

# Concept
- **注意：因為是從 「小 -> 大」 走，不會有「走過大地方右走回來的問題」 -> **不需要 mark 走過的地方，並且可用 DP 加速**
- **邊界條件：要設定好是「進 func 後一律踩格子 +1」還是「進 func 後檢查情況，再決定是否踩格子+1」

# Answer：第一次寫的 - 說明比較清楚，比較複雜
## V2：Recursive + 2D DP
```Cpp
#define UN_RECORDED_PATH_LEN    (-1)
class Solution {
private:
    int longestIncreasingPathFromPoint(auto &matrix, int i, int j, auto &pathRecord) {
        // if the start point is invalid
        if(i<0 || i >=matrix.size()) return 0;
        if(j<0 || j >=matrix[0].size()) return 0;

        // if the start point had been checked before
        if(pathRecord[i][j] != UN_RECORDED_PATH_LEN) return pathRecord[i][j];

        // go up from the point
        int up = i - 1, upPath = 1;
        if((up >= 0) && (matrix[i][j] < matrix[up][j])) {
            upPath += longestIncreasingPathFromPoint(matrix, up, j, pathRecord);
        }

        // go down from the point
        int dw = i + 1, dwPath = 1;
        if((dw < matrix.size()) && (matrix[i][j] < matrix[dw][j])) {
            dwPath += longestIncreasingPathFromPoint(matrix, dw, j, pathRecord);
        }

        // go right from the point
        int rt = j + 1, rtPath = 1;
        if((rt < matrix[0].size()) && (matrix[i][j] < matrix[i][rt])) {
            rtPath += longestIncreasingPathFromPoint(matrix, i, rt, pathRecord);
        }

        // go left from the point
        int lf = j - 1, lfPath = 1;
        if((lf >= 0) && (matrix[i][j] < matrix[i][lf])) {
            lfPath += longestIncreasingPathFromPoint(matrix, i, lf, pathRecord);
        }

        // select the maximum as the result
        int maxPath = max( max(upPath, dwPath), max(rtPath, lfPath) );
        pathRecord[i][j] = maxPath;
        return maxPath;
    }
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        // if the matrix is not valid
        if(matrix.size() == 0 || matrix[0].size() == 0) return 0;

        // init the result
        int maxPath = 0;

        // use the other matrix to store the checked points
        vector<vector<int>> pathRecord(matrix.size(), vector<int>(matrix[0].size(), UN_RECORDED_PATH_LEN));

        // check each points as start point on matrix
        for(int i = 0; i < matrix.size(); i++) {
            for(int j = 0; j < matrix[0].size(); j++) {
                maxPath = max(maxPath, longestIncreasingPathFromPoint(matrix, i, j, pathRecord));
            }
        }
        return maxPath;
    }
};
```


# Answer：複習時候寫的 - 簡潔很多
## V1：Recursive + Brute Force
```Cpp
#define DIR_NUM (4)
int const TRAV_DIR[DIR_NUM][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};
class Solution {
private:
    int LISPath(auto &matrix, int r, int c) {

        int maxPathCnt = 1;
        for(int i = 0; i < DIR_NUM; i++) {
            int r2 = r + TRAV_DIR[i][0];
            if((r2 < 0) || (r2 >= matrix.size())) continue;

            int c2 = c + TRAV_DIR[i][1];
            if((c2 < 0) || (c2 >= matrix[r2].size())) continue;

            if(matrix[r][c] >= matrix[r2][c2]) continue;

            int pathCnt = 1 + LISPath(matrix, r2, c2);
            maxPathCnt = max(pathCnt, maxPathCnt);
        }

        return maxPathCnt;
    }
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int maxPathCnt = 0;
        for(int r = 0; r < matrix.size(); r++) {
            for(int c = 0; c < matrix[r].size(); c++) {
                maxPathCnt = max(maxPathCnt, LISPath(matrix, r, c));
            }
        }
        return maxPathCnt;
    }
};
```

## V2：Recursive + 2D DP
```Cpp
#define DIR_NUM (4)
int const TRAV_DIR[DIR_NUM][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};
class Solution {
private:
    int LISPath(auto &matrix, int r, int c, vector<vector<int>> &maxPathCntRec) {

        if(maxPathCntRec[r][c]) {
            return maxPathCntRec[r][c];
        }

        int maxPathCnt = 1;
        for(int i = 0; i < DIR_NUM; i++) {
            int r2 = r + TRAV_DIR[i][0];
            if((r2 < 0) || (r2 >= matrix.size())) continue;

            int c2 = c + TRAV_DIR[i][1];
            if((c2 < 0) || (c2 >= matrix[r2].size())) continue;

            if(matrix[r][c] >= matrix[r2][c2]) continue;

            int pathCnt = 1 + LISPath(matrix, r2, c2, maxPathCntRec);
            maxPathCnt = max(pathCnt, maxPathCnt);
        }

        maxPathCntRec[r][c] = maxPathCnt;
        return maxPathCnt;
    }
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        vector<vector<int>> maxPathCntRec(matrix.size(), vector<int>(matrix[0].size(), 0));

        int maxPathCnt = 0;
        for(int r = 0; r < matrix.size(); r++) {
            for(int c = 0; c < matrix[r].size(); c++) {
                maxPathCnt = max(maxPathCnt, LISPath(matrix, r, c, maxPathCntRec));
            }
        }
        return maxPathCnt;
    }
};
```