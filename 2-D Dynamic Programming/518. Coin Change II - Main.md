---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[518. Coin Change II](https://leetcode.com/problems/coin-change-ii/)

# Concept
- **要注意 DP 的 memo 是否儲存的數值會超過範圍**
- 這題的設定
	- `1 <= coins.length <= 300`
	- `1 <= coins[i] <= 5000`
	- All the values of `coins` are **unique**.
	- `0 <= amount <= 5000`
- 假設
	- coins 為 1 to 300（數字小會比較多組合可以湊）
	- amount 為 5000
	- 此時 DP 的情況
		- 1 可以 try 0 to 5000 次
		- 2 可以 try 0 to 2500 次
		- 3 可以 try 0 to 1666 次
		- 4 可以 try 0 to 1250 次 -> *到這邊 1 to 4 已經可以 try 超過 10^9 次方，而 2^10 為 1024 大約為 10^3* -> **10^9 種組合，超過 int 範圍 -> dp memo 數值要用 long long**

# Answer：第一次寫
```Cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<unsigned long long> combOfAmountN(amount+1, 0);
        combOfAmountN[0] = 1;

        // use coin in outer loop
        // to prevent the "same combination but different sequence are served as different combination"
        for(int coin : coins) {

            // calculate the further available amount from the calculated amount
            for(int curAmount = 0; curAmount < amount; curAmount++) {

                // check whether the current amount + coin amount would over the target amount
                int comAmountFromCurAmount = curAmount + coin;
                if(comAmountFromCurAmount > amount) continue;

                // including the combination of the cur amount
                // into the combination of the added amount (cur amount + coin amount)
                combOfAmountN[comAmountFromCurAmount] += combOfAmountN[curAmount];
            }
        }

        return combOfAmountN.back();
    }
};
```

# Answer：複習1st - 比較簡潔 + 計算有優化
```Cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<unsigned long long> combOfAmount(amount+1, 0);
        combOfAmount[0] = 1;

        sort(coins.begin(), coins.end());

        for(int coin : coins) {

            for(int i = 0; i < amount; i++) {
                if(!combOfAmount[i]) continue;
                if((i+coin) > amount) break;
                combOfAmount[i+coin] += combOfAmount[i];
            }
        }

        return combOfAmount[amount];
    }
};
```

# Answer：複習2nd - 使用模板 （計算緩慢）
```Cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<unsigned long long> amountMethods(amount+1, 0);

        // initial condition
        amountMethods[0] = 1;

        // check along the coin type
        for(int coin : coins) {
            vector<unsigned long long> amountMethodsNext(amount+1, 0);

            for(int n = 0; n <= (amount / coin); n++) {

                for(int i = 0; i <= amount; i++) {
                    if(amountMethods[i] == 0) continue;

                    if((i + n*coin) > amount) break;
                    amountMethodsNext[i + n*coin] += amountMethods[i];
                }
            }

            swap(amountMethods, amountMethodsNext);
        }

        return amountMethods[amount];
    }
};
```