---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---
4
# LeetCode
[97. Interleaving String](https://leetcode.com/problems/interleaving-string/description/)

# Concept
- **起始有 s1 idx / s2 idx 就可以馬上得到 s3 idx = s1 idx + s2 idx**
- s1 idx / s2 idx 代表 s1 / s2 從哪個 idx 當作候選，但在 func 內才決定選 s1 idx 還是 s2 idx 來 match 當前的 s3[ idx3 ]

# Answer：第一次寫的
## V1：Recursive TopDown + Brute Force
```Cpp
class Solution {
private:
    bool isInterleave(  string &s1, int s1StartCheckIdx, string &s2, int s2StartCheckIdx, 
                        string &s3, int s3StartCheckIdx) {

        // if s3 reachs end
        if(s3StartCheckIdx == s3.size()) return true;
        bool checkMatch = false;

        // if s1 & s3 character match
        if(s1StartCheckIdx < s1.size() && s1[s1StartCheckIdx] == s3[s3StartCheckIdx]) {
            checkMatch = isInterleave(s1, s1StartCheckIdx+1, s2, s2StartCheckIdx, s3, s3StartCheckIdx+1);
        }
        if(checkMatch) return true;

        // if s2 & s3 character match
        if(s2StartCheckIdx < s2.size() && s2[s2StartCheckIdx] == s3[s3StartCheckIdx]) {
            checkMatch = isInterleave(s1, s1StartCheckIdx, s2, s2StartCheckIdx+1, s3, s3StartCheckIdx+1);
        }
        return checkMatch;
    }
public:
    bool isInterleave(string s1, string s2, string s3) {
        // size check
        if((s1.size() + s2.size()) != s3.size()) return false;

        if(s1.size() == 0) return (s2 == s3);

        if(s2.size() == 0) return (s1 == s3);

        // DFS check result
        return isInterleave(s1, 0, s2, 0, s3, 0);
    }
};
```

## V2：Recursive TopDown + 2D DP
```Cpp
#define CHECK_STATUS_NOT_CHECKED_YET    (-1)
class Solution {
private:
    bool isInterleave(  string &s1, int s1StartCheckIdx, string &s2, int s2StartCheckIdx, 
                        string &s3, int s3StartCheckIdx, vector<vector<int>> &matchRecord) {

        // if s3 reachs end
        if(s3StartCheckIdx == s3.size()) {
            return true;
        }

        // if the current condition had been checked
        if(matchRecord[s1StartCheckIdx][s2StartCheckIdx] != CHECK_STATUS_NOT_CHECKED_YET) {
            return matchRecord[s1StartCheckIdx][s2StartCheckIdx];
        }

        // if s1 & s3 character match
        bool checkMatch1 = false;
        if(s1StartCheckIdx < s1.size() && s1[s1StartCheckIdx] == s3[s3StartCheckIdx]) {
            checkMatch1 = isInterleave(s1, s1StartCheckIdx+1, s2, s2StartCheckIdx, s3, s3StartCheckIdx+1, matchRecord);
            matchRecord[s1StartCheckIdx+1][s2StartCheckIdx] = checkMatch1;
        }
        if(checkMatch1) return true;

        // if s2 & s3 character match
        bool checkMatch2 = false;
        if(s2StartCheckIdx < s2.size() && s2[s2StartCheckIdx] == s3[s3StartCheckIdx]) {
            checkMatch2 = isInterleave(s1, s1StartCheckIdx, s2, s2StartCheckIdx+1, s3, s3StartCheckIdx+1, matchRecord);
            matchRecord[s1StartCheckIdx][s2StartCheckIdx+1] = checkMatch2;
        }
        if(checkMatch2) return true;

        // if there's no match at all
        matchRecord[s1StartCheckIdx][s2StartCheckIdx] = false;
        return false;
    }

public:
    bool isInterleave(string s1, string s2, string s3) {
        // size check
        if((s1.size() + s2.size()) != s3.size()) return false;

        if(s1.size() == 0) return (s2 == s3);

        if(s2.size() == 0) return (s1 == s3);

        // 2D DP to record match condition
        vector<vector<int>> matchRecord(s1.size()+1, vector<int>(s2.size()+1, CHECK_STATUS_NOT_CHECKED_YET));

        // DFS check result
        return isInterleave(s1, 0, s2, 0, s3, 0, matchRecord);
    }
};
```

# Answer：複習時候寫的
## V1：Recursive TopDown + Burte Force
```Cpp
class Solution {
private:
    bool isInterveave(auto &s1, int idx1, auto &s2, int idx2, auto &s3) {
        if((idx1 >= s1.size()) && (idx2 >= s2.size())) {
            return true;
        }

        int idx3 = idx1 + idx2;
        bool checkPass = false;

        if(!checkPass && (idx1 < s1.size()) && (s1[idx1] == s3[idx3])) {
            checkPass = isInterveave(s1, idx1+1, s2, idx2, s3);
        }

        if(!checkPass && (idx2 < s2.size()) && (s2[idx2]) == s3[idx3]) {
            checkPass = isInterveave(s1, idx1, s2, idx2+1, s3);
        }

        return checkPass;
    }
public:
    bool isInterleave(string s1, string s2, string s3) {
        if((s1.size() + s2.size()) != s3.size()) return false;

        return isInterveave(s1, 0, s2, 0, s3);
    }
};
```

## V2：Recursive TopDown + 2D DP
```Cpp
#define NOT_DETERMINED_COND (-1)
class Solution {
private:
    bool isInterveave(auto &s1, int idx1, auto &s2, int idx2, auto &s3, auto &checkResultRec) {
        if((idx1 >= s1.size()) && (idx2 >= s2.size())) {
            return true;
        }

        if(checkResultRec[idx1][idx2] != NOT_DETERMINED_COND) {
            return checkResultRec[idx1][idx2];
        }

        int idx3 = idx1 + idx2;
        bool checkPass = false;

        if(!checkPass && (idx1 < s1.size()) && (s1[idx1] == s3[idx3])) {
            checkPass = isInterveave(s1, idx1+1, s2, idx2, s3, checkResultRec);
        }

        if(!checkPass && (idx2 < s2.size()) && (s2[idx2]) == s3[idx3]) {
            checkPass = isInterveave(s1, idx1, s2, idx2+1, s3, checkResultRec);
        }

        checkResultRec[idx1][idx2] = checkPass;
        return checkPass;
    }
public:
    bool isInterleave(string s1, string s2, string s3) {
        if((s1.size() + s2.size()) != s3.size()) return false;

        vector<vector<char>> checkResultRec(s1.size()+1, vector<char>(s2.size()+1, NOT_DETERMINED_COND));
        return isInterveave(s1, 0, s2, 0, s3, checkResultRec);
    }
};
```

## V3：Iteration TopDown + 2D DP
```Cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        // if the length is not valid
        if((s1.size() + s2.size()) != s3.size()) return false;

        // match cond before s1[i] & s2[j] (i / j not included)
        vector<vector<bool>> checkResultBeforeIdx(s1.size()+1, vector<bool>(s2.size()+1, false));

        // initialize match cond before s1[0] & s2[0] as true (before idx 0 -> empty -> serve as matched)
        checkResultBeforeIdx[0][0] = true;

        // check from idx 0 to index s1[size] & s2[size]
        for(int i = 0; i <= s1.size(); i++) {
            for(int j = 0; j <= s2.size(); j++) {
                
                // if previous s1[0 to i-1] & s2[0 to j-1] can't match s3[..]
                if(!checkResultBeforeIdx[i][j]) {
                    continue;
                }
                
                // try use s1[i] to match s3[i+j] if s1 is not used up
                if((i < s1.size()) && (s1[i] == s3[i+j])) {
                    checkResultBeforeIdx[i+1][j] = true;
                }

                // try use s2[j] to match s3[i+j] if s2 is not used up
                if((j < s2.size()) && (s2[j] == s3[i+j])) {
                    checkResultBeforeIdx[i][j+1] = true;
                }
            }
        }

        return checkResultBeforeIdx[s1.size()][s2.size()];
    }
};
```

## V4：Iteration TopDown + 1D DP x2
```Cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        // if the length is not valid
        if ((s1.size() + s2.size()) != s3.size()) return false;

        // use shorter one as s2
        if (s2.size() > s1.size()) swap(s1, s2);

        // match cond before s2[j] for current s1[i] (init for s1[0])
        // row0: current s1[i]
        // row1: next s1[i+1]
        vector<vector<bool>> CheckResultBeforeIdx(2, vector<bool>(s2.size() + 1, false));

        // initialize match cond before s2[0] as true (before idx 0 -> empty -> serve as matched)
        CheckResultBeforeIdx[0][0] = true;

        // check s1[0 to end]
        for (int i = 0; i <= (int)s1.size(); i++) {

            // clear next check result
            CheckResultBeforeIdx[1].assign(s2.size() + 1, false);

            // check s2[0 to end]
            for (int j = 0; j <= (int)s2.size(); j++) {

                // if current s1[i] & s2[0 to j-1] can't match s3[..]
                if (!CheckResultBeforeIdx[0][j]) {
                    continue;
                }

                // try use s1[i] to match s3[i+j] if s1 is not used up
                if ((i < s1.size()) && (s1[i] == s3[i + j])) {
                    CheckResultBeforeIdx[1][j] = true;
                }

                // try use s2[j] to match s3[i+j] if s2 is not used up
                if ((j < s2.size()) && (s2[j] == s3[i + j])) {
                    CheckResultBeforeIdx[0][j + 1] = true;
                }
            }

            // swap current & next
            swap(CheckResultBeforeIdx[0], CheckResultBeforeIdx[1]);
        }

        // last current check had been swap to next result
        return CheckResultBeforeIdx[1][s2.size()];
    }
};
```