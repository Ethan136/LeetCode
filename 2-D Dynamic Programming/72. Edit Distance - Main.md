---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[72. Edit Distance](https://leetcode.com/problems/edit-distance/)

# Answer：DFS
## DFS Brute Force
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    int calcMinModifyCnt(auto &word1, int idx1, auto &word2, int idx2) {

        // check until mis-match
        for(; (idx1 < word1.size()) && (idx2 < word2.size()); idx1++, idx2++) {
            if(word1[idx1] != word2[idx2]) break;
        }

        // if word1 or word2 reach end
        if(idx1 >= word1.size()) return (word2.size() - idx2);
        if(idx2 >= word2.size()) return (word1.size() - idx1);

        // init result
        int minModifyCnt = INT_MAX;

        // try word1 take out 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2));

        // try word1 modify 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2+1));

        // try word1 add 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1, word2, idx2+1));

        // finish
        return minModifyCnt;
    }
public:
    int minDistance(string word1, string word2) {

        // calculate modify cnt
        int minModifyCnt = calcMinModifyCnt(word1, 0, word2, 0);
        return minModifyCnt;
    }
};
```

## DFS + 2D DP
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    int calcMinModifyCnt(auto &word1, int idx1, auto &word2, int idx2, auto &modifyCntRec) {

        // early return
        if(modifyCntRec[idx1][idx2] >= 0) return modifyCntRec[idx1][idx2];

        // check until mis-match
        for(; (idx1 < word1.size()) && (idx2 < word2.size()); idx1++, idx2++) {
            if(word1[idx1] != word2[idx2]) break;
        }

        // if word1 or word2 reach end
        if(idx1 >= word1.size()) return (word2.size() - idx2);
        if(idx2 >= word2.size()) return (word1.size() - idx1);

        // init result
        int minModifyCnt = INT_MAX;

        // try word1 take out 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2, modifyCntRec));

        // try word1 modify 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2+1, modifyCntRec));

        // try word1 add 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1, word2, idx2+1, modifyCntRec));

        // record result
        modifyCntRec[idx1][idx2] = minModifyCnt;

        // finish
        return minModifyCnt;
    }
public:
    int minDistance(string word1, string word2) {

        // memo for max sequence match
        vector<vector<int>> modifyCntRec(word1.size() + 1, vector<int>(word2.size() + 1, -1));

        // calculate modify cnt
        int minModifyCnt = calcMinModifyCnt(word1, 0, word2, 0, modifyCntRec);
        return minModifyCnt;
    }
};
```

## DFS + 2D DP + Record Result Optz
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    int calcMinModifyCnt(auto &word1, int idx1, auto &word2, int idx2, auto &modifyCntRec) {

        // early return
        if(modifyCntRec[idx1][idx2] >= 0) return modifyCntRec[idx1][idx2];

        // check until mis-match
        int matchCnt = 0;
        for(; (idx1 < word1.size()) && (idx2 < word2.size()); idx1++, idx2++) {
            if(word1[idx1] != word2[idx2]) break;
            matchCnt++;
        }

        // if word1 or word2 reach end
        if(idx1 >= word1.size()) return (word2.size() - idx2);
        if(idx2 >= word2.size()) return (word1.size() - idx1);

        // init result
        int minModifyCnt = INT_MAX;

        // try word1 take out 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2, modifyCntRec));

        // try word1 modify 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2+1, modifyCntRec));

        // try word1 add 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1, word2, idx2+1, modifyCntRec));

        // record result
        modifyCntRec[idx1][idx2] = minModifyCnt;
        
        // re-wind back to update previous results
        for(int i = 0; i < matchCnt; i++) {
            if(modifyCntRec[idx1 - i][idx2 - i] >= 0) break;
            modifyCntRec[idx1 - i][idx2 - i] = minModifyCnt;
        }

        // finish
        return minModifyCnt;
    }
public:
    int minDistance(string word1, string word2) {

        // memo for max sequence match
        vector<vector<int>> modifyCntRec(word1.size() + 1, vector<int>(word2.size() + 1, -1));

        // calculate modify cnt
        int minModifyCnt = calcMinModifyCnt(word1, 0, word2, 0, modifyCntRec);
        return minModifyCnt;
    }
};
```


# Answer：BFS
## BFS  BottomUp + 2D DP
### V1：複習 1st
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
public:
    int minDistance(string word1, string word2) {

        // memo for max sequence match
        vector<vector<int>> modifyCntFromIdx(word1.size() + 1, vector<int>(word2.size() + 1, 0));

        // word1[i = end] -> modify cnt = word2[j to end]
        for(int j = 0; j < word2.size(); j++) modifyCntFromIdx[word1.size()][j] = word2.size() - j;

        // word2[j = end] -> modify cnt = word1[i to end]
        for(int i = 0; i < word1.size(); i++) modifyCntFromIdx[i][word2.size()] = word1.size() - i;

        // calculate modify cnt
        for(int i = (int)(word1.size()) - 1; i >= 0; i--) {

            for(int j = (int)(word2.size() - 1); j >= 0; j--) {

                // if match
                if(word1[i] == word2[j]) {
                    modifyCntFromIdx[i][j] = modifyCntFromIdx[i+1][j+1];
                }
                // if not match
                else {
                    // (0) init min modify cnt
                    int minModifyCnt = INT_MAX;

                    // (1) take out word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx[i+1][j]);

                    // (2) change word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx[i+1][j+1]);

                    // (3) insert new char to word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx[i][j+1]);

                    // (4) update modify cnt of word1[i] word2[j]
                    modifyCntFromIdx[i][j] = minModifyCnt;
                }
            }
        }

        return modifyCntFromIdx[0][0];
    }
};
```

### V2：複習2nd
```Cpp
class Solution {
public:
    int minDistance(string word1, string word2) {

        if(word1.empty() || word2.empty()) {
            return abs((int)(word1.size() - word2.size()));
        }

        // [transition matrix]
        // modifyCnt[idx1, idx2]: modify cnt of matching to word1[idx1] & word2[idx2]
        // modifyCnt[-1, -1] -> match with modify cnt = 0 -> check 0, 0
        // modifyCnt[0, 0] -> 
        // - match: modify cnt = 0 -> check 1, 1
        // - un-match: modify cnt = 1
        // - (a) delete -> next check (idx1+1, idx2)
        // - (b) insert -> next check (idx1, idx2+1)
        // - (c) change -> next check (idx1+1, idx2+1)
        // DFS Condition -> should use bottom up to get minModifyCnt of (idx1, idx2)

        // start from word2[end + 1]
        vector<int> modifyCntFromIdx1(word1.size()+1, 0);
        for(int idx1 = 0; idx1 < word1.size(); idx1++) modifyCntFromIdx1[idx1] = (word1.size() - idx1);
        modifyCntFromIdx1[word1.size()] = 0;

        // idx2 before the currently checked one in bottom up process
        vector<int> modifyCntFromIdx1_prevIdx2(word1.size()+1, 0);

        // bottom up to check modify cnt finally at [idx1=0, idx2=0]
        for(int idx2 = word2.size()-1; idx2 >= 0; idx2--) {

            // (1) idx1 = word1[end + 1]
            modifyCntFromIdx1_prevIdx2[word1.size()] = (word2.size() - idx2);

            // (2) idx1 = word1[end to 0]
            for(int idx1 = word1.size()-1; idx1 >= 0; idx1--) {
                // match
                if(word1[idx1] == word2[idx2]) {
                    modifyCntFromIdx1_prevIdx2[idx1] = modifyCntFromIdx1[idx1+1];
                    continue;
                }
                
                // not match -> try all modification methods
                // (a) delete word
                int delIdx1ModifyCnt = 1 + modifyCntFromIdx1_prevIdx2[idx1+1];

                // (b) insert to idx1
                int isrtIdx1ModifyCnt = 1 + modifyCntFromIdx1[idx1];

                // (c) change word
                int chgIdx1ModifyCnt = 1 + modifyCntFromIdx1[idx1+1];

                // select min modify methos
                modifyCntFromIdx1_prevIdx2[idx1] = min(delIdx1ModifyCnt, min(isrtIdx1ModifyCnt, chgIdx1ModifyCnt));
            }

            swap(modifyCntFromIdx1, modifyCntFromIdx1_prevIdx2);
        }

        // finish: return modify cnt after word1[idx1 = 0] & word2[idx2 = 0]
        return modifyCntFromIdx1[0];
    }
};
```

## BFS BottomUp + 1D DP + Cond Backup by Variable
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
public:
    int minDistance(string word1, string word2) {

        // select shorter one as word2
        if(word1.size() < word2.size()) swap(word1, word2);

        // memo for max sequence match
        vector<int> modifyCntFromIdx_2(word2.size() + 1, 0);

        // start from word1[i = size()] -> word1 empty -> modify cnt = word2[j to end] = (end - j)
        for(int j = 0; j < word2.size(); j++) modifyCntFromIdx_2[j] = word2.size() - j;

        // calculate modify cnt
        for(int i = (int)(word1.size()) - 1; i >= 0; i--) {

            // backup next idx condition for previous word1[i+1]
            int next1ModifyCntFromNextIdx_2;
            int next1ModifyCntFromIdx_2 = modifyCntFromIdx_2[word2.size()];

            // for word1[i] -> word2[j = end] -> modify cnt = word1[i to end]
            modifyCntFromIdx_2[word2.size()] = word1.size() - i;

            for(int j = (int)(word2.size() - 1); j >= 0; j--) {

                // backup condition
                next1ModifyCntFromNextIdx_2 = next1ModifyCntFromIdx_2;
                next1ModifyCntFromIdx_2 = modifyCntFromIdx_2[j];

                // if match
                if(word1[i] == word2[j]) {
                   modifyCntFromIdx_2[j] = next1ModifyCntFromNextIdx_2;
                }
                // if not match
                else {
                    // (0) init min modify cnt
                    int minModifyCnt = INT_MAX;

                    // (1) take out word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + next1ModifyCntFromIdx_2);

                    // (2) change word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + next1ModifyCntFromNextIdx_2);

                    // (3) insert new char to word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx_2[j+1]);

                    // (4) update modify cnt of word1[i] word2[j]
                    modifyCntFromIdx_2[j] = minModifyCnt;
                }
            }
        }

        return modifyCntFromIdx_2[0];
    }
};
```