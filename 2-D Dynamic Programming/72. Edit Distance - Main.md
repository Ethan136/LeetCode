---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[72. Edit Distance](https://leetcode.com/problems/edit-distance/)

# Answer：DFS
## DFS Brute Force
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    int calcMinModifyCnt(auto &word1, int idx1, auto &word2, int idx2) {

        // check until mis-match
        for(; (idx1 < word1.size()) && (idx2 < word2.size()); idx1++, idx2++) {
            if(word1[idx1] != word2[idx2]) break;
        }

        // if word1 or word2 reach end
        if(idx1 >= word1.size()) return (word2.size() - idx2);
        if(idx2 >= word2.size()) return (word1.size() - idx1);

        // init result
        int minModifyCnt = INT_MAX;

        // try word1 take out 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2));

        // try word1 modify 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2+1));

        // try word1 add 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1, word2, idx2+1));

        // finish
        return minModifyCnt;
    }
public:
    int minDistance(string word1, string word2) {

        // calculate modify cnt
        int minModifyCnt = calcMinModifyCnt(word1, 0, word2, 0);
        return minModifyCnt;
    }
};
```

## DFS + 2D DP
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    int calcMinModifyCnt(auto &word1, int idx1, auto &word2, int idx2, auto &modifyCntRec) {

        // early return
        if(modifyCntRec[idx1][idx2] >= 0) return modifyCntRec[idx1][idx2];

        // check until mis-match
        for(; (idx1 < word1.size()) && (idx2 < word2.size()); idx1++, idx2++) {
            if(word1[idx1] != word2[idx2]) break;
        }

        // if word1 or word2 reach end
        if(idx1 >= word1.size()) return (word2.size() - idx2);
        if(idx2 >= word2.size()) return (word1.size() - idx1);

        // init result
        int minModifyCnt = INT_MAX;

        // try word1 take out 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2, modifyCntRec));

        // try word1 modify 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2+1, modifyCntRec));

        // try word1 add 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1, word2, idx2+1, modifyCntRec));

        // record result
        modifyCntRec[idx1][idx2] = minModifyCnt;

        // finish
        return minModifyCnt;
    }
public:
    int minDistance(string word1, string word2) {

        // memo for max sequence match
        vector<vector<int>> modifyCntRec(word1.size() + 1, vector<int>(word2.size() + 1, -1));

        // calculate modify cnt
        int minModifyCnt = calcMinModifyCnt(word1, 0, word2, 0, modifyCntRec);
        return minModifyCnt;
    }
};
```

## DFS + 2D DP + Record Result Optz
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    int calcMinModifyCnt(auto &word1, int idx1, auto &word2, int idx2, auto &modifyCntRec) {

        // early return
        if(modifyCntRec[idx1][idx2] >= 0) return modifyCntRec[idx1][idx2];

        // check until mis-match
        int matchCnt = 0;
        for(; (idx1 < word1.size()) && (idx2 < word2.size()); idx1++, idx2++) {
            if(word1[idx1] != word2[idx2]) break;
            matchCnt++;
        }

        // if word1 or word2 reach end
        if(idx1 >= word1.size()) return (word2.size() - idx2);
        if(idx2 >= word2.size()) return (word1.size() - idx1);

        // init result
        int minModifyCnt = INT_MAX;

        // try word1 take out 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2, modifyCntRec));

        // try word1 modify 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1+1, word2, idx2+1, modifyCntRec));

        // try word1 add 1 char
        minModifyCnt = min(minModifyCnt, 1 + calcMinModifyCnt(word1, idx1, word2, idx2+1, modifyCntRec));

        // record result
        modifyCntRec[idx1][idx2] = minModifyCnt;
        
        // re-wind back to update previous results
        for(int i = 0; i < matchCnt; i++) {
            if(modifyCntRec[idx1 - i][idx2 - i] >= 0) break;
            modifyCntRec[idx1 - i][idx2 - i] = minModifyCnt;
        }

        // finish
        return minModifyCnt;
    }
public:
    int minDistance(string word1, string word2) {

        // memo for max sequence match
        vector<vector<int>> modifyCntRec(word1.size() + 1, vector<int>(word2.size() + 1, -1));

        // calculate modify cnt
        int minModifyCnt = calcMinModifyCnt(word1, 0, word2, 0, modifyCntRec);
        return minModifyCnt;
    }
};
```


# Answer：BFS
## BFS  BottomUp + 2D DP
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
public:
    int minDistance(string word1, string word2) {

        // memo for max sequence match
        vector<vector<int>> modifyCntFromIdx(word1.size() + 1, vector<int>(word2.size() + 1, 0));

        // word1[i = end] -> modify cnt = word2[j to end]
        for(int j = 0; j < word2.size(); j++) modifyCntFromIdx[word1.size()][j] = word2.size() - j;

        // word2[j = end] -> modify cnt = word1[i to end]
        for(int i = 0; i < word1.size(); i++) modifyCntFromIdx[i][word2.size()] = word1.size() - i;

        // calculate modify cnt
        for(int i = (int)(word1.size()) - 1; i >= 0; i--) {

            for(int j = (int)(word2.size() - 1); j >= 0; j--) {

                // if match
                if(word1[i] == word2[j]) {
                    modifyCntFromIdx[i][j] = modifyCntFromIdx[i+1][j+1];
                }
                // if not match
                else {
                    // (0) init min modify cnt
                    int minModifyCnt = INT_MAX;

                    // (1) take out word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx[i+1][j]);

                    // (2) change word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx[i+1][j+1]);

                    // (3) insert new char to word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx[i][j+1]);

                    // (4) update modify cnt of word1[i] word2[j]
                    modifyCntFromIdx[i][j] = minModifyCnt;
                }
            }
        }

        return modifyCntFromIdx[0][0];
    }
};
```

## BFS BottomUp + 1D DP + Cond Backup by Variable
```Cpp
#define PRINT_VAR(_VAR_) cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
public:
    int minDistance(string word1, string word2) {

        // select shorter one as word2
        if(word1.size() < word2.size()) swap(word1, word2);

        // memo for max sequence match
        vector<int> modifyCntFromIdx_2(word2.size() + 1, 0);

        // start from word1[i = size()] -> word1 empty -> modify cnt = word2[j to end] = (end - j)
        for(int j = 0; j < word2.size(); j++) modifyCntFromIdx_2[j] = word2.size() - j;

        // calculate modify cnt
        for(int i = (int)(word1.size()) - 1; i >= 0; i--) {

            // backup next idx condition for previous word1[i+1]
            int next1ModifyCntFromNextIdx_2;
            int next1ModifyCntFromIdx_2 = modifyCntFromIdx_2[word2.size()];

            // for word1[i] -> word2[j = end] -> modify cnt = word1[i to end]
            modifyCntFromIdx_2[word2.size()] = word1.size() - i;

            for(int j = (int)(word2.size() - 1); j >= 0; j--) {

                // backup condition
                next1ModifyCntFromNextIdx_2 = next1ModifyCntFromIdx_2;
                next1ModifyCntFromIdx_2 = modifyCntFromIdx_2[j];

                // if match
                if(word1[i] == word2[j]) {
                   modifyCntFromIdx_2[j] = next1ModifyCntFromNextIdx_2;
                }
                // if not match
                else {
                    // (0) init min modify cnt
                    int minModifyCnt = INT_MAX;

                    // (1) take out word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + next1ModifyCntFromIdx_2);

                    // (2) change word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + next1ModifyCntFromNextIdx_2);

                    // (3) insert new char to word1[i]
                    minModifyCnt = min(minModifyCnt, 1 + modifyCntFromIdx_2[j+1]);

                    // (4) update modify cnt of word1[i] word2[j]
                    modifyCntFromIdx_2[j] = minModifyCnt;
                }
            }
        }

        return modifyCntFromIdx_2[0];
    }
};
```