---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[494. Target Sum](https://leetcode.com/problems/target-sum/)

# Answer
## V1：Recusive Top Down Brute Force
```Cpp
class Solution {
private:
    int findTargetSumWays(auto &nums, int startIdx, int target, auto &targetSumWaysFromIdx) {
        // if current xond had been calculated
        if(targetSumWaysFromIdx.count(startIdx) && targetSumWaysFromIdx[startIdx].count(target)) {
            return targetSumWaysFromIdx[startIdx][target];
        }
        
        // terminate cond
        if(startIdx >= nums.size()) {
            return (target==0);
        }

        // cond1: use add
        int useAddWays = findTargetSumWays(nums, startIdx+1, target-nums[startIdx], targetSumWaysFromIdx);

        // cond2: use minus
        int useMinusWays = findTargetSumWays(nums, startIdx+1, target+nums[startIdx], targetSumWaysFromIdx);

        // return all ways
        targetSumWaysFromIdx[startIdx][target] = useAddWays + useMinusWays;
        return useAddWays + useMinusWays;
    }
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        unordered_map<int, unordered_map<int,int>> targetSumWaysFromIdx;
        return findTargetSumWays(nums, 0, target, targetSumWaysFromIdx);
    }
};
```

## V2：Recursive Top Down + 2D DP
```Cpp
class Solution {
private:
    int findTargetSumWays(auto &nums, int startIdx, int target, auto &targetSumWaysFromIdx) {
        // if current xond had been calculated
        if(targetSumWaysFromIdx.count(startIdx) && targetSumWaysFromIdx[startIdx].count(target)) {
            return targetSumWaysFromIdx[startIdx][target];
        }
        
        // terminate cond
        if(startIdx >= nums.size()) {
            return (target==0);
        }

        // cond1: use add
        int useAddWays = findTargetSumWays(nums, startIdx+1, target-nums[startIdx], targetSumWaysFromIdx);

        // cond2: use minus
        int useMinusWays = findTargetSumWays(nums, startIdx+1, target+nums[startIdx], targetSumWaysFromIdx);

        // return all ways
        targetSumWaysFromIdx[startIdx][target] = useAddWays + useMinusWays;
        return useAddWays + useMinusWays;
    }
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        unordered_map<int, unordered_map<int,int>> targetSumWaysFromIdx;
        return findTargetSumWays(nums, 0, target, targetSumWaysFromIdx);
    }
};
```

## V3：Iteration Top Down + 2D DP
- **這個寫法類似 BFS，從上到下逐漸平行展開**
```Cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
	    // 意義為「某個 nums[i] 前 (不包含) 的 nums[ to i-1] 可湊出某個數值有幾種做法」 
        unordered_map<int, unordered_map<int, int>> targetSumWaysBeforeIdx;
        
        // nums[0] 前的 nums[:: to -1] 湊出 sum = 0 只有一種做法 (不採用任何數字)
        targetSumWaysBeforeIdx[0][0] = 1;

        for(int j = 0; j < nums.size(); j++) {
            
            for(auto [sum, cnt] : targetSumWaysBeforeIdx[j]) {
                // use add
                targetSumWaysBeforeIdx[j+1][sum+nums[j]] += cnt;

                // use minus
                targetSumWaysBeforeIdx[j+1][sum-nums[j]] += cnt;
            }
        }

		// 回傳 nums[ size() ] 前的 nums[0 to last idx] 可以對 target 有幾種湊法
        return targetSumWaysBeforeIdx[nums.size()][target];
    }
};
```

## V4：Iteration Top Down + 1D DP x2
```Cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // initialize as "before index = 0"
        unordered_map<int, int> targetSumWaysBeforeCurIdx;
        targetSumWaysBeforeCurIdx[0] = 1;

        for(int j = 0; j < nums.size(); j++) {
            unordered_map<int, int> nexttargetSumWaysBeforeCurIdx;

            for(auto [sum, cnt] : targetSumWaysBeforeCurIdx) {

                // use add
                nexttargetSumWaysBeforeCurIdx[sum+nums[j]] += cnt;

                // use minus
                nexttargetSumWaysBeforeCurIdx[sum-nums[j]] += cnt;
            }

            swap(nexttargetSumWaysBeforeCurIdx, targetSumWaysBeforeCurIdx);
        }

        return targetSumWaysBeforeCurIdx[target];
    }
};
```

## V5：Iteraion Top Down + 1D DPx2 + DP 儲存從 map 改成 vector
- 由於 num sum 可能有正有負 -> 所以用 vector 儲存的時候，要加上一個 offset
	- 先計算所有的 abs(nums[i]) 加起來最大是多少 -> totalSum 設為 offset
	- 實際加總範圍一定在 \[ -totalSum , totalSum \] 之間
	- 如果 taget 超出這個範圍 -> early return false
	- 實際的 DP memo 儲存範圍為 \[ -totalSum , totalSum \] -> 加上 offset 變成 \[0 , 2 x totalSum\] -> *vector size = totalSumx2 + 1*
```Cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // total sum offset to prevent negative index
        int totalSum = 0;
        for(auto num : nums) totalSum += abs(num);

        // early return if target is out of range
        if(abs(target) > totalSum) return 0;

        // initialize as "before index = 0"
        vector<int> targetSumWaysBeforeCurIdx( (totalSum*2 + 1), 0 );
        targetSumWaysBeforeCurIdx[totalSum + 0] = 1;

        for(int j = 0; j < nums.size(); j++) {
            vector<int> nexttargetSumWaysBeforeCurIdx( (totalSum*2 + 1), 0 );

            for(int sum = -totalSum; sum <= totalSum; sum++) {

                // cnt ways of the sum
                int cnt = targetSumWaysBeforeCurIdx[totalSum + sum];
                if(cnt == 0) continue;

                // use add
                if(abs(sum+nums[j]) <= totalSum) nexttargetSumWaysBeforeCurIdx[totalSum + (sum+nums[j])] += cnt;

                // use minus
                if(abs(sum+nums[j]) <= totalSum) nexttargetSumWaysBeforeCurIdx[totalSum + (sum-nums[j])] += cnt;
            }

            swap(nexttargetSumWaysBeforeCurIdx, targetSumWaysBeforeCurIdx);
        }

        return targetSumWaysBeforeCurIdx[totalSum + target];
    }
};
```