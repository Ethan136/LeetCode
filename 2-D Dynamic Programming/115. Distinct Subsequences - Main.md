---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)

# Concept
**DP 設計概念**
- Brute Force Recursive -> DFS -> 使用 memo 來記錄算過的情況
	- memo 減少分支執行情況，但分支的開頭仍然會試著走看看（然後遇到 memo early return）
	- memo 類似一個外掛記錄，算過的情況就不用重新算
	- **memo 空間無法壓縮，但比較直覺**
- Brute Force Iteration -> BFS -> 使用 DP 來推衍算過的情況
	- DP 來進行分支壓縮，每一層都把情況壓縮到固定數量（避免分支發散）
	- DP 是一個內部機制優化，來簡化運作時的計算機制
	- **DP 可以進行空間壓縮，但要先觀察『每一層會往前用哪幾層的資訊』**
		- 空間壓縮可以是『只保留某幾個層數的 DP』
		- 空間壓縮也可是『只備份某幾個變數的 DP』


# Answer：DFS Brute Force
## V1：DFS - 嘗試每一種情況
```Cpp
class Solution {
private:
    int numDistinct(auto &s, int startidx_s, auto &t, int idx_t) {
        if(idx_t >= t.size()) return 1;
        if(startidx_s >= s.size()) return 0;
        

        char char_s = s[startidx_s];
        char char_t = t[idx_t];

        int distCnt = 0;

        // char match
        if(char_s == char_t) {
            // 1) use s[i]
            distCnt += numDistinct(s, startidx_s+1, t, idx_t+1);

            // 2) dkip s[i] and try s[i+1]
            distCnt += numDistinct(s, startidx_s+1, t, idx_t);
        }

        // char not match
        else {
            distCnt += numDistinct(s, startidx_s+1, t, idx_t);
        }
        
        return distCnt;
    }
public:
    int numDistinct(string s, string t) {
        return numDistinct(s, 0, t, 0);
    }
};
```
## V2：DFS + Optz - (1)只針對 s[i] = t[j] / (2) s[i] 後續字元足夠的情況才做 DFS / (3) input 必須為 valid
```Cpp
class Solution {
private:
    int numDistinct(auto &s, int startidx_s, auto &t, int idx_t) {

        // init result
        int distCnt = 0;

        // remained char t
        int charNumAfter_t = (t.size()-1) - idx_t;

        // check all the possible s[i]
        for(int i = startidx_s; i < ( (int)(s.size()) - charNumAfter_t ); i++) {
            if(s[i] != t[idx_t]) continue;

            if(idx_t == (t.size()-1)) distCnt += 1;
            else distCnt += numDistinct(s, i+1, t, idx_t+1);
        }

        // record result
        return distCnt;
    }
public:
    int numDistinct(string s, string t) {
        return numDistinct(s, 0, t, 0);
    }
};
```


# Answer：DFS + 2D DP
## V1：DFS Basic + 2D DP
```Cpp
#define INVALID_NUM (-1)
class Solution {
private:
    int numDistinct(auto &s, int startidx_s, auto &t, int idx_t, auto &numDistRec) {
        if(numDistRec[startidx_s][idx_t] != INVALID_NUM) return numDistRec[startidx_s][idx_t];
        if(idx_t >= t.size()) return 1;
        if(startidx_s >= s.size()) return 0;
        

        char char_s = s[startidx_s];
        char char_t = t[idx_t];

        int distCnt = 0;

        // char match
        if(char_s == char_t) {
            // 1) use s[i]
            distCnt += numDistinct(s, startidx_s+1, t, idx_t+1, numDistRec);

            // 2) dkip s[i] and try s[i+1]
            distCnt += numDistinct(s, startidx_s+1, t, idx_t, numDistRec);
        }

        // char not match
        else {
            distCnt += numDistinct(s, startidx_s+1, t, idx_t, numDistRec);
        }

        numDistRec[startidx_s][idx_t] = distCnt;
        return distCnt;
    }
public:
    int numDistinct(string s, string t) {
        vector<vector<int>> numDistRec(s.size()+1, vector<int>(t.size()+1, INVALID_NUM));
        return numDistinct(s, 0, t, 0, numDistRec);
    }
};
```

## V2：DFS Optz + 2D DP - (1)只針對 s[i] = t[j] / (2) s[i] 後續字元足夠的情況才做 DFS / (3) input 必須為 valid
```Cpp
#define INVALID_NUM (-1)
class Solution {
private:
    int numDistinct(auto &s, int startidx_s, auto &t, int idx_t, auto &numDistRec) {
        // early return
        if(numDistRec[startidx_s][idx_t] != INVALID_NUM) return numDistRec[startidx_s][idx_t];

        // init result
        int distCnt = 0;

        // remained char t
        int charNumAfter_t = (t.size()-1) - idx_t;

        // check all the possible s[i]
        for(int i = startidx_s; i < ( (int)(s.size()) - charNumAfter_t ); i++) {
            if(s[i] != t[idx_t]) continue;

            if(idx_t == (t.size()-1)) distCnt += 1;
            else distCnt += numDistinct(s, i+1, t, idx_t+1, numDistRec);
        }

        // record result
        numDistRec[startidx_s][idx_t] = distCnt;
        return distCnt;
    }
public:
    int numDistinct(string s, string t) {
        vector<vector<int>> numDistRec(s.size(), vector<int>(t.size(), INVALID_NUM));
        return numDistinct(s, 0, t, 0, numDistRec);
    }
};
```


# Answer：BFS Brute Force
## V1：BFS - (1) 只針對 s[i] = t[j] 的情況做後續 BFS
```Cpp
class Solution {
public:
    int numDistinct(string s, string t) {

        queue<int> checkQueue;
        int afterCnt_t = (t.size()-1);
        for(int i = 0; i < (int)(s.size() - afterCnt_t); i++) {
            if(s[i] == t[0]) checkQueue.push(i);
        }
        
        for(int j = 1; j < t.size(); j++) {

            int checkCnt = checkQueue.size();
            if(checkCnt == 0) break;
    
            while(checkCnt--) {
                int prevIdx_s = checkQueue.front();
                checkQueue.pop();

                int afterCnt_t = (t.size()-1) - j;
                for(int i = (prevIdx_s + 1); i < ((int)(s.size()) - afterCnt_t); i++) {
                    if(s[i] != t[j]) continue;
                    checkQueue.push(i);
                }
            }
        }

        return checkQueue.size();
    }
};
```

##  Answer：BFS + 2D DP
## V1：BFS + 2D DP

## BFS + 2D DP | Outer t - Inner s
```Cpp
class Solution {
public:
    int numDistinct(string s, string t) {

        // match cnt before s[i] & t[j] (i not included)
        vector<vector<unsigned long long>> matchCntBeforeIdx(t.size()+1, vector<unsigned long long>(s.size()+1, 0));

        // match cnt before t[0] -> use empty t -> any s[i] with match cnt 1
        for(int j = 0; j < matchCntBeforeIdx[0].size(); j++) matchCntBeforeIdx[0][j] = 1;
        
        // check each t[j]
        for(int j = 0; j < t.size(); j++) {

            // check each s[:] for every t[j]
            for(int i = 0; i < s.size(); i++) {

                // deliver match cnt ( s[i-1] & t[j] ) to ( s[i] & t[j] )
                matchCntBeforeIdx[j+1][i+1] = matchCntBeforeIdx[j+1][i];

                // if ( t[j] == s[i] ) -> add match cnt of ( t[j] & s[i] ) with ( t[j-1] & s[i-1] )
                if(s[i] == t[j]) matchCntBeforeIdx[j+1][i+1] += matchCntBeforeIdx[j][i];
            }
        }

        // return match cnt before ( t[size()] & s[size()] )
        return matchCntBeforeIdx[t.size()][s.size()];
    }
};
```


## BFS + 2D DP | Outer s - Inner t
```Cpp
class Solution {
public:
    int numDistinct(string s, string t) {

        // match cnt before s[i] & t[j] (i not included)
        vector<vector<unsigned long long>> matchCntBeforeIdx(s.size()+1, vector<unsigned long long>(t.size()+1, 0));

        // match cnt before t[0] -> use empty t -> any s[i] with match cnt 1
        for(int i = 0; i < matchCntBeforeIdx.size(); i++) matchCntBeforeIdx[i][0] = 1;
        
        // check each s[i]
        for(int i = 0; i < s.size(); i++) {

            // check each t[:] for every s[i]
            for(int j = 0; j < t.size(); j++) {

                // deliver match cnt ( s[i-1] & t[j] ) to ( s[i] & t[j] )
                matchCntBeforeIdx[i+1][j+1] = matchCntBeforeIdx[i][j+1];

                // if ( t[j] == s[i] ) -> add match cnt of ( t[j] & s[i] ) with ( t[j-1] & s[i-1] )
                if(s[i] == t[j]) matchCntBeforeIdx[i+1][j+1] += matchCntBeforeIdx[i][j];
            }
        }

        // return match cnt before ( t[size()] & s[size()] )
        return matchCntBeforeIdx[s.size()][t.size()];
    }
};
```

## V2：BFS + 1D DP x 2
### BFS + 1D DP x 2 | Based on s
```Cpp
class Solution {
public:
    int numDistinct(string s, string t) {

        // match cnt before t[j] & s[i] (i not included)
        // init as match cnt before t[0] (empty str) -> any s[i] with match cnt 1
        vector<unsigned long long> matchCntBeforeIdx(s.size()+1, 1);

        // check each t[j]
        for(int j = 0; j < t.size(); j++) {

            // to backup -> matchCntBeforeIdx[] on t[j-1]
            vector<unsigned long long> matchCntBeforeIdx_prev(s.size()+1, 0);
            swap(matchCntBeforeIdx_prev, matchCntBeforeIdx);

            // check each s[:] for every t[j] -> matchCntBeforeIdx[] on t[j]
            for(int i = 0; i < s.size(); i++) {

                // deliver match cnt ( t[j] & s[i-1] ) to ( t[j] & s[i] )
                matchCntBeforeIdx[i+1] = matchCntBeforeIdx[i];

                // if ( t[j] == s[i] ) -> add match cnt of ( t[j] & s[i] ) with ( t[j-1] & s[i-1] )
                if(s[i] == t[j]) matchCntBeforeIdx[i+1] += matchCntBeforeIdx_prev[i];
            }
        }

        // return match cnt before ( t[size()] & s[size()] )
        return matchCntBeforeIdx[s.size()];
    }
};
```

### BFS + 1D DP x 2 | Based on t
```Cpp
class Solution {
public:
    int numDistinct(string s, string t) {

        // match cnt before t[j] & s[i] (j not included) based on t[j], start on s[-1]
        vector<unsigned long long> matchCntBeforeIdx_t(t.size()+1, 0);

        // init match cnt before t[0] as 1 (empty str -> match 1)
        matchCntBeforeIdx_t[0] = 1;

        // check each s[i]
        for(int i = 0; i < s.size(); i++) {

            // next idx ( s[i+1] ) match cnt before t[j]
            vector<unsigned long long> nextMatchCntBeforeIdx_t(t.size()+1, 0);

            // init match cnt before t[0] as 1 (empty str -> match 1)
            nextMatchCntBeforeIdx_t[0] = 1;

            // check each t[j] for every s[i] -> nextMatchCntBeforeIdx_t[] on s[i]
            for(int j = 0; j < t.size(); j++) {

                // deliver match cnt ( t[j] & s[i-1] ) to ( t[j] & s[i] )
                nextMatchCntBeforeIdx_t[j+1] = matchCntBeforeIdx_t[j+1];

                // if ( t[j] == s[i] ) -> add match cnt of ( t[j] & s[i] ) with ( t[j-1] & s[i-1] )
                if(s[i] == t[j]) nextMatchCntBeforeIdx_t[j+1] += matchCntBeforeIdx_t[j];
            }

            // swap current with next
            swap(matchCntBeforeIdx_t, nextMatchCntBeforeIdx_t);
        }

        // return match cnt before ( t[size()] & s[size()] )
        return matchCntBeforeIdx_t[t.size()];
    }
};
```

## V2：BFS + 1D DP x 1 + Cond Backup
### BFS + 1D DP x 1 + Cond Backup + Optz 只檢查剩餘字元足夠的情況 | Based on s
```Cpp
class Solution {
public:
    int numDistinct(string s, string t) {

        // match cnt before t[j] & s[i] (i not included)
        // init as match cnt before t[0] (empty str) -> every match cnt of s[] is 1
        vector<unsigned long long> matchCntBeforeIdx_s(s.size()+1, 1);

        // t[j] 'd'ef
            // s[i] 'abcdefffgefg'
            // matchCnt: t[0] = 'd' -> [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            // matchCnt: t[1] = 'e' -> [0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2]
            // matchCnt: t[2] = 'f' -> [0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 5, 5] -> result = 5

        // check each t[j]
        for(int j = 0; j < t.size(); j++) {

            // backup match cnt before ( t[j-1] & s[i-1] ) and ( t[j-1] & s[i] ), start from idx = -1
            int prevMatchCntBeforeIdx_s = 0;
            int prevMatchCntBeforeNextIdx_s = matchCntBeforeIdx_s[0];

            // reset matCnt without any s[i] (before idx 0) as 0
            matchCntBeforeIdx_s[0] = 0;

            // check each s[:] for every t[j] -> matchCntBeforeIdx[] on t[j]
            int charCntAfter_t = (t.size()-1) - j;
            for(int i = 0; i < (s.size() - charCntAfter_t); i++) {

                // backup previous match cnt of t[j-1]
                prevMatchCntBeforeIdx_s = prevMatchCntBeforeNextIdx_s;
                prevMatchCntBeforeNextIdx_s = matchCntBeforeIdx_s[i+1];

                // deliver match cnt ( t[j] & s[i-1] ) to ( t[j] & s[i] )
                matchCntBeforeIdx_s[i+1] = matchCntBeforeIdx_s[i];

                // if ( t[j] == s[i] ) -> add match cnt of ( t[j] & s[i] ) with ( t[j-1] & s[i-1] )
                if(s[i] == t[j]) matchCntBeforeIdx_s[i+1] += prevMatchCntBeforeIdx_s;
            }
        }

        // return match cnt before ( t[size()] & s[size()] )
        return matchCntBeforeIdx_s[s.size()];
    }
};
```

### BFS + 1D DP x 1 + Cond Backup + Optz 只檢查剩餘字元足夠的情況 | Based on t
```Cpp
class Solution {
public:
    int numDistinct(string s, string t) {

        // match cnt before t[j] & s[i] (i not included)
        // init as match cnt before s[0] (empty str) -> only match cnt before t[0] is 1 (use empty t[])
        vector<unsigned long long> matchCntBeforeIdx_t(t.size()+1, 0);
        matchCntBeforeIdx_t[0] = 1;

        // s[i] 'a'bcdefffgefg
            // t[j] 'def'
            // matchCnt: s[0] = 'a' -> [1, 0, 0, 0]
            // matchCnt: s[1] = 'b' -> [1, 0, 0, 0]
            // matchCnt: s[2] = 'c' -> [1, 0, 0, 0]
            // matchCnt: s[3] = 'd' -> [1, 1, 0, 0]
            // matchCnt: s[4] = 'e' -> [1, 1, 1, 0]
            // matchCnt: s[5] = 'f' -> [1, 1, 1, 1]
            // matchCnt: s[6] = 'f' -> [1, 1, 1, 2]
            // matchCnt: s[7] = 'f' -> [1, 1, 1, 3]
            // matchCnt: s[8] = 'g' -> [1, 1, 1, 3]
            // matchCnt: s[9] = 'e' -> [1, 1, 2, 3]
            // matchCnt: s[A] = 'f' -> [1, 1, 2, 5]
            // matchCnt: s[B] = 'g' -> [1, 1, 2, 5] -> result = 5

        // check each s[i]
        for(int i = 0; i < s.size(); i++) {

            // check each t[:] for every s[i] -> matchCntBeforeIdx[] on s[i]
            int charCntAfter_s = (s.size()-1) - i;
            int leastChkIdx_t = (charCntAfter_s >= t.size()) ? (0) : (t.size()-1 - charCntAfter_s);
            for(int j = t.size() - 1; j >= leastChkIdx_t; j--) {
                // backup match cnt before t[j-1] & s[j-1]
                int prevMatchCntBeforeIdx_t = matchCntBeforeIdx_t[j];

                // deliver match cnt ( t[j] & s[i-1] ) to ( t[j] & s[i] )
                // new MatchCntBeforeIdx_t[j+1] = old matchCntBeforeIdx_t[j+1];

                // if ( t[j] == s[i] ) -> add match cnt of ( t[j] & s[i] ) with ( t[j-1] & s[i-1] )
                if(s[i] == t[j]) matchCntBeforeIdx_t[j+1] += prevMatchCntBeforeIdx_t;
            }
        }

        // return match cnt before ( t[size()] & s[size()] )
        return matchCntBeforeIdx_t[t.size()];
    }
};
```