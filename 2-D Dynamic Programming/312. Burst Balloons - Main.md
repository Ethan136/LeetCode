---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[312. Burst Balloons](https://leetcode.com/problems/burst-balloons/)

# Concept
- 直接解：**試著戳破 nums[i] 的氣球算分，然後剩餘氣球繼續試著找其中一個來戳**
- Divide & Conquer：**試著選 nums[i] 為最後戳的氣球，然後計算 nums[start : i - 1] 和 nums[i+1 : end] 這兩個區間的得分**
	- **這個做法不用記錄「哪個氣球被戳破」，也不用「直接改動 nums[i] 的氣球情況」**
	- 這個做法
- 特別注意
	- 一開始在 nums 左 / 右 各自塞一個 1 -> 作為超出邊界時候視為 num[i] = 1
	- **這題的 2D DP 無法壓縮**

# Answer：DFS Divide & Conquer - Brute Force
```Cpp
class Solution {
private:
    int maxCoinsInRange(vector<int>& nums, int startIdx, int endIdx) {

        // if start > end
        if(startIdx > endIdx) return 0;

        // init max coin
        int maxCoin = 0;

        // select boloon as "last burst in range"
        for(int i = startIdx; i <= endIdx; i++) {
            int lastBurstCoin = nums[startIdx-1] * nums[i] * nums[endIdx+1];
            int leftSideCoin = maxCoinsInRange(nums, startIdx, i-1);
            int rightSideCoin = maxCoinsInRange(nums, i+1, endIdx);

            maxCoin = max( maxCoin, leftSideCoin + lastBurstCoin + rightSideCoin);
        }

        // finish
        return maxCoin;
    }
public:
    int maxCoins(vector<int>& nums) {
        // extend start / end with 1
        nums.push_back(1);
        for(int i = nums.size()-1; i > 0; i--) swap(nums[i-1], nums[i]);
        nums.push_back(1);

        // check max coin with extended nums
        return maxCoinsInRange(nums, 1, nums.size()-2);
    }
};
```

# Answer：DFS Divide & Conquer + 2D DP
```Cpp
class Solution {
private:
    int maxCoinsInRange(vector<int>& nums, int startIdx, int endIdx, auto &maxCoinRecord) {

        // if the current setting had been calculated before
        if(maxCoinRecord[startIdx][endIdx] != -1) return maxCoinRecord[startIdx][endIdx];

        // if start > end
        if(startIdx > endIdx) return 0;

        // init max coin
        int maxCoin = 0;

        // select boloon as "last burst in range"
        for(int i = startIdx; i <= endIdx; i++) {
            int lastBurstCoin = nums[startIdx-1] * nums[i] * nums[endIdx+1];
            int leftSideCoin = maxCoinsInRange(nums, startIdx, i-1, maxCoinRecord);
            int rightSideCoin = maxCoinsInRange(nums, i+1, endIdx, maxCoinRecord);

            maxCoin = max( maxCoin, leftSideCoin + lastBurstCoin + rightSideCoin);
        }

        // record cacl result in DP
        maxCoinRecord[startIdx][endIdx] = maxCoin;

        // finish
        return maxCoin;
    }
public:
    int maxCoins(vector<int>& nums) {
        // extend start / end with 1
        nums.push_back(1);
        for(int i = nums.size()-1; i > 0; i--) swap(nums[i-1], nums[i]);
        nums.push_back(1);

        // maxCoin record in 2D DP
        vector<vector<int>> maxCoinRecord(nums.size(), vector<int>(nums.size(), -1));

        // check max coin with extended nums
        return maxCoinsInRange(nums, 1, nums.size()-2, maxCoinRecord);
    }
};
```

# Answer：BFS BottomUp Divide & Conquer + 2D DP
## V1：複習1st
**注意：2D DP 迭代順序**
- sub range start idx l 從 end 開始 -> nums[i] last 開始作為 start -> 這個 DP 不會用到兩邊的 DP，可以獨立計算
- sub range end idx r 從 l 開始 -> 從 valid start 開始計算

**注意：這題 2D DP 完全無法壓縮**
範例
- total range = index [1 to 7]
- start idx = 7 sub ranges
	- [7, 7] -> 2D DP start Idx = 7 / end idx = 7 -> *獨立計算*
- start idx = 6 sub ranges
	- [6, 6] -> 2D DP start idx 6 / end idx 6 -> 獨立計算
	- [6, 7] -> 2D DP start idx 6 / end idx 7 -> 用到sub range [6, 6] & [7, 7]
- start idx = 5 sub ranges
	- [5, 5] -> 2D DP start idx 5 / end idx 5 -> 獨立計算
	- [5, 6] -> 2D DP start idx 5 / end idx 6 -> 用到 sub range [5, 5] & [6, 6]
	- [5, 7] -> 2D DP start idx 5 / end idx 7 -> 用到 sub range [6, 7] / [5, 5] & [6, 6] / [5, 6]
```Cpp
class Solution {
private:
    int maxCoinsInRange(vector<int>& nums, int startIdx, int endIdx, auto &maxCoinRecord) {

        // try each sub-range within [start idx, end idx] - start idx
        for(int l = endIdx; l >= startIdx; l--) {

            // try each sub-range within [start idx, end idx] - end idx
            for(int r = l; r <= endIdx; r++) {

                // try to select a balloon as last burst one
                for(int lastBurstIdx = l; lastBurstIdx <= r; lastBurstIdx++) {

                    int leftSideCoin = maxCoinRecord[l][ lastBurstIdx - 1 ];

                    int lastBurstCoin = nums[l-1] * nums[ lastBurstIdx ] * nums[r+1];

                    int rightSideCoin = maxCoinRecord[ lastBurstIdx + 1 ][r];
                    
                    maxCoinRecord[l][r] = max(maxCoinRecord[l][r], leftSideCoin + lastBurstCoin + rightSideCoin);
                }
            }
        }

        // finish
        return maxCoinRecord[startIdx][endIdx];
    }
public:
    int maxCoins(vector<int>& nums) {

        // extend start / end with 1
        nums.push_back(1);
        for(int i = nums.size()-1; i > 0; i--) swap(nums[i-1], nums[i]);
        nums.push_back(1);

        // maxCoin record in 2D DP
        vector<vector<int>> maxCoinRecord(nums.size(), vector<int>(nums.size(), 0));

        // check max coin with extended nums
        return maxCoinsInRange(nums, 1, nums.size()-2, maxCoinRecord);
    }
};
```

## V2：複習2nd
```Cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {

        // append left & right balloon with coin 1
        nums.insert(nums.begin(), 1);
        nums.insert(nums.end(), 1);
        int startIdx = 1;
        int endIdx = nums.size() - 2;

        // to record the calculated max coin of sub-range
        // ths sub-range means if all balloons are still exist (including the balloons out of range)
        vector<vector<int>> maxCoinInSubRangeRec(nums.size(), vector<int>(nums.size(), 0));

        // sub-range[i, i+1] -> brute force check max
        //  (1) 1 * nums[i] * nums[i+1] + sub-range[i+1, i+1]
        //  (2) sub-range[i, i] + nums[i] * nums[i+1] * 1
        // sub-range[i-1, i+1] -> brute force check max
        //  (1) 1 * nums[i-1] * nums[i] +sub-range[i, i+1]
        //  (2) sub-range[i-1, i-1] + nums[i-1] * nums[i] * nums[i+1] + sub-range[i+1, i+1]
        //  (3) sub-range[i-1, i] + nums[i] * nums[i+1] * 1

        // try each left boundary of sub-range -> start from l = num[end idx] / r = num[end idx]
        for(int l = endIdx; l >= startIdx; l--) {

            // try each right boundary of sub-range
            for(int r = l; r <= endIdx; r++) {

                // max baloon burst within the sub-range (brute force try all)
                int maxCoinInSubRange = 0;
                for(int lastBurstIdx = l; lastBurstIdx <= r; lastBurstIdx++) {
                    int coinSubRange_L = maxCoinInSubRangeRec[l][lastBurstIdx-1];
                    int coinLastBurst = nums[l-1] * nums[lastBurstIdx] * nums[r+1];
                    int coinSubRange_R = maxCoinInSubRangeRec[lastBurstIdx+1][r];

                    int coinTotal = coinSubRange_L + coinLastBurst + coinSubRange_R;
                    maxCoinInSubRange = max(maxCoinInSubRange, coinTotal);
                }

                // record result
                maxCoinInSubRangeRec[l][r] = maxCoinInSubRange;
            }
        }

        // finish
        return maxCoinInSubRangeRec[startIdx][endIdx];
        
    }
};
```