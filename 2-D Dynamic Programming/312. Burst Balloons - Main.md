---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[312. Burst Balloons](https://leetcode.com/problems/burst-balloons/)

# Concept
- 直接解：**試著戳破 nums[i] 的氣球算分，然後剩餘氣球繼續試著找其中一個來戳**
- Divide & Conquer：**試著選 nums[i] 為最後戳的氣球，然後計算 nums[start : i - 1] 和 nums[i+1 : end] 這兩個區間的得分**
	- **這個做法不用記錄「哪個氣球被戳破」，也不用「直接改動 nums[i] 的氣球情況」**
	- 這個做法
- 特別注意
	- 一開始在 nums 左 / 右 各自塞一個 1 -> 作為超出邊界時候視為 num[i] = 1
	- **這題的 2D DP 無法壓縮**

# Answer：DFS Divide & Conquer - Brute Force
```Cpp
class Solution {
private:
    int maxCoinsInRange(vector<int>& nums, int startIdx, int endIdx) {

        // if start > end
        if(startIdx > endIdx) return 0;

        // init max coin
        int maxCoin = 0;

        // select boloon as "last burst in range"
        for(int i = startIdx; i <= endIdx; i++) {
            int lastBurstCoin = nums[startIdx-1] * nums[i] * nums[endIdx+1];
            int leftSideCoin = maxCoinsInRange(nums, startIdx, i-1);
            int rightSideCoin = maxCoinsInRange(nums, i+1, endIdx);

            maxCoin = max( maxCoin, leftSideCoin + lastBurstCoin + rightSideCoin);
        }

        // finish
        return maxCoin;
    }
public:
    int maxCoins(vector<int>& nums) {
        // extend start / end with 1
        nums.push_back(1);
        for(int i = nums.size()-1; i > 0; i--) swap(nums[i-1], nums[i]);
        nums.push_back(1);

        // check max coin with extended nums
        return maxCoinsInRange(nums, 1, nums.size()-2);
    }
};
```

# Answer：DFS Divide & Conquer + 2D DP
```Cpp
class Solution {
private:
    int maxCoinsInRange(vector<int>& nums, int startIdx, int endIdx, auto &maxCoinRecord) {

        // if the current setting had been calculated before
        if(maxCoinRecord[startIdx][endIdx] != -1) return maxCoinRecord[startIdx][endIdx];

        // if start > end
        if(startIdx > endIdx) return 0;

        // init max coin
        int maxCoin = 0;

        // select boloon as "last burst in range"
        for(int i = startIdx; i <= endIdx; i++) {
            int lastBurstCoin = nums[startIdx-1] * nums[i] * nums[endIdx+1];
            int leftSideCoin = maxCoinsInRange(nums, startIdx, i-1, maxCoinRecord);
            int rightSideCoin = maxCoinsInRange(nums, i+1, endIdx, maxCoinRecord);

            maxCoin = max( maxCoin, leftSideCoin + lastBurstCoin + rightSideCoin);
        }

        // record cacl result in DP
        maxCoinRecord[startIdx][endIdx] = maxCoin;

        // finish
        return maxCoin;
    }
public:
    int maxCoins(vector<int>& nums) {
        // extend start / end with 1
        nums.push_back(1);
        for(int i = nums.size()-1; i > 0; i--) swap(nums[i-1], nums[i]);
        nums.push_back(1);

        // maxCoin record in 2D DP
        vector<vector<int>> maxCoinRecord(nums.size(), vector<int>(nums.size(), -1));

        // check max coin with extended nums
        return maxCoinsInRange(nums, 1, nums.size()-2, maxCoinRecord);
    }
};
```

# Answer：BFS BottomUp Divide & Conquer + 2D DP
**注意：2D DP 迭代順序**
- sub range start idx l 從 end 開始 -> nums[i] last 開始作為 start -> 這個 DP 不會用到兩邊的 DP，可以獨立計算
- sub range end idx r 從 l 開始 -> 從 valid start 開始計算

**注意：這題 2D DP 完全無法壓縮**
範例
- total range = index [1 to 7]
- start idx = 7 sub ranges
	- [7, 7] -> 2D DP start Idx = 7 / end idx = 7 -> *獨立計算*
- start idx = 6 sub ranges
	- [6, 6] -> 2D DP start idx 6 / end idx 6 -> 獨立計算
	- [6, 7] -> 2D DP start idx 6 / end idx 7 -> 用到sub range [6, 6] & [7, 7]
- start idx = 5 sub ranges
	- [5, 5] -> 2D DP start idx 5 / end idx 5 -> 獨立計算
	- [5, 6] -> 2D DP start idx 5 / end idx 6 -> 用到 sub range [5, 5] & [6, 6]
	- [5, 7] -> 2D DP start idx 5 / end idx 7 -> 用到 sub range [6, 7] / [5, 5] & [6, 6] / [5, 6]
```Cpp
class Solution {
private:
    int maxCoinsInRange(vector<int>& nums, int startIdx, int endIdx, auto &maxCoinRecord) {

        // try each sub-range within [start idx, end idx] - start idx
        for(int l = endIdx; l >= startIdx; l--) {

            // try each sub-range within [start idx, end idx] - end idx
            for(int r = l; r <= endIdx; r++) {

                // try to select a balloon as last burst one
                for(int lastBurstIdx = l; lastBurstIdx <= r; lastBurstIdx++) {

                    int leftSideCoin = maxCoinRecord[l][ lastBurstIdx - 1 ];

                    int lastBurstCoin = nums[l-1] * nums[ lastBurstIdx ] * nums[r+1];

                    int rightSideCoin = maxCoinRecord[ lastBurstIdx + 1 ][r];
                    
                    maxCoinRecord[l][r] = max(maxCoinRecord[l][r], leftSideCoin + lastBurstCoin + rightSideCoin);
                }
            }
        }

        // finish
        return maxCoinRecord[startIdx][endIdx];
    }
public:
    int maxCoins(vector<int>& nums) {

        // extend start / end with 1
        nums.push_back(1);
        for(int i = nums.size()-1; i > 0; i--) swap(nums[i-1], nums[i]);
        nums.push_back(1);

        // maxCoin record in 2D DP
        vector<vector<int>> maxCoinRecord(nums.size(), vector<int>(nums.size(), 0));

        // check max coin with extended nums
        return maxCoinsInRange(nums, 1, nums.size()-2, maxCoinRecord);
    }
};
```