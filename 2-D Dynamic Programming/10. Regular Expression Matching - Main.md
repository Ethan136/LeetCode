---
ParentTask:
  - "[[2-d_dynamic_programming]]"
---

# LeetCode
[10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

# Concept
s 不會是 regex / p 可能是 regex

**檢查情況的時候，index 更新一次 update 1 個或 2個**
- 把 {'eng' + '.'} 或  {'\*' + '.'}  視為一組 -> idx 一次更新 2 個

**解答寫法裡面註解掉掉部分是假設 s 也可以是 regex**
**由於一旦檢查到 match 就 early return 回傳出去，所以其實只要記錄 false cond 即可**

分這幾個情況討論
- s[i] 和 p[j] match 彈性字元
	- s[i] 和 p[j] match + p[j] 是 regex
		- s[i] 不前進 + p[j] 前進（p[j] match any 視為 match 0）
		- s[i] 前進 + p[j] 不前進
		- s[i] 前進 + p[j] 前進
	- s[i] 和 p[j] not match + p[j] 是 regex
		- s[i] 不前進 + p[j] 前進
- s[i] 和 p[j] match 單一字元
	- s[i] 和 p[j] 各自前進一個
- s[i] 和 p[j] not match
	- return false

# Answer：Recursive + Burte Force
```Cpp
#define CHAR_MATCH_ANYTHING ('.')
#define CHAR_MATCH_ANY_TIME ('*')
#define STR_HAS_TWO_CHAR_AFTER(STR, i) (i < ( (int)(STR.size()) - 1 ))

#define MATCH_ANY_CHAR_ANY_LEN(STR, i) ( STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i] == CHAR_MATCH_ANYTHING) && (STR[i+1] == CHAR_MATCH_ANY_TIME) )

#define MATCH_ENG_CHAR_ANY_LEN(STR, i) ( STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i] != CHAR_MATCH_ANYTHING) && (STR[i+1] == CHAR_MATCH_ANY_TIME) )

#define MATCH_FLEXIBLE(STR, i) (STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i+1] == CHAR_MATCH_ANY_TIME))

#define MATCH_SINGLE_CHAR(STR, i) ( !STR_HAS_TWO_CHAR_AFTER(STR, i) || (STR[i+1] != CHAR_MATCH_ANY_TIME) )

#define CHECK_SPECIAL_CHAR(chr) ((chr == CHAR_MATCH_ANYTHING) || (chr == CHAR_MATCH_ANY_TIME))

#define MATCH_SINGLE_ENG_CHAR(STR, i) ( !CHECK_SPECIAL_CHAR(STR[i]) && !MATCH_ENG_CHAR_ANY_LEN(STR, i) )

#define MATCH_SINGLE_ANY_CHAR(STR, i) ( (STR[i] == CHAR_MATCH_ANYTHING) && !MATCH_ANY_CHAR_ANY_LEN(STR, i) )


#define CHECK_CHAR_MATCH_IN_REGEX(chr1, chr2) ( (chr1 == CHAR_MATCH_ANYTHING) || (chr2 == CHAR_MATCH_ANYTHING) || (chr1 == chr2) )

class Solution {
private:
    bool isMatchAnyAfter(string &str, int i) {

        // initialize the last index to check
        int checkLastIdx = (int)(str.size()) - 1;

        // check if there's any english char that should be matched at least once
        while(i <= checkLastIdx) {
            if(MATCH_FLEXIBLE(str, i)) {
                i += 2;
                continue;
            }

            // must match one "char (ENG or ANY)"
            return false;
        }

        // if check pass: string after str[i] can maych anything
        return true;
    }

    vector<pair<int, int>> getAllPossibleIdxShiftForNextMatch(string &s, int i, string &p, int j) {
        vector<pair<int, int>> result;
        // [THIS PART ASSUMES THAT s CAN ALSO HAS REGEX CHAR]: WHICH DOES NOT HAPPEN IN s
        /*
        if(MATCH_FLEXIBLE(s,i) && MATCH_FLEXIBLE(p,j)) {
            result.push_back({2, 2});
            result.push_back({2, 0});
            result.push_back({0, 2});
            return result;
        }

        bool matchStrPOneChar = MATCH_SINGLE_ANY_CHAR(p,j) || 
                              ( MATCH_SINGLE_ENG_CHAR(p,j) && CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j]) );
        if(MATCH_FLEXIBLE(s,i) && matchStrPOneChar) {
            result.push_back({2, 0});
            result.push_back({0, 1});
            result.push_back({2, 1});
            return result;
        }

        if(MATCH_FLEXIBLE(s,i) && !matchStrPOneChar) {
            result.push_back({2, 0});
            return result;
        }
        */

        bool matchStrSOneChar = MATCH_SINGLE_ANY_CHAR(s,i) || 
                              ( MATCH_SINGLE_ENG_CHAR(s,i) && CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j]) );
        if(matchStrSOneChar && MATCH_FLEXIBLE(p,j)) {
            result.push_back({0, 2});
            result.push_back({1, 0});
            result.push_back({1, 2});
            return result;
        }

        if(!matchStrSOneChar && MATCH_FLEXIBLE(p,j)) {
            result.push_back({0, 2});
            return result;
        }

        if(CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j])) {
            result.push_back({1, 1});
            return result;
        }

        return result;
    }

    bool isMatchAfter(string &s, int i, string &p, int j) {

        // [THIS PART ASSUMES THAT s CAN ALSO HAS REGEX CHAR]: WHICH DOES NOT HAPPEN IN s
        /*
        if(j >= p.size()) {
            return isMatchAnyAfter(s, i);
        }
        */

        if(j >= p.size()) {
            return (i >= s.size());
        }

        if(i >= s.size()) {
            return isMatchAnyAfter(p, j);
        }

        vector<pair<int, int>> idxShifts = getAllPossibleIdxShiftForNextMatch(s, i, p, j);
        if(idxShifts.empty()) return false;

        for(auto [shift_i, shift_j] : idxShifts) {
            if(isMatchAfter(s, i+shift_i, p, j+shift_j) == true) return true;
        }
        return false;
    }

public:
    bool isMatch(string s, string p) {
        return isMatchAfter(s, 0, p, 0);
    }
};
``` 


# Answer：Recursive + 2D DP
```Cpp
#define CHAR_MATCH_ANYTHING ('.')
#define CHAR_MATCH_ANY_TIME ('*')
#define STR_HAS_TWO_CHAR_AFTER(STR, i) (i < ( (int)(STR.size()) - 1 ))

#define MATCH_ANY_CHAR_ANY_LEN(STR, i) ( STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i] == CHAR_MATCH_ANYTHING) && (STR[i+1] == CHAR_MATCH_ANY_TIME) )

#define MATCH_ENG_CHAR_ANY_LEN(STR, i) ( STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i] != CHAR_MATCH_ANYTHING) && (STR[i+1] == CHAR_MATCH_ANY_TIME) )

#define MATCH_FLEXIBLE(STR, i) (STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i+1] == CHAR_MATCH_ANY_TIME))

#define CHECK_SPECIAL_CHAR(chr) ((chr == CHAR_MATCH_ANYTHING) || (chr == CHAR_MATCH_ANY_TIME))

#define MATCH_SINGLE_ENG_CHAR(STR, i) ( !CHECK_SPECIAL_CHAR(STR[i]) && !MATCH_ENG_CHAR_ANY_LEN(STR, i) )

#define MATCH_SINGLE_ANY_CHAR(STR, i) ( (STR[i] == CHAR_MATCH_ANYTHING) && !MATCH_ANY_CHAR_ANY_LEN(STR, i) )


#define CHECK_CHAR_MATCH_IN_REGEX(chr1, chr2) ( (chr1 == CHAR_MATCH_ANYTHING) || (chr2 == CHAR_MATCH_ANYTHING) || (chr1 == chr2) )

#define UN_CHECK_COND (-1)

class Solution {
private:
    bool isMatchAnyAfter(string &str, int i) {

        // initialize the last index to check
        int checkLastIdx = (int)(str.size()) - 1;

        // check if there's any english char that should be matched at least once
        while(i <= checkLastIdx) {
            if(MATCH_FLEXIBLE(str, i)) {
                i += 2;
                continue;
            }

            // must match one "char (ENG or ANY)"
            return false;
        }

        // if check pass: string after str[i] can maych anything
        return true;
    }

    vector<pair<int, int>> getAllPossibleIdxShiftForNextMatch(string &s, int i, string &p, int j) {
        vector<pair<int, int>> result;
        // [THIS PART ASSUMES THAT s CAN ALSO HAS REGEX CHAR]: WHICH DOES NOT HAPPEN IN s
        /*
        if(MATCH_FLEXIBLE(s,i) && MATCH_FLEXIBLE(p,j)) {
            result.push_back({2, 2});
            result.push_back({2, 0});
            result.push_back({0, 2});
            return result;
        }

        bool matchStrPOneChar = MATCH_SINGLE_ANY_CHAR(p,j) || 
                              ( MATCH_SINGLE_ENG_CHAR(p,j) && CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j]) );
        if(MATCH_FLEXIBLE(s,i) && matchStrPOneChar) {
            result.push_back({2, 0});
            result.push_back({0, 1});
            result.push_back({2, 1});
            return result;
        }

        if(MATCH_FLEXIBLE(s,i) && !matchStrPOneChar) {
            result.push_back({2, 0});
            return result;
        }
        */

        bool matchStrSOneChar = MATCH_SINGLE_ANY_CHAR(s,i) || 
                              ( MATCH_SINGLE_ENG_CHAR(s,i) && CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j]) );
        if(matchStrSOneChar && MATCH_FLEXIBLE(p,j)) {
            result.push_back({0, 2});
            result.push_back({1, 0});
            result.push_back({1, 2});
            return result;
        }

        if(!matchStrSOneChar && MATCH_FLEXIBLE(p,j)) {
            result.push_back({0, 2});
            return result;
        }

        if(CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j])) {
            result.push_back({1, 1});
            return result;
        }

        return result;
    }

    bool isMatchAfter(string &s, int i, string &p, int j, auto &matchRecord) {

        // [THIS PART ASSUMES THAT s CAN ALSO HAS REGEX CHAR]: WHICH DOES NOT HAPPEN IN s
        /*
        if(j >= p.size()) {
            return isMatchAnyAfter(s, i);
        }
        */

        if(j >= p.size()) {
            return (i >= s.size());
        }

        if(i >= s.size()) {
            return isMatchAnyAfter(p, j);
        }

        if(matchRecord[i][j] != UN_CHECK_COND) {
            return matchRecord[i][j];
        }

        vector<pair<int, int>> idxShifts = getAllPossibleIdxShiftForNextMatch(s, i, p, j);
        if(idxShifts.empty()) return false;

        for(auto [shift_i, shift_j] : idxShifts) {
            if(isMatchAfter(s, i+shift_i, p, j+shift_j, matchRecord)) {
                return (matchRecord[i][j] = true);
            }
        }
        return (matchRecord[i][j] = false);
    }

public:
    bool isMatch(string s, string p) {
        vector<vector<int>> matchRecord(s.size(), vector<int>(p.size(), UN_CHECK_COND));
        return isMatchAfter(s, 0, p, 0, matchRecord);
    }
};
```


# Answer：Recursive + 2D DP + Variable Delivery Optz
```Cpp
#define CHAR_MATCH_ANYTHING ('.')
#define CHAR_MATCH_ANY_TIME ('*')
#define STR_HAS_TWO_CHAR_AFTER(STR, i) (i < ( (int)(STR.size()) - 1 ))

#define MATCH_ANY_CHAR_ANY_LEN(STR, i) ( STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i] == CHAR_MATCH_ANYTHING) && (STR[i+1] == CHAR_MATCH_ANY_TIME) )

#define MATCH_ENG_CHAR_ANY_LEN(STR, i) ( STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i] != CHAR_MATCH_ANYTHING) && (STR[i+1] == CHAR_MATCH_ANY_TIME) )

#define MATCH_FLEXIBLE(STR, i) (STR_HAS_TWO_CHAR_AFTER(STR, i) && (STR[i+1] == CHAR_MATCH_ANY_TIME))

#define CHECK_SPECIAL_CHAR(chr) ((chr == CHAR_MATCH_ANYTHING) || (chr == CHAR_MATCH_ANY_TIME))

#define MATCH_SINGLE_ENG_CHAR(STR, i) ( !CHECK_SPECIAL_CHAR(STR[i]) && !MATCH_ENG_CHAR_ANY_LEN(STR, i) )

#define MATCH_SINGLE_ANY_CHAR(STR, i) ( (STR[i] == CHAR_MATCH_ANYTHING) && !MATCH_ANY_CHAR_ANY_LEN(STR, i) )


#define CHECK_CHAR_MATCH_IN_REGEX(chr1, chr2) ( (chr1 == CHAR_MATCH_ANYTHING) || (chr2 == CHAR_MATCH_ANYTHING) || (chr1 == chr2) )

#define UN_CHECK_COND (-1)

class Solution {
private:
    bool isMatchAnyAfter(string &str, int i) {

        // initialize the last index to check
        int checkLastIdx = (int)(str.size()) - 1;

        // check if there's any english char that should be matched at least once
        while(i <= checkLastIdx) {
            if(MATCH_FLEXIBLE(str, i)) {
                i += 2;
                continue;
            }

            // must match one "char (ENG or ANY)"
            return false;
        }

        // if check pass: string after str[i] can maych anything
        return true;
    }

    bool getAllPossibleIdxShiftForNextMatch(string &s, int i, string &p, int j, vector<pair<int, int>> &result) {
        result.clear();
        // [THIS PART ASSUMES THAT s CAN ALSO HAS REGEX CHAR]: WHICH DOES NOT HAPPEN IN s
        /*
        if(MATCH_FLEXIBLE(s,i) && MATCH_FLEXIBLE(p,j)) {
            result.push_back({2, 2});
            result.push_back({2, 0});
            result.push_back({0, 2});
            return true;
        }

        bool matchStrPOneChar = MATCH_SINGLE_ANY_CHAR(p,j) || 
                              ( MATCH_SINGLE_ENG_CHAR(p,j) && CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j]) );
        if(MATCH_FLEXIBLE(s,i) && matchStrPOneChar) {
            result.push_back({2, 0});
            result.push_back({0, 1});
            result.push_back({2, 1});
            return true;
        }

        if(MATCH_FLEXIBLE(s,i) && !matchStrPOneChar) {
            result.push_back({2, 0});
            return true;
        }
        */

        bool matchStrSOneChar = MATCH_SINGLE_ANY_CHAR(s,i) || 
                              ( MATCH_SINGLE_ENG_CHAR(s,i) && CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j]) );
        if(matchStrSOneChar && MATCH_FLEXIBLE(p,j)) {
            result.push_back({0, 2});
            result.push_back({1, 0});
            result.push_back({1, 2});
            return true;
        }

        if(!matchStrSOneChar && MATCH_FLEXIBLE(p,j)) {
            result.push_back({0, 2});
            return true;
        }

        if(CHECK_CHAR_MATCH_IN_REGEX(s[i],p[j])) {
            result.push_back({1, 1});
            return true;
        }

        return false;
    }

    bool isMatchAfter(string &s, int i, string &p, int j, auto &matchRecord, auto &idxShifts) {

        // [THIS PART ASSUMES THAT s CAN ALSO HAS REGEX CHAR]: WHICH DOES NOT HAPPEN IN s
        /*
        if(j >= p.size()) {
            return isMatchAnyAfter(s, i);
        }
        */

        if(j >= p.size()) {
            return (i >= s.size());
        }

        if(i >= s.size()) {
            return isMatchAnyAfter(p, j);
        }

        if(matchRecord[i][j] != UN_CHECK_COND) {
            return matchRecord[i][j];
        }

        if(!getAllPossibleIdxShiftForNextMatch(s, i, p, j, idxShifts)) {
            return false;
        }

        for(auto [shift_i, shift_j] : idxShifts) {
            if(isMatchAfter(s, i+shift_i, p, j+shift_j, matchRecord, idxShifts)) {
                return (matchRecord[i][j] = true);
            }
        }
        return (matchRecord[i][j] = false);
    }

public:
    bool isMatch(string s, string p) {
        vector<pair<int, int>> idxShifts;
        vector<vector<int>> matchRecord(s.size(), vector<int>(p.size(), UN_CHECK_COND));
        return isMatchAfter(s, 0, p, 0, matchRecord, idxShifts);
    }
};
```


# Answer：複習時候寫的 - 比較簡潔 Recursive + 2D DP
## V1：Recursive + DP 包兩層 func
- **如果 recursvie func 裡面的 early return 很多 -> 可以包兩層來記錄 DP，但這樣速度會變慢**
```Cpp
#define CHECK_MATCH_ANYTIME(STR, i) ( (i+1) < STR.size() ) && ( STR[i+1] == '*' )
#define CHECK_MATCH_ANYCHAR(STR, i)  ( STR[i] == '.' )
class Solution {
private:
    bool isMatchEmptyAferIdx(auto &p, int j) {
        while(j < p.size()) {
            // match any len
            if( CHECK_MATCH_ANYTIME(p, j) ) {
                j += 2;
                continue;
            }

            // false
            return false;
        }

        // check pass
        return true;
    }

    bool isMatchAfterIdx_Inner(auto &s, int i, auto &p, int j, auto &matchIdxCondRec) {

        if(i >= s.size()) {
            return isMatchEmptyAferIdx(p, j);
        }

        if(j >= p.size()) {
            return false;
        }

        // match cond of s[i] vs p[j]
        bool idxCharMatch = (s[i] == p[j]) || CHECK_MATCH_ANYCHAR(p, j);

        // if s[i] = p[j] & p match any length
        if( idxCharMatch && CHECK_MATCH_ANYTIME(p, j) ) {
            if(isMatchAfterIdx_Outer(s, i+1, p, j, matchIdxCondRec)) return true;
            if(isMatchAfterIdx_Outer(s, i+1, p, j+2, matchIdxCondRec)) return true;
            if(isMatchAfterIdx_Outer(s, i, p, j+2, matchIdxCondRec)) return true;
            return false;
        }

        // if s[i] != p[j] & p match any length
        if( !idxCharMatch & CHECK_MATCH_ANYTIME(p, j) ) {
            return isMatchAfterIdx_Outer(s, i, p, j+2, matchIdxCondRec);
        }

        // if s & p match single char
        if( idxCharMatch ) {
            return isMatchAfterIdx_Outer(s, i+1, p, j+1, matchIdxCondRec);
        }

        // if not match
        return false;
    }

    bool isMatchAfterIdx_Outer(auto &s, int i, auto &p, int j, auto &matchIdxCondRec) {
        if(matchIdxCondRec[i][j] != -1) {
            return matchIdxCondRec[i][j];
        }

        matchIdxCondRec[i][j] = isMatchAfterIdx_Inner(s, i, p, j, matchIdxCondRec);
        return matchIdxCondRec[i][j];
    }
public:
    bool isMatch(string s, string p) {
        vector<vector<int>> matchIdxCondRec(s.size()+1, vector<int>(p.size()+1, -1));
        return isMatchAfterIdx_Outer(s, 0, p, 0, matchIdxCondRec);
    }
};
```

## V2：Recursive + DP 只包一層 Func
```Cpp
#define CHECK_MATCH_ANYTIME(STR, i) ( (i+1) < STR.size() ) && ( STR[i+1] == '*' )
#define CHECK_MATCH_ANYCHAR(STR, i)  ( STR[i] == '.' )
class Solution {
private:
    bool isMatchEmptyAferIdx(auto &p, int j) {
        while(j < p.size()) {
            // match any len
            if( CHECK_MATCH_ANYTIME(p, j) ) {
                j += 2;
                continue;
            }

            // false
            return false;
        }

        // check pass
        return true;
    }

    bool isMatchAfterIdx(auto &s, int i, auto &p, int j, auto &matchIdxCondRec) {

        if(matchIdxCondRec[i][j] != -1) {
            return matchIdxCondRec[i][j];
        }

        if(i >= s.size()) {
            return (matchIdxCondRec[i][j] = isMatchEmptyAferIdx(p, j));
        }

        if(j >= p.size()) {
            return (matchIdxCondRec[i][j] = false);
        }

        // match cond of s[i] vs p[j]
        bool idxCharMatch = (s[i] == p[j]) || CHECK_MATCH_ANYCHAR(p, j);

        // if s[i] = p[j] & p match any length
        if( idxCharMatch && CHECK_MATCH_ANYTIME(p, j) ) {
            if(isMatchAfterIdx(s, i+1, p, j, matchIdxCondRec)) return true;
            if(isMatchAfterIdx(s, i+1, p, j+2, matchIdxCondRec)) return true;
            if(isMatchAfterIdx(s, i, p, j+2, matchIdxCondRec)) return true;
            return (matchIdxCondRec[i][j] = false);
        }

        // if s[i] != p[j] & p match any length
        if( !idxCharMatch & CHECK_MATCH_ANYTIME(p, j) ) {
            return (matchIdxCondRec[i][j] = isMatchAfterIdx(s, i, p, j+2, matchIdxCondRec));
        }

        // if s & p match single char
        if( idxCharMatch ) {
            return (matchIdxCondRec[i][j] = isMatchAfterIdx(s, i+1, p, j+1, matchIdxCondRec));
        }

        // if not match
        return (matchIdxCondRec[i][j] = false);
    }

public:
    bool isMatch(string s, string p) {
        vector<vector<int>> matchIdxCondRec(s.size()+1, vector<int>(p.size()+1, -1));
        return isMatchAfterIdx(s, 0, p, 0, matchIdxCondRec);
    }
};
```