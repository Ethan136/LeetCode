---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[46. Permutations](https://leetcode.com/problems/permutations/)

# Answer: 使用 swap 直接調整 nums 內容 (特殊做法，不好想)
- 直接 swap nums[] 裡面的 element，來達成「對原始數值進行重新排列」
	- **設定一個 startIdx，從這個之後一直把後面的 index 和 start index 進行 swap**
	- 每次 swap 一個 idnex，就繼續 call recursive func 來把「剩餘的數列進行 swap」
	- 終止條件為「swap startidx = nums.size()」
```Cpp
class Solution {
private:
    void permuteBySwapFromIdx(vector<int>& nums, int startIdx, vector<vector<int>> &result) {
        if(startIdx == nums.size()) {
            result.push_back(nums);
            return;
        }
        
        for(int i = startIdx; i < nums.size(); i++) {
            swap( nums[i], nums[startIdx] );
            
            permuteBySwapFromIdx(nums, startIdx+1, result);
            
            swap( nums[i], nums[startIdx] );
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        permuteBySwapFromIdx(nums, 0, result);
        return result;
    }
};
``` 

# Answer: 使用額外變數記錄每個 num 是否被使用
- **排列：每次從 nums 挑一個尚未使用的數字來用**
	- > **需要記錄「哪個數字還沒使用」**
- 記錄「數字是否使用」
	- 額外變數記錄
	- 在數字上面設定某個 bit -> **這個必須所有數字有共同沒用到的 bit，但如果有負數，則所有 bit 一定都會用到**
```Cpp

class Solution {
private:
    void permute(vector<int> &nums, vector<int> &curSubSet, int curSubSetLen, vector<bool> &curSubSetUsedIdx, 
                vector<vector<int>> &allSubSet) {

        if(curSubSetLen == nums.size()) {
            allSubSet.push_back(curSubSet);
            return;
        }

        for(int i = 0; i < nums.size(); i++) {
            // if this num had been used on the subset
            if(curSubSetUsedIdx[i]) continue;

            // set num
            curSubSet[curSubSetLen++] = nums[i];

            // flag the used index
            curSubSetUsedIdx[i] = true;

            // recursively add the remained nums in subset
            permute(nums, curSubSet, curSubSetLen, curSubSetUsedIdx, allSubSet);

            // clear the used index
            curSubSetUsedIdx[i] = false;

            // pop out current num from subset
            curSubSetLen--;
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        // need to record which index had been used
        // (1) additional variable -> use this
        // (2) set bit on the num -> CANT use this -> negative num would use almost all bits -> no un-used bits

        int curSubSetLen = 0;
        vector<int> curSubSet(nums.size());
        vector<bool> curSubSetUsedIdx(nums.size(), false);

        vector<vector<int>> allSubSet;
        permute(nums, curSubSet, curSubSetLen, curSubSetUsedIdx, allSubSet);

        return allSubSet;
    }
};
```
