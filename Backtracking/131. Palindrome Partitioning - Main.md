---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)

# Answer：使用 Recursive 檢查 [start, end] 區間為 palindrom 後，呼叫下一層 recursive 建構 [end ~] 以後的 partition

## V1 - Recursive + 沒有 memory optimize（會動態配置記憶體）
```Cpp
class Solution {
private:
    bool isSubStrPalinDrome(string s, int startIdx, int endIdx) {
        if(startIdx < 0 || startIdx >= s.size() || endIdx < 0 || endIdx >= s.size()) return false;
        for(int i = startIdx, j = endIdx; i < j; i++, j--) {
            if(s[i] != s[j]) return false;
        }
        return true;
    }
    
    void getAllPalinDromeSetFromStr(string s, int checkStartIdx, vector<string> &curResultSet, vector<vector<string>> &resultAllSets) {

        for(int checkEndIdx = checkStartIdx; checkEndIdx < s.size(); checkEndIdx++) {
            if( !isSubStrPalinDrome(s, checkStartIdx, checkEndIdx) ) continue;
            
            curResultSet.push_back( s.substr(checkStartIdx, (checkEndIdx-checkStartIdx+1)) );
            
            if(checkEndIdx == s.size()-1) {
                resultAllSets.push_back( curResultSet );
            }
            else {
                getAllPalinDromeSetFromStr(s, checkEndIdx+1, curResultSet, resultAllSets);
            }
            
            curResultSet.pop_back();
        }
        
    }
public:
    vector<vector<string>> partition(string s) {
        vector<string> curResultSet;
        vector<vector<string>> resultAllSets;
        getAllPalinDromeSetFromStr(s, 0, curResultSet, resultAllSets);
        return resultAllSets;
    }
};
``` 

## V2 - Recursive + memory optimize（記憶體一次分配，避免動態配置）
- **注意：如果要使用 cur solution vector + length var 來避免動態 push / pop vector -> 這個 cur solution vector 必須要先分配好足夠 size**
- **注意：current partition 用一個 vector\<int\> curPartitionEndIdx 來表示**
	- 這個代表每個 partition end index 對應原始 string 的哪個 index
	- 預設是 index 0 一定是「第一個 partition 的 start index」
	- 後續的 partition 的 start index 為「前一個 partition 的 end index + 1」
	- partitions = \[0, 1st end idx\] \[1st end idx+1, 2nd end idx\], \[2nd end idx+1, 3rd end idx\] ...
- **注意：C++ string 的 substring 語法 `s.substr(startIdx, length)`**
```Cpp
class Solution {
private:
    bool checkPalindrome(string &s, int startIdx, int endIdx) {
        if(startIdx < 0 || endIdx >= s.size()) return false;
        if(startIdx > endIdx) return false;

        for(int l = startIdx, r = endIdx; l < r; l++, r--) {
            if(s[l] != s[r]) return false;
        }
        return true;
    }

    void getPartitionSet(string &s, int startIdx, auto& curPartitionEndIdx, int curPartitionLen, auto &partitionSet) {
        if(startIdx >= s.size()) {
            partitionSet.push_back(vector<string>(curPartitionLen));
            auto &newPartition = partitionSet.back();

            for(int startIdx = 0, i = 0;
                i < curPartitionLen;
                startIdx = curPartitionEndIdx[i] + 1, i++) {
                
                int subStrLen = curPartitionEndIdx[i] - startIdx + 1;
                newPartition[i] = s.substr(startIdx, subStrLen);
            }
            return;
        }

        for(int endIdx = startIdx; endIdx < s.size(); endIdx++) {
            if(!checkPalindrome(s, startIdx, endIdx)) continue;

            curPartitionEndIdx[curPartitionLen++] = endIdx;

            getPartitionSet(s, endIdx+1, curPartitionEndIdx, curPartitionLen, partitionSet);
            
            curPartitionLen--;
        }
    }
public:
    vector<vector<string>> partition(string s) {

        int curPartitionLen = 0;
        vector<int> curPartitionEndIdx(s.size());

        vector<vector<string>> partitionSet;
        getPartitionSet(s, 0, curPartitionEndIdx, curPartitionLen, partitionSet);

        return partitionSet;
    }
};
```


## V3 - Recursive + memory optimize + 2D DP (這個 2D DP 其實沒啥用，這版本只是練習)
- **這邊 2D DP 其實用不到，因為一個「start idx / end idx」配置，只會檢查一次**
```Cpp
#define NOT_CHECKED_YET (-1)
#define PARTITION_CHECK_PASS    (1)
#define PARTITION_CHECK_FAIL    (0)
class Solution {
private:
    bool checkPalindrome(string &s, int startIdx, int endIdx, auto &partitionCheckMemo) {
        if(startIdx < 0 || endIdx >= s.size()) return false;
        if(startIdx > endIdx) return false;

        if(partitionCheckMemo[startIdx][endIdx] != NOT_CHECKED_YET) {
            return (partitionCheckMemo[startIdx][endIdx] == PARTITION_CHECK_PASS);
        }

        for(int l = startIdx, r = endIdx; l < r; l++, r--) {
            if(s[l] == s[r]) continue;

            partitionCheckMemo[startIdx][endIdx] = PARTITION_CHECK_FAIL;
            return false;
        }

        partitionCheckMemo[startIdx][endIdx] = PARTITION_CHECK_PASS;
        return true;
    }

    void getPartitionSet(string &s, int startIdx, 
                        auto& curPartitionEndIdx, int curPartitionLen, auto &partitionCheckMemo, 
                        auto &partitionSet) {

        if(startIdx >= s.size()) {
            partitionSet.push_back(vector<string>(curPartitionLen));
            auto &newPartition = partitionSet.back();

            for(int startIdx = 0, i = 0;
                i < curPartitionLen;
                startIdx = curPartitionEndIdx[i] + 1, i++) {
                
                int subStrLen = curPartitionEndIdx[i] - startIdx + 1;
                newPartition[i] = s.substr(startIdx, subStrLen);
            }
            return;
        }

        for(int endIdx = startIdx; endIdx < s.size(); endIdx++) {
            if(!checkPalindrome(s, startIdx, endIdx, partitionCheckMemo)) continue;

            curPartitionEndIdx[curPartitionLen++] = endIdx;

            getPartitionSet(s, endIdx+1, curPartitionEndIdx, curPartitionLen, partitionCheckMemo, partitionSet);
            
            curPartitionLen--;
        }
    }
public:
    vector<vector<string>> partition(string s) {

        int curPartitionLen = 0;
        vector<int> curPartitionEndIdx(s.size());

        vector<vector<int>> partitionCheckMemo(s.size(), vector<int>(s.size(), NOT_CHECKED_YET));

        vector<vector<string>> partitionSet;
        getPartitionSet(s, 0, curPartitionEndIdx, curPartitionLen, partitionCheckMemo, partitionSet);

        return partitionSet;
    }
};
```