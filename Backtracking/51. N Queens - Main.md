---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[51. N Queens](https://leetcode.com/problems/n-queens/)

# Concept
- **queen 可以斜走 -> 難度在於如何把「每個斜方向用一個數值表示」 -> 也就是要把 (row, col) Mapping 為對角線 index**
- 對角線 index -> **對角線分為正 / 負**
	- 正對角線： index = row + col
	- 負對角線： index = row - col + (n-1)
		- 用 col - row + (n-1) 也可以
		- (n-1) 是為了讓 col - row 最小為 0 做的平移 -> *平移 max index 的數值*

# Answer V1：使用自訂物件 -> 第一次寫寫太複雜
```Cpp
#define POS_CHAR_WITHOUT_Q ('.')
#define POS_CHAR_WITH_Q     ('Q')
#define CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, n) (row + col)
#define CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, n) (row - col + n - 1)
#define BIT(N) (1 << (N))
class QueenSafePosInfo {
private:
    // the max board size N = 9 -> can use bitmap to record the conditiion
    int m_rowWithQBMP = 0;
    int m_colWithQBMP = 0;
    int m_PosDiagWithQBMP = 0;
    int m_NegDiagWithQBMP = 0;

    // board size
    int m_BoardSize = 0;

public:
    QueenSafePosInfo(int n) {
        m_BoardSize = n;
    }

    int getBoardSize() {
        return m_BoardSize;
    }

    bool checkPosAttackByQ(int row, int col) {
        // attack by row
        if(m_rowWithQBMP & BIT(row)) return true;

        // attack by col
        if(m_colWithQBMP & BIT(col)) return true;

        // attack by positive diagonal with (row + col = const)
        if(m_PosDiagWithQBMP & BIT(CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, m_BoardSize)) ) return true;

        // attack by negative diagonal with (row - col = const)
        if(m_NegDiagWithQBMP & BIT(CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, m_BoardSize)) ) return true;

        // not attack by any condition
        return false;
    }

    bool safeSetQPosition(int row, int col) {
        // if the position is not safe
        if(checkPosAttackByQ(row, col)) return false;

        // record the row that will be attacked
        m_rowWithQBMP |= BIT(row);

        // record the col that will be attacked
        m_colWithQBMP |= BIT(col);

        // record the position diagonal that will be attacked
        m_PosDiagWithQBMP |= BIT(CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, m_BoardSize));

        // record the negative diagonal that will be attacked
        m_NegDiagWithQBMP |= BIT(CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, m_BoardSize));

        // finish
        return true;
    }

    void clrQPosition(int row, int col) {

        // clear the row that will be attacked
        m_rowWithQBMP &= ~BIT(row);

        // clear the col that will be attacked
        m_colWithQBMP &= ~BIT(col);

        // clear the position diagonal that will be attacked
        m_PosDiagWithQBMP &= ~BIT(CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, m_BoardSize));

        // clear the negative diagonal that will be attacked
        m_NegDiagWithQBMP &= ~BIT(CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, m_BoardSize));
    }

};

class Solution {
private:

    void trySafelySetAllQueenFromRow(int row, QueenSafePosInfo& QPosInfo, vector<string> &curResult, vector<vector<string>>& resultPosSet) {

        // NOTE: the curResult should be init with "All position set with No Queen" before firstly calling this func

        // if all the previous rows had been set finished
        if(row == QPosInfo.getBoardSize()) {
            resultPosSet.push_back( curResult );
            return;
        }

        // try to set Queen on current row
        for(int col = 0; col < QPosInfo.getBoardSize(); col++) {
            
            // try to put Queen on the position safely
            if(!QPosInfo.safeSetQPosition(row, col)) continue;

            // mark Q position of result
            curResult[row][col] = POS_CHAR_WITH_Q;

            // try to put Queen from the next row
            trySafelySetAllQueenFromRow(row+1, QPosInfo, curResult, resultPosSet);

            // clear Q position mark from the result before trying the next column
            curResult[row][col] = POS_CHAR_WITHOUT_Q;

            // clear Queen position from the posInfo
            QPosInfo.clrQPosition(row, col);
        }
    }

public:
    vector<vector<string>> solveNQueens(int n) {

        // initialize the objec to record the Queen position
        QueenSafePosInfo QPosInfo(n);

        // init the current result with all char on board set as "no queen"
        vector<string> curResult( n, string(n, POS_CHAR_WITHOUT_Q) );

        // the set for all results
        vector<vector<string>> resultPosSet;
        
        // do DFS traverse from row to row until the end of the board
        trySafelySetAllQueenFromRow(0, QPosInfo, curResult, resultPosSet);

        // return results set
        return resultPosSet;
    }
};
```

# Answer V2：不使用自訂物件 + 使用 Bitmap 記憶體最佳化 -> 直覺簡單
```Cpp
#define CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, n) (row + col)
#define CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, n) (row - col + (n - 1))

#define BIT(_N_)                    (1 << (_N_))
#define CHK_BITMAP(_BITMAP_, _N_)   (_BITMAP_ & BIT(_N_))
#define SET_BITMAP(_BITMAP_, _N_)   (_BITMAP_ |= BIT(_N_))
#define CLR_BITMAP(_BITMAP_, _N_)   (_BITMAP_ &= ~BIT(_N_))
#define PRINT_VAR(_VAR_)            cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    void solveNQueens(int n, int row, int usedColBitMap, int usedPosDiagBitMap, int usedNegDiagBitMap, 
                    vector<string> &curSolution, vector<vector<string>> &solutionSet) {

        if(row == n) {
            solutionSet.push_back(curSolution);
            return;
        }

        for(int col = 0; col < n; col++) {

            int posDiagIdx = CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, n);
            int negDiagIdx = CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, n);

            if(CHK_BITMAP(usedColBitMap, col)) continue;
            if(CHK_BITMAP(usedPosDiagBitMap, posDiagIdx)) continue;
            if(CHK_BITMAP(usedNegDiagBitMap, negDiagIdx)) continue;

            SET_BITMAP(usedColBitMap, col);
            SET_BITMAP(usedPosDiagBitMap, posDiagIdx);
            SET_BITMAP(usedNegDiagBitMap, negDiagIdx);

            curSolution[row][col] = 'Q';

            solveNQueens(n, row+1, usedColBitMap, usedPosDiagBitMap, usedNegDiagBitMap, curSolution, solutionSet);

            curSolution[row][col] = '.';

            CLR_BITMAP(usedColBitMap, col);
            CLR_BITMAP(usedPosDiagBitMap, posDiagIdx);
            CLR_BITMAP(usedNegDiagBitMap, negDiagIdx);
        }

    }
public:
    vector<vector<string>> solveNQueens(int n) {
        
        int usedColBitMap = 0, usedPosDiagBitMap = 0, usedNegDiagBitMap = 0;
        vector<string> curSolution(n, string(n, '.'));

        int row = 0;
        vector<vector<string>> solutionSet;
        solveNQueens(n, row, usedColBitMap, usedPosDiagBitMap, usedNegDiagBitMap, curSolution, solutionSet);
        return solutionSet;
    }
};
```