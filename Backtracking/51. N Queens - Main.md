---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[51. N Queens](https://leetcode.com/problems/n-queens/)

# Concept
- **queen 可以斜走 -> 難度在於如何把「每個斜方向用一個數值表示」 -> 也就是要把 (row, col) Mapping 為對角線 index**
- 對角線 index -> **對角線分為正 / 負**
	- 正對角線： index = row + col
	- 負對角線： index = row - col + (n-1)
		- 用 col - row + (n-1) 也可以
		- (n-1) 是為了讓 col - row 最小為 0 做的平移 -> *平移 max index 的數值*

# Answer V1：使用自訂物件 -> 第一次寫寫太複雜
```Cpp
#define POS_CHAR_WITHOUT_Q ('.')
#define POS_CHAR_WITH_Q     ('Q')
#define CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, n) (row + col)
#define CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, n) (row - col + n - 1)
#define BIT(N) (1 << (N))
class QueenSafePosInfo {
private:
    // the max board size N = 9 -> can use bitmap to record the conditiion
    int m_rowWithQBMP = 0;
    int m_colWithQBMP = 0;
    int m_PosDiagWithQBMP = 0;
    int m_NegDiagWithQBMP = 0;

    // board size
    int m_BoardSize = 0;

public:
    QueenSafePosInfo(int n) {
        m_BoardSize = n;
    }

    int getBoardSize() {
        return m_BoardSize;
    }

    bool checkPosAttackByQ(int row, int col) {
        // attack by row
        if(m_rowWithQBMP & BIT(row)) return true;

        // attack by col
        if(m_colWithQBMP & BIT(col)) return true;

        // attack by positive diagonal with (row + col = const)
        if(m_PosDiagWithQBMP & BIT(CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, m_BoardSize)) ) return true;

        // attack by negative diagonal with (row - col = const)
        if(m_NegDiagWithQBMP & BIT(CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, m_BoardSize)) ) return true;

        // not attack by any condition
        return false;
    }

    bool safeSetQPosition(int row, int col) {
        // if the position is not safe
        if(checkPosAttackByQ(row, col)) return false;

        // record the row that will be attacked
        m_rowWithQBMP |= BIT(row);

        // record the col that will be attacked
        m_colWithQBMP |= BIT(col);

        // record the position diagonal that will be attacked
        m_PosDiagWithQBMP |= BIT(CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, m_BoardSize));

        // record the negative diagonal that will be attacked
        m_NegDiagWithQBMP |= BIT(CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, m_BoardSize));

        // finish
        return true;
    }

    void clrQPosition(int row, int col) {

        // clear the row that will be attacked
        m_rowWithQBMP &= ~BIT(row);

        // clear the col that will be attacked
        m_colWithQBMP &= ~BIT(col);

        // clear the position diagonal that will be attacked
        m_PosDiagWithQBMP &= ~BIT(CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, m_BoardSize));

        // clear the negative diagonal that will be attacked
        m_NegDiagWithQBMP &= ~BIT(CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, m_BoardSize));
    }

};

class Solution {
private:

    void trySafelySetAllQueenFromRow(int row, QueenSafePosInfo& QPosInfo, vector<string> &curResult, vector<vector<string>>& resultPosSet) {

        // NOTE: the curResult should be init with "All position set with No Queen" before firstly calling this func

        // if all the previous rows had been set finished
        if(row == QPosInfo.getBoardSize()) {
            resultPosSet.push_back( curResult );
            return;
        }

        // try to set Queen on current row
        for(int col = 0; col < QPosInfo.getBoardSize(); col++) {
            
            // try to put Queen on the position safely
            if(!QPosInfo.safeSetQPosition(row, col)) continue;

            // mark Q position of result
            curResult[row][col] = POS_CHAR_WITH_Q;

            // try to put Queen from the next row
            trySafelySetAllQueenFromRow(row+1, QPosInfo, curResult, resultPosSet);

            // clear Q position mark from the result before trying the next column
            curResult[row][col] = POS_CHAR_WITHOUT_Q;

            // clear Queen position from the posInfo
            QPosInfo.clrQPosition(row, col);
        }
    }

public:
    vector<vector<string>> solveNQueens(int n) {

        // initialize the objec to record the Queen position
        QueenSafePosInfo QPosInfo(n);

        // init the current result with all char on board set as "no queen"
        vector<string> curResult( n, string(n, POS_CHAR_WITHOUT_Q) );

        // the set for all results
        vector<vector<string>> resultPosSet;
        
        // do DFS traverse from row to row until the end of the board
        trySafelySetAllQueenFromRow(0, QPosInfo, curResult, resultPosSet);

        // return results set
        return resultPosSet;
    }
};
```

# Answer V2：不使用自訂物件 + 使用 Bitmap 記憶體最佳化 -> 直覺簡單
```Cpp
#define CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, n) (row + col)
#define CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, n) (row - col + (n - 1))

#define BIT(_N_)                    (1 << (_N_))
#define CHK_BITMAP(_BITMAP_, _N_)   (_BITMAP_ & BIT(_N_))
#define SET_BITMAP(_BITMAP_, _N_)   (_BITMAP_ |= BIT(_N_))
#define CLR_BITMAP(_BITMAP_, _N_)   (_BITMAP_ &= ~BIT(_N_))
#define PRINT_VAR(_VAR_)            cout << #_VAR_ << ": " << _VAR_ << endl;
class Solution {
private:
    void solveNQueens(int n, int row, int usedColBitMap, int usedPosDiagBitMap, int usedNegDiagBitMap, 
                    vector<string> &curSolution, vector<vector<string>> &solutionSet) {

        if(row == n) {
            solutionSet.push_back(curSolution);
            return;
        }

        for(int col = 0; col < n; col++) {

            int posDiagIdx = CONVERT_ROW_COL_TO_POS_DIAG_IDX(row, col, n);
            int negDiagIdx = CONVERT_ROW_COL_TO_NEG_DIAG_IDX(row, col, n);

            if(CHK_BITMAP(usedColBitMap, col)) continue;
            if(CHK_BITMAP(usedPosDiagBitMap, posDiagIdx)) continue;
            if(CHK_BITMAP(usedNegDiagBitMap, negDiagIdx)) continue;

            SET_BITMAP(usedColBitMap, col);
            SET_BITMAP(usedPosDiagBitMap, posDiagIdx);
            SET_BITMAP(usedNegDiagBitMap, negDiagIdx);

            curSolution[row][col] = 'Q';

            solveNQueens(n, row+1, usedColBitMap, usedPosDiagBitMap, usedNegDiagBitMap, curSolution, solutionSet);

            curSolution[row][col] = '.';

            CLR_BITMAP(usedColBitMap, col);
            CLR_BITMAP(usedPosDiagBitMap, posDiagIdx);
            CLR_BITMAP(usedNegDiagBitMap, negDiagIdx);
        }

    }
public:
    vector<vector<string>> solveNQueens(int n) {
        
        int usedColBitMap = 0, usedPosDiagBitMap = 0, usedNegDiagBitMap = 0;
        vector<string> curSolution(n, string(n, '.'));

        int row = 0;
        vector<vector<string>> solutionSet;
        solveNQueens(n, row, usedColBitMap, usedPosDiagBitMap, usedNegDiagBitMap, curSolution, solutionSet);
        return solutionSet;
    }
};
```

# Answer：V3 - 複習2nd

## V3.1 - 暴力填色
- 一次 try 一個 row
- row 裏面依序檢查每個 col
	- **每走到一個格子，如果可以放 Queen，則放 queen，並且從這個 row / col 開始，往『左下』、『右下』、『正下』標記『路徑上有 queen 的 count ++』**
```Cpp
class Solution {
private:
    void travAndModifyQueenCntFromPos(auto &board, int row, int col, int modifyCnt) {
        // traverse pos
        int markRow, markCol;

        // mark in column direction
        markRow = row;
        while(markRow < board.size()) {
            board[markRow++][col] += modifyCnt;
        }

        // mark in positive diag direction
        markRow = row;
        markCol = col;
        while((markRow < board.size()) && (markCol < board[markRow].size())) {
            board[markRow++][markCol++] += modifyCnt;
        }

        // mark in negative diag direction
        markRow = row;
        markCol = col;
        while((markRow < board.size()) && (markCol >= 0)) {
            board[markRow++][markCol--] += modifyCnt;
        }
    }
    void travAndGetAllQueenSet(auto &boardQueenCnt, int row, vector<string> &curSet, vector<vector<string>> &allSets) {
        // if traversed to last row
        if(row == boardQueenCnt.size()) {
            allSets.push_back(curSet);
            return;
        }

        // initialize arrangement for current row
        curSet.push_back( string(boardQueenCnt[row].size(), '.') );

        // check each pos on current row
        for(int col = 0; col < boardQueenCnt[row].size(); col++) {
            if(boardQueenCnt[row][col] > 0) continue;

            travAndModifyQueenCntFromPos(boardQueenCnt, row, col, 1);

            curSet[row][col] = 'Q';
            travAndGetAllQueenSet(boardQueenCnt, row+1, curSet, allSets);
            curSet[row][col] = '.';

            travAndModifyQueenCntFromPos(boardQueenCnt, row, col, -1);
        }

        // pop out traverse record of current row
        curSet.pop_back();
    }
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<int>> boardQueenCnt(n, vector<int>(n, 0));
        vector<string> curSet;
        vector<vector<string>> allSets;

        travAndGetAllQueenSet(boardQueenCnt, 0, curSet, allSets);
        return allSets;
    }
};
```

## V3.2 - 使用 vector 記錄 column，並且用 map 記錄對角線
- **注意：正 / 負 對角線，要用不同的 map**
```Cpp
class Solution {
private:
    void travAndGetAllQueenSet(int n, int row, auto &curSet, auto &allSets, auto &colHasQueen, auto &posDiagHasQueen, auto &negDiagHasQueen) {
        // if traversed to last row
        if(row == n) {
            allSets.push_back(curSet);
            return;
        }

        // initialize arrangement for current row
        curSet.push_back( string(n, '.') );

        // check each pos on current row
        for(int col = 0; col < n; col++) {
            if(colHasQueen[col]) continue;
            if(posDiagHasQueen[row + col]) continue;
            if(negDiagHasQueen[row - col]) continue;

            colHasQueen[col] = true;
            posDiagHasQueen[row + col] = true;
            negDiagHasQueen[row - col] = true;

            curSet[row][col] = 'Q';
            travAndGetAllQueenSet(n, row+1, curSet, allSets, colHasQueen, posDiagHasQueen, negDiagHasQueen);
            curSet[row][col] = '.';

            negDiagHasQueen[row - col] = false;
            posDiagHasQueen[row + col] = false;
            colHasQueen[col] = false;
        }

        // pop out traverse record of current row
        curSet.pop_back();
    }
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<bool> colHasQueen(n, false);
        unordered_map<int, bool> posDiagHasQueen;
        unordered_map<int, bool> negDiagHasQueen;

        vector<string> curSet;
        vector<vector<string>> allSets;

        travAndGetAllQueenSet(n, 0, curSet, allSets, colHasQueen, posDiagHasQueen, negDiagHasQueen);
        return allSets;
    }
};
```