---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[78. Subsets](https://leetcode.com/problems/subsets/)

# Answer V1：不使用額外 vector 儲存 current result - 比較不好想
- **直接把處理中的 result 存到 subset，並且用現有的 subset 內容展開後續的 result**
- 缺點是用到很多 push back -> **有大量動態記憶體配置**
- **而且從處理中的 result 展開後續的 result 內容，會導致「無法預先知道每個 result 的總長度，而無法預先保留精確空間**
- 雖然不用額外 vector 存 current result，但整體來說記憶體效能可能是比較差的
```Cpp
class Solution {
private:
    
    void createSubSet(vector<int>& nums, int startNumIdxToCreateSubSet, vector<vector<int>>& subSetsAll) {
       
        // record the index of the base for new subset
        int expandSubsetFromResultIdx = subSetsAll.size() - 1;
        
        // produce subset with certain element in nums as pivot element
        for(int i = startNumIdxToCreateSubSet; i < nums.size(); i++) {
        
            // init new result from base subset
            subSetsAll.push_back( subSetsAll[expandSubsetFromResultIdx] );
            
            // append new result with element
            subSetsAll.back().push_back( nums[i] );
            
            // create subset with one-more element
            createSubSet(nums, (i+1), subSetsAll);
            
        }   
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {

        // init result with empty subset
        vector<vector<int>> subSetsAll = {{}};
        
        // produce subset starting from certain index
        createSubSet(nums, 0, subSetsAll);
        
        // finish
        return subSetsAll;
    }
};
``` 

# Answer V2：使用額外 vector 儲存 current result - 比較好想
- **處理完成前的內容，額外存到一個 temp vector 裡面**
- **避免對 temp vector 做動態記憶體配置**
	- 這個 temp vector 可以預先分配長度 = nums.size
	- 這個 temp vector 可以透過額外一個 curResultLen 來作為 store index
	- 這個 temp vector 其實是當作一個 stack 來使用
- 處理完成一個 temp vector 後，再把它存到 subSet 裡面
- 由於是一個 temp vector 重複使用
	- 每次處理一個 num[i] 並且 traverse to end 後 return 回來 -> **需要把 num[i] 執行 pop out -> 也就是 curResultLen --**
```Cpp
class Solution {
private:
    void createSubSets(vector<int> &nums, int startIdx, vector<int> &curResult, int curResultLen, vector<vector<int>> &resultSet) {
        for(int i = startIdx; i < nums.size(); i++) {
            curResult[curResultLen++] = nums[i];
            createSubSets(nums, i+1, curResult, curResultLen, resultSet);
            curResultLen--;
        }
        
        resultSet.push_back({});
        vector<int> &resultVec = resultSet.back();

        if(curResultLen) {
            resultVec.resize(curResultLen);
            for(int i = 0; i < curResultLen; i++) resultVec[i] = curResult[i];
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int curResultLen = 0;
        vector<int> curResult(nums.size(), 0);

        int startIdx = 0;
        vector<vector<int>> resultSet;
        createSubSets(nums, startIdx, curResult, curResultLen, resultSet);

        return resultSet;
    }
};
```