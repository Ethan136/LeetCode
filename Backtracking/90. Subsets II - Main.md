---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[90. Subsets II](https://leetcode.com/problems/subsets-ii/)

# Concept
- 有重複的數字可以用 1 to n 次，又要避免 subset 重複 -> **原本數列必須排序**
- 顯式重複數字處理：在每個 num[i] 處理的情況中，再包一層 loop 處理重複 1 to n 的情況，處理完後 i 跳到「下一個不重複數字」
	- **如果數字重複，則處理的時候在 inner loop 中處理重複數字的情況 -> **不要把處理中的重複數字帶到下一層 recursive，避免產生重複的 subset**
- 隱式重複數字處理：在每個 num[i] 處理情況中，直接 func call 下一層 recursive，並且每一層 recursive 只「放入一個重複的 num[i]」
	- **如果數字重複，則一層 recursive 只處理一次這個數字（避免產生重複 sub-set），其餘重複次數丟到下一層 recursive 進行處理**
	- **比較不好想，雖然 code 比較少**
	- 類似說 [1, 2, 2, 2, 3]
		- layer0: 放入 1
			- layer1: 放入 2(1)
				- layer2: 放入 2(2)
					- layer3: 放入 2(3)
						- layer4: 放入 3 -> [1, 2, 2, 3, 3]
					- layer3: 放入 3 -> [1, 2, 2, 3]
				- layer2: 試著放入 2(3) -> 和前一個重複 -> 跳過
				- layer2: 放入 3 -> [1, 2, 3]
			- layer1: 試著放入 2(2) -> 和前一個重複 -> 跳過
			- layer1: 試著放入 2(3) -> 和前一個重複 -> 跳過
			- layer1 放入3 -> [1, 3]
		- layer0: 放入 2 ...

# Answer V1：使用處理中的結果展開後續的結果 + 隱式表示重複數字處理
- **隱式表示重複數字使用情況**
- **比較不好想，但 code 比較少，但用比較多動態記憶體配置**
```Cpp
class Solution {
private:
    void subsetsWithDupFromStartIdx(int startIdx, vector<int>& nums, vector<vector<int>> &subSetsAll) {
        if(startIdx >= nums.size()) return;
        
        int expandSubSetsFromPrevIdx = subSetsAll.size()-1;
        for(int i = startIdx; i < nums.size(); i++) {
            if(i > startIdx && nums[i] == nums[i-1]) continue;
            
            subSetsAll.push_back( subSetsAll[expandSubSetsFromPrevIdx] );
            subSetsAll.back().push_back( nums[i] );
            
            subsetsWithDupFromStartIdx((i+1), nums, subSetsAll);
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        // sort thr number
        sort(nums.begin(), nums.end());
        
        // init the result with empth subSet
        vector<vector<int>> subSetsAll = {{}};
        
        // create subsets
        subsetsWithDupFromStartIdx(0, nums, subSetsAll);
        
        // finish
        return subSetsAll;
    }
};
``` 

# Answer V2-3：用一個暫存變數記錄當前結果 + 顯式表示重複數字處理
## V2：自訂資料結構整理重複數字的情況
```Cpp
class Solution {
private:
    struct numInfo {
        int val;
        int repeatCnt;
    };

    void createSubSets(auto &numsInfo, int startIdx, vector<int> &curResult, int curResultLen, vector<vector<int>> &resultSet) {
        for(int i = startIdx; i < numsInfo.size(); i++) {

            for(int numCnt = 1; numCnt <= numsInfo[i].repeatCnt; numCnt++) {

                int n = numCnt;
                while(n--) curResult[curResultLen++] = numsInfo[i].val;

                createSubSets(numsInfo, i+1, curResult, curResultLen, resultSet);

                n = numCnt;
                while(n--) curResultLen--;
            }
        }
        
        resultSet.push_back({});
        vector<int> &resultVec = resultSet.back();

        if(curResultLen) {
            resultVec.resize(curResultLen);
            for(int i = 0; i < curResultLen; i++) resultVec[i] = curResult[i];
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        vector<numInfo> numsInfo;
        for(int i = 0; i < nums.size(); i++) {
            if(numsInfo.empty() || (nums[i] != nums[i-1])) numsInfo.push_back({.val = nums[i], .repeatCnt = 1});
            else numsInfo.back().repeatCnt++;
        }

        int curResultLen = 0;
        vector<int> curResult(nums.size(), 0);

        int startIdx = 0;
        vector<vector<int>> resultSet;
        createSubSets(numsInfo, startIdx, curResult, curResultLen, resultSet);

        return resultSet;
    }
};
```

## V3：不使用額外資料結構，即時計算當前數字重複情況
- **如果數字重複，則處理的時候在 inner loop 中處理重複數字的情況 -> **不要把處理中的重複數字帶到下一層 recursive，避免產生重複的 subset**
- **如果數字重複，則處理完這個數字後，nums[i] 要直接跳到下一個不一樣的數字**
```Cpp
class Solution {
private:
    void createSubSets(vector<int> &nums, int startIdx, vector<int> &curResult, int curResultLen, vector<vector<int>> &resultSet) {
        for(int i = startIdx, curNumRepeatCnt; i < nums.size(); i+= curNumRepeatCnt) {

            curNumRepeatCnt = 1;
            for(int j = i; (j+1 < nums.size()) && (nums[j] == nums[j+1]); j++) curNumRepeatCnt++;

            for(int numCnt = 1; numCnt <= curNumRepeatCnt; numCnt++) {

                int n = numCnt;
                while(n--) curResult[curResultLen++] = nums[i];

                createSubSets(nums, i+curNumRepeatCnt, curResult, curResultLen, resultSet);

                n = numCnt;
                while(n--) curResultLen--;
            }
        }
        
        resultSet.push_back({});
        vector<int> &resultVec = resultSet.back();

        if(curResultLen) {
            resultVec.resize(curResultLen);
            for(int i = 0; i < curResultLen; i++) resultVec[i] = curResult[i];
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        int curResultLen = 0;
        vector<int> curResult(nums.size(), 0);

        int startIdx = 0;
        vector<vector<int>> resultSet;
        createSubSets(nums, startIdx, curResult, curResultLen, resultSet);

        return resultSet;
    }
};
```

# Answer：V3 - 複習2nd - 模板化寫法
```Cpp
class Solution {
private:
    int getRepeatNumFromIdx(auto &nums, int idx) {
        if(idx >= nums.size()) return 0;

        int repeat = 1;
        for(int i = idx+1; i < nums.size(); i++) {
            if(nums[i] != nums[idx]) break;
            repeat++;
        }
        return repeat;
    }

    void getSubSetFromIdx(auto &nums, int startIdx, int needElmtNum, auto &allSubSets, auto &curSubSet ) {
        if(needElmtNum == 0) {
            allSubSets.push_back(curSubSet);
            return;
        }

        for(int i = startIdx, repeatCnt = 1; i < nums.size(); i+= repeatCnt) {
            repeatCnt = getRepeatNumFromIdx(nums, i);
            for(int r = 1, needCnt = 0; r <= repeatCnt; r++) {
                needCnt = r;
                while(needCnt--) curSubSet.push_back(nums[i]);

                getSubSetFromIdx(nums, i + repeatCnt, needElmtNum - r, allSubSets, curSubSet );

                needCnt = r;
                while(needCnt--) curSubSet.pop_back();
            }
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        
        // all subsets
        vector<vector<int>> allSubSets;

        // current sub-set in process
        vector<int> curSubSet;
        curSubSet.reserve(nums.size());

        // sort the nums
        sort(nums.begin(), nums.end());

        // get sub-set with all kinds of size
        for(int subSetSize = 0; subSetSize <= nums.size(); subSetSize++) {
            getSubSetFromIdx( nums, 0, subSetSize, allSubSets, curSubSet );
        }

        // finish
        return allSubSets;
    }
};
```