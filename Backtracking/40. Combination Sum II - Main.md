---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)

# Answer - 隱式表示重複數字使用 + temp solution vector 使用動態長度 -> 比較難想到
```Cpp
class Solution {
private:
    
    bool createSubSetFromSum(int startCheckNumIdx, vector<int>& nums, int targetSum, vector<int>& subSetOnCheck, vector<vector<int>>& subSetsAll) {
    
        // if the target num less or equal to zero
        if(targetSum <= 0) return (targetSum == 0);
        
        
        // produce subset with certain element in nums as pivot element
        for(int i = startCheckNumIdx; i < nums.size(); i++) {

            // if the current num is the same as the previous one
            if(i > startCheckNumIdx && nums[i] == nums[i-1]) continue;
        
            // calculate the remained target sum after select certain num
            int remainSum = targetSum - nums[i];
        
            // append the on check number
            subSetOnCheck.push_back( nums[i] );
            
            // check the subset with one more element
            bool checkPass = createSubSetFromSum(i+1, nums, remainSum, subSetOnCheck, subSetsAll);
            
            // append result if the onCheck subset satisfies the target sum
            if( checkPass ) subSetsAll.push_back( subSetOnCheck );
            
            // pop out the number after check
            subSetOnCheck.pop_back();
        }
        
        // here must return false since the targetSum is not zero
        return false;
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

        // init result
        vector<vector<int>> subSetsAll;

        // sor the candicate to prevent the duplicated subSet
        sort(candidates.begin(), candidates.end());
        
        // produce subset starting from certain index
        vector<int> subSetOnCheck;
        createSubSetFromSum(0, candidates, target, subSetOnCheck, subSetsAll);
        
        // finish
        return subSetsAll;
    }
};
```

# Answer - 顯式表示重複數字使用 + temp solution vector 使用預配長度 -> 想法比較直覺
## V1：複習1st
```Cpp
class Solution {
private:
    void combinationSum2(   auto &candidates, int startIdx, int target, 
                            auto &curCombination, int curCombLen, auto &allCombination) {
        if(target < 0) {
            return;
        }

        if(target == 0) {
            allCombination.push_back(curCombination);
            allCombination.back().resize(curCombLen);
            return;
        }

        for(int i = startIdx, repeatCnt; i < candidates.size(); i+= repeatCnt) {
            repeatCnt = 1;
            for(int j = i; (j+1 < candidates.size()) && (candidates[j] == candidates[j+1]); j++) repeatCnt++;

            int curNumMaxUseCnt = min(repeatCnt, target / candidates[i]);
            for(int sameNumUseCnt = 1; sameNumUseCnt <= curNumMaxUseCnt; sameNumUseCnt++) {

                int n = sameNumUseCnt;
                while(n--) curCombination[curCombLen++] = candidates[i];

                // -> call next recursive
                combinationSum2(candidates, i+repeatCnt, (target - candidates[i] * sameNumUseCnt), 
                                curCombination, curCombLen, allCombination);

                n = sameNumUseCnt;
                while(n--) curCombLen--;
            }
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());

        int curCombLen = 0;
        vector<int> curCombination(candidates.size(), 0);

        vector<vector<int>> allCombination;
        combinationSum2(candidates, 0, target, curCombination, curCombLen, allCombination);

        return allCombination;
    }
};
```

## V2: 複習2nd - 模板化寫法
```Cpp
class Solution {
private:
    int getRepeatNumFromIdx(auto &nums, int idx) {
        if(idx >= nums.size()) return 0;

        int repeatNum = 1;
        for(int i = idx+1; i < nums.size(); i++) {
            if(nums[i] != nums[idx]) break;
            repeatNum++;
        }
        return repeatNum;
    }

    void getTargetCombinationFromIdx(auto &nums, int startIdx, int target, auto &curComb, auto &allCombinations) {
        if(target == 0) {
            allCombinations.push_back(curComb);
            return;
        }

        for(int i = startIdx, repeatNum = 0; i < nums.size(); i+=repeatNum ) {
            repeatNum = getRepeatNumFromIdx(nums, i);
            for(int r = 1, useRepeatNum = 1; r <= repeatNum; r++) {
                if( (target - r*nums[i]) < 0 ) break;

                useRepeatNum = r;
                while(useRepeatNum--) curComb.push_back(nums[i]);

                getTargetCombinationFromIdx(nums, i+repeatNum, target - r*nums[i], curComb, allCombinations);

                useRepeatNum = r;
                while(useRepeatNum--) curComb.pop_back();
            }
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        // sort candidates
        sort(candidates.begin(), candidates.end());

        // combination in process & result
        vector<int> curComb;
        vector<vector<int>> allCombinations;

        // find all combinations
        getTargetCombinationFromIdx(candidates, 0, target, curComb, allCombinations);
        return allCombinations;
    }
};
```