---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[39. Combination Sum](https://leetcode.com/problems/combination-sum/)

# Concept
- **使用一個暫存的 vector 記錄當下 subset 檢查情況 -> check pass 的時候存到 all sub set 裡面**
	- 檢查當下是否可以加入某個數字到 subset
		- 檢查前 subset push_back(num)
		- 檢查後 subset pop_back(num)
	- 這個 vector 其實是當作 stack 使用
		- 可以預先分配最大空間，再搭配一個 subsetLen 來記錄裡面存幾個 num
- 同一個 num 重複使用的情況，有兩種寫法
	- (1): 隱式表示：同一個 num 重複使用，則直接多呼叫一次 func call
	- (2): 顯式表示：同一個 num 重複使用，用一個 loop 連續多次把 num 設定到 sub-set 裡面
# Answer: 隱式表示同一個 num 重複使用 + 檢查中的 subset 用 vector 動態 push / pop
```Cpp
class Solution {
private:
    
    bool createSubSetFromSum(int startCheckNumIdx, vector<int>& nums, int targetSum, vector<int>& subSetOnCheck, vector<vector<int>>& subSetsAll) {
    
        // if the target num less or equal to zero
        if(targetSum <= 0) return (targetSum == 0);
        
        
        // produce subset with certain element in nums as pivot element
        for(int i = startCheckNumIdx; i < nums.size(); i++) {
        
            // calculate the remained target sum after select certain num
            int remainSum = targetSum - nums[i];
        
            // append the on check number
            subSetOnCheck.push_back( nums[i] );
            
            // check the subset with one more element
            bool checkPass = createSubSetFromSum(i, nums, remainSum, subSetOnCheck, subSetsAll);
            
            // append result if the onCheck subset satisfies the target sum
            if( checkPass ) subSetsAll.push_back( subSetOnCheck );
            
            // pop out the number after check
            subSetOnCheck.pop_back();
        }
        
        // here must return false since the targetSum is not zero
        return false;
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {

        // init result
        vector<vector<int>> subSetsAll;
        
        // produce subset starting from certain index
        vector<int> subSetOnCheck;
        createSubSetFromSum(0, candidates, target, subSetOnCheck, subSetsAll);
        
        // finish
        return subSetsAll;
    }
};
``` 

# Answer: 顯式表示同一個 num 重複使用 + 檢查中的 subset 用 vector + subsetLen 避免動態分配
```Cpp
class Solution {
private:
    void combinationSum(vector<int> &candidates, int startIdx, int target, 
                        vector<int> &curCombination, int curCombLen, auto &combinationSet) {
        // target < 0 -> invalid cond
        if(target < 0) {
            return;
        }

        // target = 0 -> record new combination
        if(target == 0) {
            combinationSet.push_back({});
            vector<int> &newCombination = combinationSet.back();

            newCombination.resize(curCombLen);
            for(int i = 0; i < curCombLen; i++) newCombination[i] = curCombination[i];
            return;
        }

        // target > 0 -> calculate combination
        for(int i = startIdx; i < candidates.size(); i++) {

            int maxTimesOfCurNum = target / candidates[i];
            for(int multipleTimes = 1; multipleTimes <= maxTimesOfCurNum; multipleTimes++) {

                int n = multipleTimes;
                while(n--) curCombination[curCombLen++] = candidates[i];

                combinationSum( candidates, i+1, (target - candidates[i] * multipleTimes), 
                                curCombination, curCombLen, combinationSet);

                n = multipleTimes;
                while(n--) curCombLen--;
            }
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {

        sort(candidates.begin(), candidates.end());
        int maxCombinationLen = target / candidates[0] + ( (target % candidates[0]) ? (1) : (0) );

        vector<int> curCombination(maxCombinationLen, 0);
        int curCombLen = 0;

        vector<vector<int>> combinationSet;
        combinationSum( candidates, 0, target, 
                        curCombination, curCombLen, combinationSet);
        
        return combinationSet;
    }
};
```
- **注意**
	- **這個做法一定要一開始在 curSubSet (curCombination) 直接分配足夠的 length**
	- **另外一個做法則是，一開始 curSubSet 分配一個長度，但長度不足的時候，再動態 resize**