---
ParentTask:
  - "[[backtracking]]"
---

# LeetCode
[17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

# Answer：DFS
## V1 - DFS + Iteration -> **這個實戰絕對想不到**
- **結構複雜，而且很多邊界條件要考慮**
```Cpp
class Solution {
private:
    string padStrAll[10] = 
    {
        /*0*/" ",
        /*1*/"",
        /*2*/"abc",
        /*3*/"def",
        /*4*/"ghi",
        /*5*/"jkl",
        /*6*/"mno",
        /*7*/"pqrs",
        /*8*/"tuv",
        /*9*/"wxyz"
    };
    
    struct checkPadStrCond {
        int digit = -1;
        int checkPadStrIdx = 0;
    };
public:
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return {};
        
        vector<checkPadStrCond> checkConds(digits.size());
        for(int i = 0; i < digits.size(); i++) checkConds[i].digit = digits[i] - '0';
        
        string curResult( digits.size(), '_' );
        vector<string> resultSet;
        
        int checkIdx = 0;
        while(true) {
        
            // if check idx go back before the start poibt -> all check finished
            if( checkIdx < 0 ) break;
        
            // if check idx reaches end
            if( checkIdx >= checkConds.size() ) {
                resultSet.push_back( curResult );
                checkIdx--; continue;
            }
        
            // get the current check condition
            checkPadStrCond &curCheckCond = checkConds[checkIdx];
            
            // the str on pad
            string &padStr = padStrAll[ curCheckCond.digit ];
            
            // if the current xigit had been titally checked -> go back to previous digit
            if( curCheckCond.checkPadStrIdx >= padStr.size() ) {
                curCheckCond.checkPadStrIdx = 0;
                checkIdx--; continue;
            }
            
            // if current digit has not been totally checked
            // (1) convert digit to char and add to result
            curResult[ checkIdx ] = padStr[ curCheckCond.checkPadStrIdx++ ];
            
            // (2) traverse to next digit if the current digit is not the last one
            checkIdx++;
        }
        
        return resultSet;
    }
};
``` 


## V2 - DFS + Recursive -> **複習的時候是想到這個寫法**
- **好懂很多，而且寫法和其他 back tracking 架構類似**
- **注意：題目要求輸入空字串 string = "" 的時候，要回傳 empty vector {} ，而不是 vector 含有空字串 {""}**
```Cpp
    string _digitToChar_[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
#define GET_PAD_STR_FROM_DIGIT(_DIGIT_) _digitToChar_[_DIGIT_ - '0'];

class Solution {
private:
    void letterCombinations(string &digits, int startIdx, 
                            string &curCombination, int curCombLen, vector<string> &combinationSet) {
        if(startIdx >= digits.size()) {
            combinationSet.push_back(curCombination.substr(0, curCombLen));
            return;
        }

        string &padStr = GET_PAD_STR_FROM_DIGIT(digits[startIdx]);
        if(padStr.empty()) {
            letterCombinations(digits, startIdx+1, curCombination, curCombLen, combinationSet);
            return;
        }

        for(int i = 0; i < padStr.size(); i++) {
            if(curCombination.size() <= curCombLen) curCombination.resize(curCombLen+1);
            curCombination[curCombLen++] = padStr[i];

            letterCombinations(digits, startIdx+1, curCombination, curCombLen, combinationSet);

            curCombLen--;
        }

    }
public:
    vector<string> letterCombinations(string digits) {

        if(digits.empty()) return {};

        int curCombLen = 0;
        string curCombination;
        
        vector<string> combinationSet;
        letterCombinations(digits, 0, curCombination, curCombLen, combinationSet);

        return combinationSet;
    }
};
```


# Answer：BFS + Iteration
- **每一層都用前一層檢查的結果進行展開**
- **一開始 resultSet 必須包含一個空字串，這樣才能用這個空字串展開後續內容**
```Cpp
class Solution {
private:
    string padStrAll[10] = 
    {
        /*0*/" ",
        /*1*/"",
        /*2*/"abc",
        /*3*/"def",
        /*4*/"ghi",
        /*5*/"jkl",
        /*6*/"mno",
        /*7*/"pqrs",
        /*8*/"tuv",
        /*9*/"wxyz"
    };
    
    
public:
    vector<string> letterCombinations(string digits) {
        // if the input digit is empty
        if(digits.empty()) return {};
        
        // the result set for all str combination
        vector<string> resultSet = {""};
        
        // BFS to check each digit
        for(int i = 0; i < digits.size(); i++) {
            // pad str of xurrent digit
            string &padStr = padStrAll[ digits[i] - '0' ];
            
            // to store the expanded result from prev digit
            vector<string> expandStrFromPrevDigitSet;
            
            // check each possible char on current digit
            for(auto c : padStr) {
            
                // expand resylf of previoys digit with new padStr
                for(auto &prevDigitStr : resultSet) {
                    expandStrFromPrevDigitSet.push_back( prevDigitStr+c );
                }
            }
            
            // set the expanded str set as new result
            swap(resultSet, expandStrFromPrevDigitSet);
        }
        return resultSet;
    }
};
```