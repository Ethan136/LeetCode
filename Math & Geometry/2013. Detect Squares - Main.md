---
ParentTask:
  - "[[math_and_geometry]]"
---

# LeetCode
[2013. Detect Squares](https://leetcode.com/problems/detect-squares/)

# Concept
兩階段 mapping 查詢
- 先查詢相同 X 的 points -> 任意一個相同 x 的 point，可以和 input point 計算出一個 distance -> 也就是變長
- 找出 x-axis = X + dist 的所有 points，看能不能和 "input point" 及 "上述任一個相同 X 的 point" 構成正方形
- 找出 x-axis = X - dist 的所有 points，看能不能和 "input point" 及 "上述任一個相同 X 的 point" 構成正方形

# Answer V1：single mapping from X to points (速度慢，記憶體開銷大)
```Cpp 
class DetectSquares {
private:
    unordered_map<int, vector<vector<int>>> m_XpointMap;
public:
    DetectSquares() {
        
    }
    
    void add(vector<int> point) {
        m_XpointMap[point[0]].push_back(point);
    }
    
    int count(vector<int> point) {
        // find points with same X
        if(!m_XpointMap.count(point[0])) return 0;
        auto &same_Xpoints = m_XpointMap[point[0]];

        // find points of Y to form the square
        int recCnt = 0;
        for(auto &sameXpt : same_Xpoints) {

            // distance of sameXpt to point
            int dist = abs(sameXpt[1] - point[1]);
            if(dist == 0) continue;

            // the points match sameXpt & point
            int pt1_match, pt2_match;

            // extend rightward
            pt1_match = 0, pt2_match = 0;
            auto &right_edge_candidate = m_XpointMap[point[0]+dist];
            for(auto &rightPt : right_edge_candidate) {
                if(rightPt[1] == point[1]) pt1_match++;
                if(rightPt[1] == sameXpt[1]) pt2_match++;
            }
            recCnt += (pt1_match * pt2_match);

            // extend leftward
            pt1_match = 0, pt2_match = 0;
            auto &left_edge_candidate = m_XpointMap[point[0]-dist];
            for(auto &leftPt : left_edge_candidate) {
                if(leftPt[1] == point[1]) pt1_match++;
                if(leftPt[1] == sameXpt[1]) pt2_match++;
            }
            recCnt += (pt1_match * pt2_match);
        }

        // finish
        return recCnt;
    }
};

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares* obj = new DetectSquares();
 * obj->add(point);
 * int param_2 = obj->count(point);
 */
```


# Answer V2：double mapping from (x, y) to point Cnt (速度快很多，記憶體開銷較小)
```Cpp
class DetectSquares {
private:
    unordered_map<int, unordered_map<int, int>> m_XYpointCntMap;
public:
    DetectSquares() {
        
    }
    
    void add(vector<int> point) {
        m_XYpointCntMap[point[0]][point[1]]++;
    }
    
    int count(vector<int> point) {
        // find points with same X
        if(!m_XYpointCntMap.count(point[0])) return 0;
        auto &sameXpointMap = m_XYpointCntMap[point[0]];

        // find points of Y to form the square
        int recCnt = 0;
        for(auto &[y, pointCnt] : sameXpointMap) {

            // distance of sameXpt to point
            int dist = abs(y - point[1]);
            if(dist == 0) continue;

            // extend rightward
            int x2r = point[0]+dist;
            if(m_XYpointCntMap[x2r].size() && m_XYpointCntMap[x2r].count(point[1]) && m_XYpointCntMap[x2r].count(y)) {
                int pt1_match = m_XYpointCntMap[x2r][point[1]];
                int pt2_match = m_XYpointCntMap[x2r][y];
                recCnt += pointCnt * pt1_match * pt2_match;
            }
            

            // extend leftward
            int x2l = point[0]-dist;
            if(m_XYpointCntMap[x2l].size() && m_XYpointCntMap[x2l].count(point[1]) && m_XYpointCntMap[x2l].count(y)) {
                int pt1_match = m_XYpointCntMap[x2l][point[1]];
                int pt2_match = m_XYpointCntMap[x2l][y];
                recCnt += pointCnt * pt1_match * pt2_match;
            }
        }

        // finish
        return recCnt;
    }
};

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares* obj = new DetectSquares();
 * obj->add(point);
 * int param_2 = obj->count(point);
 */
```