---
ParentTask:
  - "[[math_and_geometry]]"
---

# LeetCode
[2013. Detect Squares](https://leetcode.com/problems/detect-squares/)

# Concept
兩階段 mapping 查詢
- 先查詢相同 X 的 points -> 任意一個相同 x 的 point，可以和 input point 計算出一個 distance -> 也就是變長
- 找出 x-axis = X + dist 的所有 points，看能不能和 "input point" 及 "上述任一個相同 X 的 point" 構成正方形
- 找出 x-axis = X - dist 的所有 points，看能不能和 "input point" 及 "上述任一個相同 X 的 point" 構成正方形

# Answer V1：single mapping from X to points (速度慢，記憶體開銷大)
```Cpp 
class DetectSquares {
private:
    unordered_map<int, vector<vector<int>>> m_XpointMap;
public:
    DetectSquares() {
        
    }
    
    void add(vector<int> point) {
        m_XpointMap[point[0]].push_back(point);
    }
    
    int count(vector<int> point) {
        // find points with same X
        if(!m_XpointMap.count(point[0])) return 0;
        auto &same_Xpoints = m_XpointMap[point[0]];

        // find points of Y to form the square
        int recCnt = 0;
        for(auto &sameXpt : same_Xpoints) {

            // distance of sameXpt to point
            int dist = abs(sameXpt[1] - point[1]);
            if(dist == 0) continue;

            // the points match sameXpt & point
            int pt1_match, pt2_match;

            // extend rightward
            pt1_match = 0, pt2_match = 0;
            auto &right_edge_candidate = m_XpointMap[point[0]+dist];
            for(auto &rightPt : right_edge_candidate) {
                if(rightPt[1] == point[1]) pt1_match++;
                if(rightPt[1] == sameXpt[1]) pt2_match++;
            }
            recCnt += (pt1_match * pt2_match);

            // extend leftward
            pt1_match = 0, pt2_match = 0;
            auto &left_edge_candidate = m_XpointMap[point[0]-dist];
            for(auto &leftPt : left_edge_candidate) {
                if(leftPt[1] == point[1]) pt1_match++;
                if(leftPt[1] == sameXpt[1]) pt2_match++;
            }
            recCnt += (pt1_match * pt2_match);
        }

        // finish
        return recCnt;
    }
};

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares* obj = new DetectSquares();
 * obj->add(point);
 * int param_2 = obj->count(point);
 */
```


# Answer V2：double mapping from (x, y) to point Cnt (速度快很多，記憶體開銷較小)
## V2.1：複習1st
```Cpp
class DetectSquares {
private:
    unordered_map<int, unordered_map<int, int>> m_XYpointCntMap;
public:
    DetectSquares() {
        
    }
    
    void add(vector<int> point) {
        m_XYpointCntMap[point[0]][point[1]]++;
    }
    
    int count(vector<int> point) {
        // find points with same X
        if(!m_XYpointCntMap.count(point[0])) return 0;
        auto &sameXpointMap = m_XYpointCntMap[point[0]];

        // find points of Y to form the square
        int recCnt = 0;
        for(auto &[y, pointCnt] : sameXpointMap) {

            // distance of sameXpt to point
            int dist = abs(y - point[1]);
            if(dist == 0) continue;

            // extend rightward
            int x2r = point[0]+dist;
            if(m_XYpointCntMap[x2r].size() && m_XYpointCntMap[x2r].count(point[1]) && m_XYpointCntMap[x2r].count(y)) {
                int pt1_match = m_XYpointCntMap[x2r][point[1]];
                int pt2_match = m_XYpointCntMap[x2r][y];
                recCnt += pointCnt * pt1_match * pt2_match;
            }
            

            // extend leftward
            int x2l = point[0]-dist;
            if(m_XYpointCntMap[x2l].size() && m_XYpointCntMap[x2l].count(point[1]) && m_XYpointCntMap[x2l].count(y)) {
                int pt1_match = m_XYpointCntMap[x2l][point[1]];
                int pt2_match = m_XYpointCntMap[x2l][y];
                recCnt += pointCnt * pt1_match * pt2_match;
            }
        }

        // finish
        return recCnt;
    }
};

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares* obj = new DetectSquares();
 * obj->add(point);
 * int param_2 = obj->count(point);
 */
```


## V2.2：複習2nd
- 和 V2.1 比起來，這個寫法可能會額外呼叫 map 建立 Map\[Xa\]\[Yb\] = 0的內容 -> 速度慢一點
- 但整體來說寫的比較簡潔
```Cpp
class DetectSquares {
private:
    unordered_map<int, unordered_map<int, int>> m_xToYPointCnt;
public:
    DetectSquares() {
    }
    
    void add(vector<int> point) {
        m_xToYPointCnt[ point[0] ][ point[1] ]++;
    }
    
    int count(vector<int> point) {
        // basis point x0 / y0
        int x0 = point[0];
        int y0 = point[1];

        // same X points different Y -> x0 / y1
        int squareCnt = 0;
        for(auto [y1, x0y1Cnt] : m_xToYPointCnt[x0]) {
            // (0) check distance of Y = edge width
            int width = abs(y1 - y0);
            if(width == 0) continue;

            // (1) positive X dir extend to square (x1 / y0) & (x1 / y1)
            int x1 = x0 + width;
            int x1y0Cnt = m_xToYPointCnt[x1][y0];
            int x1y1Cnt = m_xToYPointCnt[x1][y1];
            squareCnt += x0y1Cnt * x1y0Cnt * x1y1Cnt;

            // (2) negative X dir extend to square (x2 / y0) & (x2 / y1)
            int x2 = x0 - width;
            int x2y0Cnt = m_xToYPointCnt[x2][y0];
            int x2y1Cnt = m_xToYPointCnt[x2][y1];
            squareCnt += x0y1Cnt * x2y0Cnt * x2y1Cnt;
        }

        return squareCnt;
    }
};
```