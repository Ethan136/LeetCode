# LeetCode
[43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)

# Concept
- result size 預分配：可以直接分配為 nums1.size() + nums2.size() -> **後續再把 pivot zero 拿掉即可**
- 可以預處理把 char digit 轉換成 num -> 這樣string 裡面直接視為儲存數字，比較好算
	- string[i] -= '0' -> 會把 '0' to '9' 轉換成 0 to 9 (num)

# Answer V1：一個數字一個數字相乘 (沒有把 char digit 轉換成 num)
```Cpp
#define DEBUG_EN    (0)
class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1 == "0" || num2 == "0") return "0";
        if(num1 == "1") return num2;
        if(num2 == "1") return num1;

        // originally stored in reversed order
        string result(num1.size() + num2.size(), '0');

        // reverse string num1 & nums
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());

        // do multiply & store in result
        // (1) choose one digit of num1
        int i, j;
        for(i = 0; i < num1.size(); i++) {

            // selected digit of num1: digit1
            int digit1 = num1[i] - '0';

            // (2) choose one digit of num2: digit1 x num2[j]
            int carry = 0;
            for(j = 0; j < num2.size(); j++) {

                // digit stored in result before calculation
                int prevCalcResultDigit = result[i+j] - '0';

                // selected digit of num2: digit2
                int digit2 = num2[j] - '0';

                // do multiply digit1 x digit2
                int multiply1x2 = digit1 * digit2;

                // add the carry from digit1 x digit2_prev
                int multiply1x2WithCarry = multiply1x2 + carry;

                // add to the result digit
                int multiply1x2WithCarryToResult = multiply1x2WithCarry + prevCalcResultDigit;

                // update the digit on the "corresponding pos of digit2"
                int resultDigit = multiply1x2WithCarryToResult % 10;

                // upate the carry of the next multiply digit1 x digit2_next
                carry = multiply1x2WithCarryToResult / 10;

                // store the calculation result of the current digit
                result[i+j] = '0' + resultDigit;

#if DEBUG_EN
                cout
                << "-----------------" << endl
                << "num1[" << i << "]: " << digit1 << endl
                << " x " << endl
                << "num2[" << j << "]: " << digit2 << endl
                << " + " << endl
                << "origin result[" << i + j << "]: " << prevCalcResultDigit << endl
                << " = " << endl
                << multiply1x2WithCarryToResult << endl
                << "new result[" << i + j << "]: " << resultDigit << endl
#endif
            }

            // to deal with the remained carry of digit1 x whole num2
            int carryAddToResult = carry + (result[i+j] - '0');

            // the digit to store in the origin highest digit
            result[i+j] = '0' + carryAddToResult % 10;

            // calculate new carry extend to next highest digit
            result[i+j+1] = '0' + carryAddToResult / 10;
        }


        // calculate the "pivot zero" of the result
        int pivot0Num = 0;
        for(int i = result.size()-1; i >= 0; i--) {
            if(result[i] != '0') break;
            pivot0Num++;
        }

        // clear the "pivot zero" of the result
        result.resize( result.size() - pivot0Num );

        // reverse the result to the order with "digit from high to low"
        reverse(result.begin(), result.end());

        // finish
        return result;
    }
};
```

# Answer V2：2D DP 記錄先前乘過的數字 + 把 digit char 轉換成 num 再做計算 (計算結束後再把 num 轉換成 digit char)
## V1：複習1st
- **因為用 2D DP 記錄先前乘過的 num1 * num2\[i\]  -> 把數字比較長的設為 num1，比較短的設為 num2**
```Cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        // if one of num1 or num2 is zero
        if(num1[0] == '0' || num2[0] == '0') return "0";

        // set the longer one as num1
        if(num1.size() < num2.size()) swap(num1, num2);

        // convert num1 / num2 stored char to number
        for(auto &digit1 : num1) digit1 -= '0';
        for(auto &digit2 : num2) digit2 -= '0';

        // reverse num1 , num2
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());

        // initialize the result
        string result(num1.size() + num2.size(), 0);

        // to record the multiply condition
        unordered_map<int, string> multiplyDigitMap;

        // do multiply
        for(int i = 0; i < num2.size(); i++) {
            // digit on num2
            int digit = num2[i];

            // initialize intermediate multiply result
            string num1xdigit;

            // if num1 * digit had been calculated before
            if(multiplyDigitMap.count(digit)) {
                num1xdigit = multiplyDigitMap[digit];
            }
            // if num1 * digit had not been calculated before
            else {
                int carry = 0;
                for(int j = 0; j < num1.size(); j++) {
                    int sum = num1[j] * digit + carry;
                    num1xdigit.push_back(sum % 10);
                    carry = sum / 10;
                }
                if(carry) num1xdigit.push_back(carry);
                multiplyDigitMap[digit] = num1xdigit;
            }

            // result add num1xdigit + shift_N
            int carry = 0, k;
            for(k = 0; (k < num1xdigit.size()) || (carry); k++) {
                int addNum = (k < num1xdigit.size()) ? (num1xdigit[k]) : (0);
                int sum = carry + addNum + result[i + k];
                result[i + k] = sum % 10;
                carry = sum / 10;
            }
        }

        // take out the leading zeros
        while(result.back() == 0) {
            result.pop_back();
        }

        // reverse back the result
        reverse(result.begin(), result.end());

        // convert the result from num to char
        for(auto &resultChr : result) resultChr += '0';

        // finish
        return result;

    }
};
```

## V2：複習2nd
- **debug 的時候注意： cout << (c + '0') -> 會使用數字輸出 char index，而不是輸出 char 字元**
```Cpp
class Solution {
public:
    string multiply(string nums1, string nums2) {
        // convert to pure num
        for(char &c1 : nums1) c1 -= '0';
        for(char &c2 : nums2) c2 -= '0';

        // reverse order of nums1 / nums2 -> [low digit ... high digit] (idx low to high)
        reverse(nums1.begin(), nums1.end());
        reverse(nums2.begin(), nums2.end());

        // nums1 * nums2 -> chose longer one as nums1 with recorded DP result
        if(nums1.size() < nums2.size()) swap(nums1, nums2);

        // init result as length of nums1.size() + nums2.size() + 1
        // (+1 means leading digit increase one)
        string result(nums1.size() + nums2.size() + 1, 0);

        // process nums1 * nums2[i] with DP by recording nums1 * '0 to 9'
        vector<string> nums1MtplyN(10, "");

        // func to process multiply
        auto calcNums1MtplyN = [](auto &nums1, int N) {
            string nums1MtplyDigit2 = "";

            int carry = 0;
            for(int j = 0; j < nums1.size(); j++) {
                int sum = nums1[j] * N + carry;
                nums1MtplyDigit2 += char(sum % 10);
                carry = sum / 10;
            }
            if(carry) nums1MtplyDigit2 += char(carry);

            return nums1MtplyDigit2;
        };

        // func to process add
        auto addToResult = [](int addNumStartDigit, string &addNumStr, string &result) {

            int carry = 0;
            int digitCnt = addNumStr.size();
            for(int i = 0; (i < digitCnt) || (carry); i++) {
                int addNum = (i < digitCnt) ? (addNumStr[i]) : (0);
                int sum = result[addNumStartDigit + i] + addNum + carry;
                result[addNumStartDigit + i] = sum % 10;
                carry = sum / 10;
            }
        };

        // process nums1 * nums2
        for(int i = 0; i < nums2.size(); i++) {

            // if nums2[i] = 0 -> no need to calc
            if(nums2[i] == 0) continue;

            // process nums1 * nums2[i]
            // (0) digit of nums2[i]
            int digit2 = nums2[i];

            // (1) if current multiply nums1 * digits had not been calculated before
            if(!nums1MtplyN[ digit2 ].size()) {
                nums1MtplyN[ digit2 ] = calcNums1MtplyN(nums1, digit2);
            }

            // add nums1 * nums2[i] to result
            addToResult(i, nums1MtplyN[ digit2 ], result);
        }

        // delete leading zero until only 1 zero remain
        while( (result.size() > 1) && (result.back() == 0) ) result.pop_back();

        // reverse order of result -> [high digit, ... , low digit] (idx low to high)
        reverse(result.begin(), result.end());

        // convert back to char '0 to 9'
        for(char &c : result) c += '0';

        // finish
        return result;
    }
};
```