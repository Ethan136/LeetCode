---
ParentTask:
  - "[[math_and_geometry]]"
---

# LeetCode
[54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)

# Concept
- **要明確定義是先走再記錄 matrix value，還是先記錄 matrix value 再走**
- **先走，再記錄 matrix value 會比較好寫，並且 start position = {0, -1} (從 matrix 外往裡面踏進來)**
- **這題難在如何定義行走方向，以及如何更新每次行走要走「哪個方向」以及「走幾格」**

# Answer V1：state machine 定義四個方向依序行走 + 自訂資料結構 t_Pos
```Cpp
#define DEBUG_EN    (1)

class Solution {
    struct t_Pos {
        int row;
        int col;
    };

    enum travDir {
        DIR_ROW_RIGHT,
        DIR_ROW_LEFT,
        DIR_COL_UP,
        DIR_COL_DOWN
    };

    // path: not include startPos , but include endPos
    void traverseMatrix(vector<vector<int>>& matrix, t_Pos startPos, travDir dir, int travNum, t_Pos &endPos, vector<int> &path) {
        // if the traget traverse num is invalid
        if(travNum <= 0) {
            endPos = startPos;
            return;
        }

        // boundary condition
        int rowNum = matrix.size();
        int colNum = matrix[0].size();

        // do traverse
        switch (dir) {
        case DIR_ROW_RIGHT:   
            for(int i = 1; i <= travNum && (startPos.col + i < colNum); i++) {
                endPos = {startPos.row, startPos.col + i};
                path.push_back(matrix[endPos.row][endPos.col]);
                cout << matrix[endPos.row][endPos.col] << endl;
            }
            break;
        case DIR_ROW_LEFT:
            for(int i = 1; i <= travNum && (startPos.col - i >= 0); i++) {
                endPos = {startPos.row, startPos.col - i};
                path.push_back(matrix[endPos.row][endPos.col]);
                cout << matrix[endPos.row][endPos.col] << endl;
            }
            break;
        case DIR_COL_UP:
            for(int i = 1; i <= travNum && (startPos.row - i >= 0); i++) {
                endPos = {startPos.row - i, startPos.col};
                path.push_back(matrix[endPos.row][endPos.col]);
                cout << matrix[endPos.row][endPos.col] << endl;
            }
            break;
        case DIR_COL_DOWN:
            for(int i = 1; i <= travNum && (startPos.row + i < rowNum); i++) {
                endPos = {startPos.row + i, startPos.col};
                path.push_back(matrix[endPos.row][endPos.col]);
                cout << matrix[endPos.row][endPos.col] << endl;
            }
            break;
        }
    };

#if DEBUG_EN
    void debugPrintCond(int goState, int remainRow, int remainCol, t_Pos startPos) {
        switch (goState) {
        case DIR_ROW_RIGHT:   
            cout << "DIR_ROW_RIGHT" << endl;
            break;
        case DIR_ROW_LEFT:
            cout << "DIR_ROW_LEFT" << endl;
            break;
        case DIR_COL_UP:
            cout << "DIR_COL_UP" << endl;
            break;
        case DIR_COL_DOWN:
            cout << "DIR_COL_DOWN" << endl;
            break;
        }
        
        cout << "remainRow: " << remainRow << " | remainCol: " << remainCol << endl;
        cout << "startPos: [" << startPos.row << " , " << startPos.col << "]" << endl;
    }
#else
#define debugPrintCond( goState, remainRow, remainCol, startPos)
#endif

public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {

        // initial condition of traverse
        travDir goState = DIR_ROW_RIGHT;
        int remainRow = matrix.size();
        int remainCol = matrix[0].size();

        // initialize result
        vector<int> path;
        path.reserve(remainRow * remainCol);

        // initial traverse -> step from the outside of the matrix and will go right within the row
        t_Pos startPos = {0, -1};

        // do traverse in spiral
        t_Pos endPos;
        while((remainRow > 0) && (remainCol > 0)) {

            debugPrintCond(goState, remainRow, remainCol, startPos);

            switch(goState) {
            case DIR_ROW_RIGHT:
                traverseMatrix(matrix, startPos, goState, remainCol, endPos, path);
                remainRow--;

                goState = DIR_COL_DOWN;
                startPos = endPos;
                break;

            case DIR_COL_DOWN:
                traverseMatrix(matrix, startPos, goState, remainRow, endPos, path);
                remainCol--;

                goState = DIR_ROW_LEFT;
                startPos = endPos;
                break;

            case DIR_ROW_LEFT:
                traverseMatrix(matrix, startPos, goState, remainCol, endPos, path);
                remainRow--;

                startPos = endPos;
                goState = DIR_COL_UP;
                break;

            case DIR_COL_UP:
                traverseMatrix(matrix, startPos, goState, remainRow, endPos, path);
                remainCol--;

                startPos = endPos;
                goState = DIR_ROW_RIGHT;
                break;
            }
        }

        // finish
        return path;
    }
};
```

# Answer V2：把行走方向定義成四個 direction vector，再依照順序行走（比較簡潔）
```Cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // if matrix is empty
        if(matrix.empty()) return {};

        // set the the direction of traverse: right -> down -> left -> up
        vector<vector<int>> travDir = { { 0,  1}, 
                                        { 1,  0}, 
                                        { 0, -1},
                                        {-1,  0}
                                        };

        // initial condition of traverse
        int remainRow = matrix.size();
        int remainCol = matrix[0].size();
        int travDirCnt = 0;

        // initialize the result
        vector<int> result(remainRow * remainCol);

        // traverse in spiral direction until all row / all col are traversed thoroughtly
        vector<int> travPosition = {0, -1};
        for(int travCnt = 0; travCnt < result.size();) {

            // get the direction vector
            vector<int> &Dir = travDir[ travDirCnt % travDir.size() ];

            // get the remained row / col num
            int &remainRowColNum = (travDirCnt % 2) ? (remainCol) : (remainRow);

            // the grid num in the direction
            int gridNum = (travDirCnt % 2) ? (remainRow) : (remainCol);

            // traverse throught the direction
            for(int i = 0; i < gridNum; i++) {
                // do traverse
                travPosition[0] += Dir[0];
                travPosition[1] += Dir[1];

                // fetch matrix element
                int r = travPosition[0];
                int c = travPosition[1];
                result[ travCnt++ ] = matrix[ r ][ c ];
            }

            // update the remained row or col num to be traversed
            remainRowColNum--;

            // update the traversed direction cnt
            travDirCnt++;
        }

        // finish
        return result;
    }
};
```