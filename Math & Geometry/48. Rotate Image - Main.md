# LeetCode
[48. Rotate Image](https://leetcode.com/problems/rotate-image/)

# Answer：旋轉順時鐘 - Mirrow(row + col = Const) + reverse row
```Cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // reverse rotate = transpose + row reverse

        // (0) dimenstion of matrix
        int N = matrix.size();

        // (1) transpose
        // element[ i, j ] <-> element[ j, i ]
        // row, col process
        // [0] [0, 1, 2, 3, ... N-1]
        // [1] [_, 1, 2, 3, ... N-1]
        // [2] [_, _, 2, 3, ... N-1]
        for(int i = 0; i < N; i++) {
            for(int j = (i+1); j < N; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // (2) row reverse
        for(auto &row : matrix) reverse(row.begin(), row.end());
    }
};
```

# Answer：旋轉順時鐘 - reverse row + Mirrow(Len-1 - (row + col) = 0)
```Cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // (0) check valid
        if(matrix.size() <= 1) return;

        // (1) reverse row
        // [3 2 1]
        // [6 5 4]
        // [9 8 7]
        for(auto &row : matrix) reverse(row.begin(), row.end());

        // (2) mirrow through positive diagonal line (N - row + col = 0)
        // N = matrix size - 1
        // [7 4 1]
        // [8 5 2]
        // [9 6 3]
        //
        // M[0, 0] <-> M[2, 2] offset 2 vs offset -2
        // M[0, 1] <-> M[1, 2] offset 1 vs offset -1
        // M[0, 2] <-> M[0, 2] offset 0
        // M[1, 0] <-> M[2, 1] offset 1 vs offset -1
        // M[1, 1] <-> M[1, 1] offset 0
        // M[1, 2] <-> M[0, 1] offset 1 vs offset -1
        // M[2, 0] <-> M[2, 0] offset 0
        int N = matrix.size() - 1;
        for(int r = 0; r < matrix.size(); r++) {
            for(int c = 0; c < matrix[r].size(); c++) {
                // M[r, c]: N-(r+c) = offset ( > 0)
                int offset = N-(r+c);
                if(offset == 0) break;
                
                // M[r', c']: N-(r'+c') = -offset ( < 0)
                // (r'-r, c'-c) = (1, 1) * offset
                // r' = r + offset
                // c' = c + offset
                int r2 = r + offset;
                int c2 = c + offset;

                // swap to do mirror
                swap(matrix[r][c], matrix[r2][c2]);
            }
        }
    }
};
```