# LeetCode
[48. Rotate Image](https://leetcode.com/problems/rotate-image/)

# Concept
- 正對角線鏡射 (r - c = k): a[r, c] <-> a[c, r] -> *Transpose*
	- **Transpose swap 的時候，不需要處理整個 matrix（否則會把已經 transpose 完成的，又 transpose 還原回去）**
	- **Transpose swap 的時候，先選 row (row idx)，再選 row element (col idx) -> 選 col idx 的時候從 (row idx + 1) 的地方開始即可**
		- for( row idx )
			- for( col idx = row idx + 1 : end)
- 負對角線鏡射 (r + c = k):  a[r, c] <-> a[lastColIdx - c, lastRowIdx - r] -> **transpose + reverse row + reverse col**
	- matrix 3x3
		- a[0, 0] -> a[2, 2]
		- a[0, 1] -> a[1, 2]
		- a[1, 0] -> a[2, 1]
- 正轉 90 度 (逆時針) a[r, c] <-> a[lastColIdx - c, r] -> **transpose + reverse col**
	- matrix 3x3
		- a[0, 0] -> a[2, 0]
		- a[0, 1] -> a[1, 0]
		- a[1, 0] -> a[2, 1]
- 負轉 90 度 (順時針) a[r, c] <-> a[c, lastRowIdx - r] -> **transpose + reverse row**
	- matrix 3x3
		- a[0, 0] -> a[0, 2]
		- a[0, 1] -> a[1, 2]
		- a[1, 0] -> a[2, 1]

# Answer：旋轉順時鐘 - Mirrow(row + col = Const) + reverse row
```Cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // reverse rotate = transpose + row reverse

        // (0) dimenstion of matrix
        int N = matrix.size();

        // (1) transpose
        // element[ i, j ] <-> element[ j, i ]
        // row, col process
        // [0] [0, 1, 2, 3, ... N-1]
        // [1] [_, 1, 2, 3, ... N-1]
        // [2] [_, _, 2, 3, ... N-1]
        for(int i = 0; i < N; i++) {
            for(int j = (i+1); j < N; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // (2) row reverse
        for(auto &row : matrix) reverse(row.begin(), row.end());
    }
};
```

# Answer：旋轉順時鐘 - reverse row + Mirrow(Len-1 - (row + col) = 0)
## V1：複習 1st
```Cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // (0) check valid
        if(matrix.size() <= 1) return;

        // (1) reverse row
        // [3 2 1]
        // [6 5 4]
        // [9 8 7]
        for(auto &row : matrix) reverse(row.begin(), row.end());

        // (2) mirrow through positive diagonal line (N - row + col = 0)
        // N = matrix size - 1
        // [7 4 1]
        // [8 5 2]
        // [9 6 3]
        //
        // M[0, 0] <-> M[2, 2] offset 2 vs offset -2
        // M[0, 1] <-> M[1, 2] offset 1 vs offset -1
        // M[0, 2] <-> M[0, 2] offset 0
        // M[1, 0] <-> M[2, 1] offset 1 vs offset -1
        // M[1, 1] <-> M[1, 1] offset 0
        // M[1, 2] <-> M[0, 1] offset 1 vs offset -1
        // M[2, 0] <-> M[2, 0] offset 0
        int N = matrix.size() - 1;
        for(int r = 0; r < matrix.size(); r++) {
            for(int c = 0; c < matrix[r].size(); c++) {
                // M[r, c]: N-(r+c) = offset ( > 0)
                int offset = N-(r+c);
                if(offset == 0) break;
                
                // M[r', c']: N-(r'+c') = -offset ( < 0)
                // (r'-r, c'-c) = (1, 1) * offset
                // r' = r + offset
                // c' = c + offset
                int r2 = r + offset;
                int c2 = c + offset;

                // swap to do mirror
                swap(matrix[r][c], matrix[r2][c2]);
            }
        }
    }
};
```

## V2：複習 2nd - 公式處理
```Cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
		// clockwise -> rotate -90 -> transpose + reverse row
		for(int r = 0; r < matrix.size(); r++) {
			for(int c = 0; c < matrix[r].size(); c++) {
				swap(matrix[r][c], matrix[c][r]);
			}
		}

		// reverse col
		for(auto &row : matrix) reverse(row。begin(), row.end());
    }
};
```