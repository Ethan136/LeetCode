# LeetCode
[50. Pow(x, n)](https://leetcode.com/problems/powx-n/)

# Concept
- 把 n 拆解為 2 進位 -> 這樣 n 最多只要處理 32 次即可
	- （如果一個一個乘，則 n 要處理 n 次）

- 為了做 bit manipulation，把 n 改成用 abs(n) = N 來操作
- **注意，n 的範圍是 (-2^31) to (2^31 -1)，為了避免 abs(n) 發生 overflow -> N 要使用 long long**

# Answer：N 拆解為 2 進位 + bit manipulation
## V1：N 檢查 bit(0) to bit(31)
```Cpp
class Solution {
public:
    double myPow(double x, int n) {
        // special case
        // x = 0 or 1
        if(x == 0 || x == 1) return x;

        // special case
        // n = 0 or 1
        if(n == 0) return 1;
        if(n == 1) return x;

        // set N = abs(n)
        long long N = n;
        N = abs(N);

        // check N in binary
        // ex: N = 13 -> b'1101
        // x^N = x^(b'1101) = x^(b'1000) * x^(b'0100) * x^(b'0001) = x^8 * x^4 * x^1
        double result = 1;
        double pow_i = x;
        for(int i = 0; i < 32; i++, pow_i = (pow_i * pow_i)) {
            if(N & (1 << i)) result *= pow_i;
        }

        // modify result based on n
        if(n < 0) result = 1 / result;

        // finish
        return result;
    }
};
```

## V2：N 檢查到最高 bit 位數，不用檢查 32 bits
```Cpp
class Solution {
public:
    double myPow(double x, int n) {
        // special case
        // x = 0 or 1
        if(x == 0 || x == 1) return x;

        // special case
        // n = 0 or 1
        if(n == 0) return 1;
        if(n == 1) return x;

        // set N = abs(n)
        long long N = n;
        N = abs(N);

        // check N in binary
        // ex: N = 13 -> b'1101
        // x^N = x^(b'1101) = x^(b'1000) * x^(b'0100) * x^(b'0001) = x^8 * x^4 * x^1
        double result = 1;
        double pow_i = x;
        while(N) {
            // N & bit(0)
            if(N & 1) result *= pow_i;

            // update pow_i
            pow_i *= pow_i;

            // update N
            N = (N >> 1);
        }

        // modify result based on n
        if(n < 0) result = 1 / result;

        // finish
        return result;
    }
};
```