---
ParentTask:
  - "[[bit_manipulation]]"
---

# LeetCode
[371. Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)

# Answer：檢查兩個數字每個 bit
## V1：邏輯判斷 bit 進位情況 + 迴圈中把 a / b 逐漸 bit shift right -> 比較不直覺
```Cpp

class Solution {
public:

    int getSum(int a, int b) {

		int nCarryBit = 0;
		int nResult = 0;
		for( int nBit = 0; nBit < 32; nBit++ ) {

			bool aBitOn = a & 1;
			bool bBitOn = b & 1;
			
			// 0 0
			if( ( aBitOn == false ) && ( bBitOn == false ) ) {
				nResult |= ( nCarryBit << nBit );
				nCarryBit = 0;
			}

			// 1 1
			else if( ( aBitOn == true ) && ( bBitOn == true ) ) {
				nResult |= ( nCarryBit << nBit );
				nCarryBit = 1;
			}

			// 1 0  or 0 1 -> check carry bit
			else {
				if( nCarryBit == 0 ) nResult |= ( 1 << nBit );
				else nCarryBit == 1;
			}


			a >>= 1;
			b >>= 1;
		}

		return nResult;
    }
};
```

## V2：把兩個數字的 bit 當作 10 進位原理，來計算 2 進位結果 -> 比較直覺簡單
### V2.1：複習1st - 這個概念可以，但寫法不符合題目規定
- **這邊沒有考慮到 signed int 使用 bit shift 的問題**
- **而且這個解法用到加發，也不符合題目設定**
```Cpp
#define BIT(N) (1 << (N))
class Solution {
public:
    int getSum(int a, int b) {
        int result = 0;

        for(int i = 0, bit_carry = 0; i < 32; i++) {

            int bit_a = (a & BIT(i)) ? (1) : (0);
            int bit_b = (b & BIT(i)) ? (1) : (0);

            int bit_sum = bit_a + bit_b + bit_carry;
            int cur_bit = bit_sum % 2;

            if(cur_bit) result |= BIT(i);
            bit_carry = bit_sum / 2;
        }

        return result;
    }
};
```


### V2.2：複習2nd - 正規作法（轉換成 unsigned 來做 bit operation）
- **因為 a, b 可能有負值，用 bit operation shift 的時候，先一律轉成 unsigned，後續再做操作**
- **要考慮 a, b 都檢查完之後，還有一個 carry_bit 的情況**
	- -> (5 + (-2)) 的情況中，最後這個 carry_bit 會超出 0 to 31bit 範圍，變成 32bit 而 overflow 為 0
	- **所以 5 + (-2) 的 case，雖然 (-2) 有用到 bit31，但最後結果是正數，bit31 = 0**
- **使用 2補數 + 1 處理負號 -> 是要操作 XOR 來做相加時候用的**
- **這個這個作法，是正規硬體處理 2進位加法的作法**
```Cpp
class Solution {
public:
    int getSum(int a, int b) {
        unsigned int A = a;
        unsigned int B = b;
        unsigned int result = 0;

        unsigned int cur_bitToNum = 1;
        unsigned int carry_bit = 0;
        while(A || B || carry_bit) {
            // bit on A and B
            unsigned int bit_a = (A & 1);
            unsigned int bit_b = (B & 1);

            // calculate bit add
            unsigned int cur_bit = (bit_a ^ bit_b) ^ carry_bit;
            carry_bit = (bit_a & bit_b) | (bit_b & carry_bit) | (bit_a & carry_bit);

            // update result with current bit
            if(cur_bit) result |= cur_bitToNum;

            // update for next calculation
            cur_bitToNum = (cur_bitToNum << 1);
            A = (A >> 1);
            B = (B >> 1);
        }

        return result;
    }
};
```