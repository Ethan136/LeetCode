# Question
https://leetcode.com/problems/counting-bits/submissions/1680048443/

# Answer: Normal - 直覺快速
```Cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> result(n+1, 0);
        for(unsigned int i = 0; i <= n; i++) {
            int targetNum = i;
            while(targetNum) {
                if(targetNum & 1) result[i]++;
                targetNum = (targetNum >> 1);
            }
        }
        return result;
    }
};
```
- 可以每個 bit 都檢查，從 bit(0) 每次 shift 一個 bit，檢查到 bit32 -> 這樣比較慢
- 如果是一律檢查數字的 bit 0，每次 shift 數字一個 bit 把它變小 -> 這樣在數字 shift 後如果變成 0，就可以提前終止 -> 比較快


# Answer: DP - 不是很好懂
```Cpp
#define BIT(N) (1<<N)
class Solution {
public:
    vector<int> countBits(int n) {
        // init result
        vector<int> result(n+1);

        // check num from 1 to n
        for(int num = 1, pow2NumClosestToNum = 1; num <= n; num++) {

            // if current num equals to (pow2NumClosestToNum * 2)
            // -> update pow2NumClosestToNum to the next 2^n
            int nextPow2ClosestToNum = 2 * pow2NumClosestToNum;
            if(num == nextPow2ClosestToNum) pow2NumClosestToNum = nextPow2ClosestToNum;

            // calculate bit cnt
            result[num] = 1 + result[(num - pow2NumClosestToNum)];
        }

        // finish
        return result;
    }
};

// Number N = [2^n] + [N-(2^n)]
// (1)
// 2^n = the number closest to N and is 2 to the power of n
// -> 1000... -> bit num = 1

// (2)
// N - (2^n) = the "lesser bit parts" of N
// bit num = result[num - 2^n]
```