# LeetCode
[190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)

# Answer - for loop two pointer 檢查每個 bit - 一次設定兩個 bit
- 做法直覺，但比較複雜 -> **真正的 reverse bit 對調的概念**
```Cpp
#define BIT(N) (1<<N)
#define GET_BIT_01_N_OF_VAL(val, N) ((val & BIT(N)) >> N)
#define SET_BIT_01_N_OF_VAL(val, N, set01) val=((val & ~BIT(N)) | (set01*BIT(N)))
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        for(int i = 0, j = 31; i < j; i++, j--) {
            uint32_t  bit_i_01_val = GET_BIT_01_N_OF_VAL(n, i);
            uint32_t  bit_j_01_val = GET_BIT_01_N_OF_VAL(n, j);

            SET_BIT_01_N_OF_VAL(n,i,bit_j_01_val);
            SET_BIT_01_N_OF_VAL(n,j,bit_i_01_val);
        }
        return n;
    }
};
```

# Answer - while loop modify N 檢查到最後一個 non-zero bit
- **寫法也蠻簡潔的**
- **而且速度比較快**
```Cpp
#define BIT(N)  (1 << N)
class Solution {
public:
    int reverseBits(int n) {

        int result = 0;

        // check until the max-non-zero bit of n
        int revBitIdx = 31;
        while(n) {

            // reversely set the bit to the result
            if(n & 1) result |= BIT(revBitIdx);

            // n shift-bit rightward
            n = (n >> 1);

            // update the next bit for reverse
            revBitIdx--;
        }

        return result;
    }
};
```