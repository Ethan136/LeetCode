# LeetCode
[190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)

# Answer - for loop two pointer 檢查每個 bit - 一次設定兩個 bit
- 做法直覺，但比較複雜 -> **真正的 reverse bit 對調的概念**
```Cpp
#define BIT(N) (1<<N)
#define GET_BIT_01_N_OF_VAL(val, N) ((val & BIT(N)) >> N)
#define SET_BIT_01_N_OF_VAL(val, N, set01) val=((val & ~BIT(N)) | (set01*BIT(N)))
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        for(int i = 0, j = 31; i < j; i++, j--) {
            uint32_t  bit_i_01_val = GET_BIT_01_N_OF_VAL(n, i);
            uint32_t  bit_j_01_val = GET_BIT_01_N_OF_VAL(n, j);

            SET_BIT_01_N_OF_VAL(n,i,bit_j_01_val);
            SET_BIT_01_N_OF_VAL(n,j,bit_i_01_val);
        }
        return n;
    }
};
```

# Answer - while loop modify N 檢查到最後一個 non-zero bit
- **寫法也蠻簡潔的**
- **而且速度比較快**
```Cpp
#define BIT(N)  (1 << N)
class Solution {
public:
    int reverseBits(int n) {

        int result = 0;

        // check until the max-non-zero bit of n
        int revBitIdx = 31;
        while(n) {

            // reversely set the bit to the result
            if(n & 1) result |= BIT(revBitIdx);

            // n shift-bit rightward
            n = (n >> 1);

            // update the next bit for reverse
            revBitIdx--;
        }

        return result;
    }
};
```

# Answer：複習 2dn - 檢查 N bit(a) 的時候，result 乘上 bit(31-a)
- **先一律轉換成 unsigned int，算完再轉回去**
- **這邊的 revBitNum32 必須用 unsigned，不然會出錯，說明如下** (signed num 使用 bit shift，sign value 也會保留)
>`int revBitNum32 = (1 << 31);`  
> 這行在 32-bit `int` 下會變成**負數**（或觸發未定義行為），之後你又對它做右移，屬於**對帶符號整數做算術右移**，結果不受保證。接著把這個
> 值加進 `result`，整個輸出就會壞掉。

```Cpp
class Solution {
public:
    int reverseBits(int n) {
        unsigned int N = n;

        unsigned int result = 0;
        unsigned int revBitNum32 = (1 << 31);
        while(N) {
            if(N & 1) result += revBitNum32;

            N = (N >> 1);
            revBitNum32 = (revBitNum32 >> 1);
        }
        return result;
    }
};
```
