# LeetCode
[7. Reverse Integer](https://leetcode.com/problems/reverse-integer/)

# Answer：轉換成 long long 作計算

# Concept
- **注意： result = x%10 + result*10 這個算法，不論在 x > 0 或是 x < 0 都適用！**

## V1 - 計算最簡單，但速度慢 -> 應該是因為使用 * 0.1 造成轉換為 double 作計算降低速度
**這個不符合規範，因為使用 long long (題目要求不要用 64bit value)**
```Cpp
class Solution {
public:
    int reverse(int x) {
        long long result = 0;
        //if((-x > 2^31-1) || (-x < −2^31))  // error ，在用 -x 的時候就會overflow了，之後便無法成功比較
        // when overflow -> 會正負變號 -> 不行，有些overflow 不是這個形式
        while(x){
            result = x%10 + result*10;
            x = x * 0.1;
        }
        return (result < INT_MIN || result > INT_MAX ) ? 0 : result;
        
    }
};
```

## V2 - 轉換成絕對數值作計算 -> 其實不用轉絕對值，就可以進行計算
**這個不符合規範，因為使用 long long (題目要求不要用 64bit value)**
```Cpp
class Solution {
public:
    int reverse(int x) {
        long long abs_X = abs( (long long)(x) );
        long long abs_X_rev = 0;

        while(abs_X) {
            // shift previous result by * 10
            abs_X_rev *= 10;

            // add current digit
            abs_X_rev += abs_X % 10;

            // origin num shift right by / 10
            abs_X /= 10;
        }

        long long X_rev = (x >= 0) ? (abs_X_rev) : (-abs_X_rev);

        if(X_rev > INT_MAX || X_rev < INT_MIN) return 0;
        return (int)(X_rev);
    }
};
```


# Answer：直接 int 作計算，一邊轉換一邊檢查是否超過範圍 - 正解
## V1：第一次寫的
```Cpp
#define DEBUG (0)
class Solution {
public:
    int reverse(int x) {

        // initialize result
        int revX = 0;

        // do value reverse until there's no remained x
        for(;x != 0; x/=10) {

            // the least digit of the current x
            int digit = x % 10;

            // check if 10*revX exceeds INT_MAX / INT_MIN
            if(revX > INT_MAX/10 || revX < INT_MIN/10) return 0;

            // check if 10*revX + digit exceeds INT_MAX
            if(revX == INT_MAX/10 && digit > INT_MAX%10) return 0;

            // check if 10*revX + digit exceeds INT_MIN
            if(revX == INT_MIN/10 && digit < INT_MIN%10) return 0;

            // calculate the reversed number of X
            revX = (10 * revX) + digit;

#if DEBUG
cout << "digit: "<< digit << endl;
cout << "revX: " << revX << endl;
#endif
        }

        // finish
        return revX;
    }
};
```

## V2：複習2nd時候寫的
```Cpp
class Solution {
public:
    int reverse(int x) {
        int result = 0;
        while(x) {
            // check result * 10 is valid and do operation for reverse num digit
            if( (result > (INT_MAX/10)) || (result < (INT_MIN/10)) ) return 0;
            result *= 10;

            // check result is valid after adding current digit num and do operation
            int curXMod10 = (x % 10);
            if( (curXMod10 > 0) && (result > (INT_MAX - curXMod10)) ) return 0;
            if( (curXMod10 < 0) && (result < (INT_MIN - curXMod10)) ) return 0;
            result += curXMod10;

            // update x
            x = x / 10;
        }
        return result;
    }
};
```