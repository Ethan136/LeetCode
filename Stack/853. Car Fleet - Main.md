# LeetCode
[853. Car Fleet](https://leetcode.com/problems/car-fleet/)

# Note
- [[Compare 裏面的 Lambda Cmp Func]] -> `[](const auto& a, const auto& b) { return (a.distance <= b.distance); }`

# Answer - V1: 使用 Stack 從前往後檢查 (StackSize 即為 fleet num)
```Cpp
class Solution {
	struct tPathInfo {
		int distance;
		double timeToArrive;
	};

public:
	int carFleet(int target, vector<int>& position, vector<int>& speed) {
		// car arrival info
		vector<tPathInfo> StartInfoVec(position.size());
		for(int i = 0; i < StartInfoVec.size(); i++) {
			StartInfoVec[i].distance = (target - position[i]);
			StartInfoVec[i].timeToArrive = double(StartInfoVec[i].distance) / double(speed[i]);
		}

		// sort the arrival info by "start position" & "arrive time"
		// -> to make sure the car with position closer to target will be in the smaller index
		sort(StartInfoVec.begin(), StartInfoVec.end(), 
			[](const auto& a, const auto& b) {
				return (a.distance <= b.distance);
			});

		// use a stack to store the "head car info" of each fleets -> set first car as fleet head
		stack<tPathInfo> fleetHeadCarPathInfo;
		fleetHeadCarPathInfo.push(StartInfoVec.front());
		
		// check all cars (from the second car)
		for(int i = 1; i < StartInfoVec.size(); i++) {

			// (1)if the current fleet takes longer than the next car to arrive
			// -> these two car is in the same fleet -> no need to add new fleet head car
			if(fleetHeadCarPathInfo.top().timeToArrive >= StartInfoVec[i].timeToArrive) continue;

			// (2)if the current fleet in check will arrive earlier
			// -> the next car is the head of next fleet -> add to new fleet head car
			fleetHeadCarPathInfo.push(StartInfoVec[i]);
		}

		return fleetHeadCarPathInfo.size();
	}
};
``` 
- 想法 **計算每台車理想上所需時間 -> 用來檢查是否車子會互相追上**
	- 如果一臺車要 3 秒，1 台車只要1秒 -> 3秒的車如果在 1 秒的前面 -> 會追上
	- **呈上，所以需要先依照當下位置做 sort，然後計算每臺車的所需時間**
- 檢查的時候用 stack
	- 從比較近的開始檢查：當前的車當作車頭
	- 後面的車如果所需時間比較短 -> 會追上車頭 -> 視爲一個 fleet
	- 後面的車如果所需時間比較久 -> 不會追上車頭 -> 視爲一個新的 fleet
- **C++ 內建的 pair 可以做比大小 -> vector<pair\> 可以執行 sort**
- **C++ 自定資料結構丟到 vector 裏面做 sort**
	- 參考 [[347. Top K Frequent Elements - Main]]


# Answered - V2: 不使用 stack 從後往前檢查 (單一變數記錄 fleet num)
## V2.1 複習1st
```Cpp
class Solution {
private:
    struct pathInfo {
        int startPos;
        double time;
    };

public:
    int carFleet(int target, vector<int>& position, vector<int>& speed) {

        // create a vector with start pos & arrival time
        vector<pathInfo> pathInfoVec(position.size());
        for(int i = 0; i < position.size(); i++) {
            pathInfoVec[i] = {  .startPos = position[i], 
                                .time = ((double)(target-position[i]) / (double)speed[i])};
        }

        // sort the path info based on start position
        auto cmpPathStartPos = [](pathInfo &a, pathInfo &b) {return a.startPos < b.startPos;};
        sort(pathInfoVec.begin(), pathInfoVec.end(), cmpPathStartPos);

        // check from last car backward to first car
        // (1) last car init as one fleet
        int fleetNum = 1;
        double fleetArrivTime = pathInfoVec.back().time;

        // (2) check previous cars
        int carBeforeLastIdx = (int)(pathInfoVec.size()) - 2;
        for(int i = carBeforeLastIdx; i >= 0; i--) {

            // check whether the previous car could catch up the fleet -> join the fleet
            if(pathInfoVec[i].time <= fleetArrivTime)  continue;

            // if the previous car can not catch up the fleet -> new fleet
            fleetNum++;
            fleetArrivTime = pathInfoVec[i].time;
        }

        return fleetNum;
    }
};
```

## V2.2 複習2nd
```Cpp
class Solution {
private:
    struct reachInfo {
        int startPos;
        double reachTime;
    };
public:
    int carFleet(int target, vector<int>& position, vector<int>& speed) {
        if(position.size() == 0) return 0;
        if(position.size() == 1) return 1;

        // check from position to target time
        // earlier pos with faster time -> group with later position cars
        // if we don't know whether the later car goes slower and would make a group with current car -> put to stack
        // -> or check from later position to earlier position
        vector<reachInfo> allPosReachInfo(position.size());
        for(int i = 0; i < allPosReachInfo.size(); i++) {
            allPosReachInfo[i] = {position[i], (double)(target - position[i]) / (double)(speed[i])};
        }

        // sort the start positions
        auto cmpReachInfo = [](auto &a, auto &b) {return a.startPos < b.startPos;};
        sort(allPosReachInfo.begin(), allPosReachInfo.end(), cmpReachInfo);

        // last car as one group
        int groupNum = 1;
        double laterGroupReachTime = allPosReachInfo.back().reachTime;

        // check from last-1 car to 1st car (order by start position)
        for(int i = allPosReachInfo.size()-2; i >= 0; i--) {
            // combine as one group
            if(allPosReachInfo[i].reachTime <= laterGroupReachTime) {
                continue;
            }
            // seperate group reach at different time
            // (1) add new group
            groupNum++;

            // (2) focus on the previous group
            laterGroupReachTime = allPosReachInfo[i].reachTime;
        }

        // finish
        return groupNum;
    }
};
```

# Answer - V3：sort 初始位置 + 使用 stack 模板
## V3.1 - 複習2nd + 模板練習
```Cpp
class Solution {
public:
    int carFleet(int target, vector<int>& position, vector<int>& speed) {
        if(position.size() == 0) return 0;
        if(position.size() == 1) return 1;

		vector<pair<int, double>> startPosWithReachTime(position.size());
		for(int i = 0; i < startPosWithReachTime.size(); i++) {
			startPosWithReachTime[i] = {position[i], (double)(target - position[i]) / (double)(speed[i])};
		};
		auto cmpStartPos = [](auto &a, auto &b) {return a.first < b.first;};
		sort(startPosWithReachTime.begin(), startPosWithReachTime.end(), cmpStartPos);

		stack<int> groupPivotCarIdx;
		for(int i = 0; i < startPosWithReachTime.size(); i++) {

			// check current car with previous groups' car
			double curCarReachTime = startPosWithReachTime[i].second;
			while(groupPivotCarIdx.size()) {
				// (1) check prvious group reach time
				double prevGroupCarReachTime = startPosWithReachTime[groupPivotCarIdx.top()].second;

				// (2) if current car reach later -> previous car group will join current car
				if(curCarReachTime >= prevGroupCarReachTime) groupPivotCarIdx.pop();
				else break;
			}

			// put current car into group
			groupPivotCarIdx.push( i );
		}
        return groupPivotCarIdx.size();
    }
};
```