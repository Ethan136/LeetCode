# LeetCode
[853. Car Fleet](https://leetcode.com/problems/car-fleet/)

# Note
- [[Compare 裏面的 Lambda Cmp Func]] -> `[](const auto& a, const auto& b) { return (a.distance <= b.distance); }`

# Answer - V1: 使用 Stack 從前往後檢查 (StackSize 即為 fleet num)
```Cpp
class Solution {
	struct tPathInfo {
		int distance;
		double timeToArrive;
	};

public:
	int carFleet(int target, vector<int>& position, vector<int>& speed) {
		// car arrival info
		vector<tPathInfo> StartInfoVec(position.size());
		for(int i = 0; i < StartInfoVec.size(); i++) {
			StartInfoVec[i].distance = (target - position[i]);
			StartInfoVec[i].timeToArrive = double(StartInfoVec[i].distance) / double(speed[i]);
		}

		// sort the arrival info by "start position" & "arrive time"
		// -> to make sure the car with position closer to target will be in the smaller index
		sort(StartInfoVec.begin(), StartInfoVec.end(), 
			[](const auto& a, const auto& b) {
				return (a.distance <= b.distance);
			});

		// use a stack to store the "head car info" of each fleets -> set first car as fleet head
		stack<tPathInfo> fleetHeadCarPathInfo;
		fleetHeadCarPathInfo.push(StartInfoVec.front());
		
		// check all cars (from the second car)
		for(int i = 1; i < StartInfoVec.size(); i++) {

			// (1)if the current fleet takes longer than the next car to arrive
			// -> these two car is in the same fleet -> no need to add new fleet head car
			if(fleetHeadCarPathInfo.top().timeToArrive >= StartInfoVec[i].timeToArrive) continue;

			// (2)if the current fleet in check will arrive earlier
			// -> the next car is the head of next fleet -> add to new fleet head car
			fleetHeadCarPathInfo.push(StartInfoVec[i]);
		}

		return fleetHeadCarPathInfo.size();
	}
};
``` 
- 想法 **計算每台車理想上所需時間 -> 用來檢查是否車子會互相追上**
	- 如果一臺車要 3 秒，1 台車只要1秒 -> 3秒的車如果在 1 秒的前面 -> 會追上
	- **呈上，所以需要先依照當下位置做 sort，然後計算每臺車的所需時間**
- 檢查的時候用 stack
	- 從比較近的開始檢查：當前的車當作車頭
	- 後面的車如果所需時間比較短 -> 會追上車頭 -> 視爲一個 fleet
	- 後面的車如果所需時間比較久 -> 不會追上車頭 -> 視爲一個新的 fleet
- **C++ 內建的 pair 可以做比大小 -> vector<pair\> 可以執行 sort**
- **C++ 自定資料結構丟到 vector 裏面做 sort**
	- 參考 [[347. Top K Frequent Elements - Main]]


# Answered - V2: 不使用 stack 從後往前檢查 (單一變數記錄 fleet num)
```Cpp
class Solution {
private:
    struct pathInfo {
        int startPos;
        double time;
    };

public:
    int carFleet(int target, vector<int>& position, vector<int>& speed) {

        // create a vector with start pos & arrival time
        vector<pathInfo> pathInfoVec(position.size());
        for(int i = 0; i < position.size(); i++) {
            pathInfoVec[i] = {  .startPos = position[i], 
                                .time = ((double)(target-position[i]) / (double)speed[i])};
        }

        // sort the path info based on start position
        auto cmpPathStartPos = [](pathInfo &a, pathInfo &b) {return a.startPos < b.startPos;};
        sort(pathInfoVec.begin(), pathInfoVec.end(), cmpPathStartPos);

        // check from last car backward to first car
        // (1) last car init as one fleet
        int fleetNum = 1;
        double fleetArrivTime = pathInfoVec.back().time;

        // (2) check previous cars
        int carBeforeLastIdx = (int)(pathInfoVec.size()) - 2;
        for(int i = carBeforeLastIdx; i >= 0; i--) {

            // check whether the previous car could catch up the fleet -> join the fleet
            if(pathInfoVec[i].time <= fleetArrivTime)  continue;

            // if the previous car can not catch up the fleet -> new fleet
            fleetNum++;
            fleetArrivTime = pathInfoVec[i].time;
        }

        return fleetNum;
    }
};
```