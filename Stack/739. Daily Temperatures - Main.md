# LeetCode
[739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

# Concept
- **想法上來說，是會想用一個 heap 來做自動排序，找出溫度最高 -> 低 / 低 -> 高**
- **但 Heap 其實和這題概念不合，這題是「只要溫度比較高即可，不需要溫度最高」**
- 此外，由於只要溫度變高，就可以計算結果 -> **只有在溫度降低的時候，才不確定之後會不會變高而需要把資訊存起來** ->> **存起來的資訊，一定是溫度逐漸降低** 

# Answer: 把當下沒辦法直接確定要等幾天的日期，丟都 pending stack - O(N)
## V1 - 以 next day 為基底進行檢查 (從 day1 開始)
```Cpp
class Solution {
public:
	vector<int> dailyTemperatures(vector<int>& temperatures) {

		// initialize result
		vector<int> result(temperatures.size(), 0);

		// the index waiting for the warmer day
		stack<int> pendingDay;

		// check all temperature
		for(int nextDay = 1; nextDay < temperatures.size(); nextDay++) {

			// check day index
			int checkDay = nextDay-1;

			// if not get warmer
			if(temperatures[checkDay] >= temperatures[nextDay]) {
				pendingDay.push(checkDay);
				continue;
			}

			// if it's warmer now
			result[checkDay] = 1;

			// check all the pending days
			while(pendingDay.size()) {
				int latestPendingDay = pendingDay.top();
				if(temperatures[latestPendingDay] >= temperatures[nextDay] ) break;

				result[latestPendingDay] = (nextDay - latestPendingDay);
				pendingDay.pop();
			}
		}

		return result;
	}
};
```
- 如果隔天馬上變暖 -> 馬上更新
- 如果隔天沒變暖 -> 當下 index 記錄到 stack 裏面 -> *等後續遇到變暖的時候再拿出來比對*
- 這個 stack 裏面的數值更新機制，類似 [[239. Sliding Window Maximum - Main]]
- index 使用注意
	- 如果從 index0 開始檢查，檢查到 last index -> **last index 無法檢查隔天的天氣（index 超出範圍）**
	- 但可以 index1 開始檢查，檢查到 last index -> *每次檢查的時候，是『往前一天反查』*


## V2 - 以 cur day 為基底往前檢查 (從 day1 開始) -> 比較簡潔
### V2.1：複習1st
```Cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {

        stack<int> pendingDayIdx;
        pendingDayIdx.push(0);

        vector<int> result(temperatures.size(), 0);
        for(int i = 1; i < temperatures.size(); i++) {

			// if the minimal temp of pending day is less than current day temp -> update waiting day count
            while( pendingDayIdx.size() && (temperatures[pendingDayIdx.top()] < temperatures[i]) ) {
                result[pendingDayIdx.top()] = i - pendingDayIdx.top();
                pendingDayIdx.pop();
            }

			// push current day index to pending
            pendingDayIdx.push(i);
        }

        return result;
    }
};
```
- **注意： pendingDayIdx stack 對應的溫度，一定是從 bottom -> top 逐漸遞減**
	- 這是因為一旦發生溫度增加，則 stack top 就會把 day idx pop 出來
	- 所以 stack 裡面的資訊，其實在 push 當下，就已經做過某種 sort

### V2.2：複習2nd
```Cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> result(temperatures.size(), 0);

        // indices wait for check
        stack<int> pendingIdx;
        for(int i = 0; i < temperatures.size(); i++) {
            // check pending temperature before today
            while(pendingIdx.size() && (temperatures[ pendingIdx.top() ] < temperatures[i])) {
                result[ pendingIdx.top() ] = i - pendingIdx.top();
                pendingIdx.pop();
            }

            // add today to pending
            pendingIdx.push(i);
        }

        return result;
    }
};
```

## V3 - 為 V2 的改版，用 vector + indicator 來實現 stack 加速
```Cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {

        int stackLen = 0;
        vector<int> pendingDayIdx(temperatures.size(), 0);
        pendingDayIdx[stackLen++] = 0;

        vector<int> result(temperatures.size(), 0);
        for(int i = 1; i < temperatures.size(); i++) {

            while( stackLen && (temperatures[ pendingDayIdx[stackLen-1] ] < temperatures[i]) ) {
                result[ pendingDayIdx[stackLen-1] ] = i - pendingDayIdx[stackLen-1];
                stackLen--;
            }

            pendingDayIdx[stackLen++] = i;
        }

        return result;
    }
};
```