# LeetCode
[84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

# Answer: V1 - stack with restrict ascendent value (寫法比較複雜)
```Cpp
class Solution {
public:
	int largestRectangleArea(vector<int>& heights) {
		// initialize the max area result
		int maxAreaResult = 0;

		// use a stack to record the index which is waiting to be evaluated
		// add a dummy index with -1 to inidcate that the left boundry
		stack<int> pendingIndices;

		// in order to evaluate the last index of height
		// -> augment both the left / right sides of heights with "dummy zero height"
		// -> (1) augment right -> used as the "right index of the last bar"
		int checkHeightNum = heights.size();
		heights.push_back(0);

		// check the heights
		// -> r = "right index of the bar"
		// -> i = index of current bar
		for(int i = 0, r = 1; i < checkHeightNum; i++, r++) {

			// (0) variables for calculation process
			int areaOnCheckedBar;
			int areaStartIdx;
			int areaEndIdx;

			// (1) if the next one is "larger" than the current one
			// -> the current bar height could be extend to the next bar with same height
			// -> the current bar & next bar merge to a rectangle
			// -> the rectangle area of the current bar could be extended and the area may be increasing
			// -> the rectangle area of the current bar is not certain
			// -> put in the pending stack
			if(heights[i] <= heights[i+1]) {
				pendingIndices.push(i);
				continue;
			}

			// (2) if the next one is "smaller than the current one"
			// -> the rectangular area formed by the current bar height can be certainlly evaluated
			// -> the pending bar is smaller than the current one
			// -> the width = (pending bar right, current bar right]
			areaEndIdx = r;
			areaStartIdx = pendingIndices.empty() ? 0 : pendingIndices.top()+1;
			areaOnCheckedBar = heights[i] * (areaEndIdx - areaStartIdx);
			maxAreaResult = max(areaOnCheckedBar, maxAreaResult);

			// (3) also, since the next bar is smaller
			// -> the area of the previously pending bar can be certainly evaluated "if they are taller than the next bar"
			// -> evaluate all the "previously smaller bars" which has not been evaluated 
			// -> the width = (the bar smaller than the pending in stack, current bar right]
			while(pendingIndices.size() ) {

				// check height of the pending bar is smaller than the next bar
				int H = heights[ pendingIndices.top() ];
				if( H <= heights[i+1]) break;
				pendingIndices.pop();

				areaEndIdx = r;
				areaStartIdx = pendingIndices.empty() ? 0 : (pendingIndices.top()+1);
				areaOnCheckedBar = H * (areaEndIdx - areaStartIdx);
				maxAreaResult = max(areaOnCheckedBar, maxAreaResult);
			}
		}
		return maxAreaResult;

	}
};
``` 
- 執行機制
	- 從左往右檢查
		- bar height 使用 0 base index i
		- bar width 由於牽涉到『當前 index 的矩形右端點是在 index+1』 -> 使用另外一個變數 r 來當作矩形右端點 (r = i + 1)
			- **最後一個 bar 的矩形右端點 index 爲 invalid -> 擴充 height 往右加一格 dummy 0-height**
			- **這樣做可以檢查邊界條件判斷，比較舒服**
	- 下一個 bar 的高度比目前高
		- (1) 目前的 bar 可以繼續往後延伸建立矩形 -> 目前 bar 還無法計算面積 -> 放到 stack

	- 下一個 bar 的高度比目前低
		- (1) 目前的 bar 無法繼續往後延伸建立矩形 -> 目前 bar 的面積可以計算
		- (2) 此時，*如果 stack 裏面有先前的 bar，代表先前的 bar 比目前的低*，但『有可能比 next bar 還高』
			- -> **先前的 bar 如果比 nextbar 還高，也可以確定面積**


# Answer: V2 - stack with restrict ascending value (寫法比較簡單)
```Cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> pendingHeightIdx;
        pendingHeightIdx.push(0);

        int maxRecArea = heights[0];
        for(int i = 1; i <= heights.size(); i++) {

            // if the current index is out of heights -> serve as zero height
            int curHeight = (i < heights.size()) ? (heights[i]) : (0);

            // if current height taller than stack.top height
            // -> not sure whether the current hight could form a rec with larger area -> put in stack
            if(curHeight > heights[ pendingHeightIdx.top() ]) {
                pendingHeightIdx.push(i);
                continue;
            }

            // if current height the same as stack.top height
            if(curHeight == heights[ pendingHeightIdx.top() ]) {
                continue;
            }

            // if current height shorten than stack.top height
            // -> extend the current height leftward to previous pending heights
            int shorterHeightShiftToIdx = i;
            while( pendingHeightIdx.size() && (curHeight < heights[ pendingHeightIdx.top() ]) ) {

                // (1) the taller rec stored in flat height
                int tallerRecArea = heights[ pendingHeightIdx.top() ] * (i - pendingHeightIdx.top());

                // (2) taller rec area vs with max recorded area
                maxRecArea = max( maxRecArea, tallerRecArea);

                // (3) the shorter height can be equivalently shift left to the index of the taller height for area extension
                shorterHeightShiftToIdx = pendingHeightIdx.top();

                // (4) pop out the taller height since the extend condition of this rec is terminated
                pendingHeightIdx.pop();
            }

            // (5) shift the current height to the most possible left index (which is used to be taller height)
            heights[shorterHeightShiftToIdx] = curHeight;

            // (6) push the shorter height into the stack with the most possible shift-left index 
            pendingHeightIdx.push(shorterHeightShiftToIdx);
        }

        return maxRecArea;
    }
};
```
- **pending stack: 還無法決定面積的 height**
- **情況1：如果當前的高度變高 -> 先前的 height 可以延伸，而且當前的 height 也可能可以往後延伸** -> 當前的 height 放到 pending stack
- **情況2：如果當前的高度不變 -> 先前的 height 可以延伸，而去當前的 height 可以和先前的 height 合併** -> 當前的 height 不用放到 pending stack
- **情況3：如果當前的高度變矮 -> 先前的 height 無法延伸**
	- while: 先前 pending stack 裡面的 height 如果比目前的高 -> pop 出來
		- 計算面積，並更新 max area
		- 記錄這個 height 的 index -> 這個 height 比目前的高，則代表 目前 height 如果要計算面積，可以把它平移到先前的 index 來作為起始點
		- **注意：這邊 pop 的時候，要先檢查 pending stack size > 0**
	- 前一個步驟執行完畢後，pending stack 可能是空的，也可能是裡面的 height 比目前的矮
		- 這時候把目前的 height 平移到「最後一次 pop 出來的 height index」 -> 這個 last pop height index 就是「這個 height 往左最多可以平移到哪個地方開始計算面積」
			- heights[ last_pop_height_idx ] = cur height
		- 並且再把 cur height 放到 pending stack 裡面
- **終止情況：用上面這個方式計算，如果 heights 都是嚴格遞增，則檢查完 heights 後，pending stack 裡面會塞一堆 heights 還沒處理** -> **延伸一筆 index = heights.size() 的計算，此時 cur height 直接視為 0 -> 觸法 termination**