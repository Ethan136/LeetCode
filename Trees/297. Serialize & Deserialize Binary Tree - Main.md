# LeetCode
[297. Serialize & Deserialize Binary Tree](https://neetcode.io/solutions/serialize-and-deserialize-binary-tree)

# Answer
## DFS V1: streamstring (太過複雜，搞死自己)
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
#define DEBUG (0)
#define NODE_SPLIT_STR  ","
#define NULL_NODE_STR   "n"
#define NODE_SPLIT_CHAR NODE_SPLIT_STR[0]

class Codec {
private:
#if DEBUG
    void debugCheckSerialize(TreeNode* root) {
        serialize(root);
    }

    void deserializCheckTreeStr(string &str ) {
        deque<string> dequeStr;
        stringstream streamStr(str);
        string segmentStr;
        while(getline(streamStr, segmentStr, NODE_SPLIT_CHAR)) dequeStr.push_back(segmentStr);
        cout<<endl<<"[deserialize Tree Str]"<<endl;
        for(auto i = 0; i < dequeStr.size(); i++) {
            cout<<dequeStr[i]<<", ";
        }
        cout<<endl;
    }
#else
#define debugCheckSerialize(_DUMMY_INPUT_)
#define deserializCheckTreeStr(_DUMMY_INPUT_)
#endif

    bool buildOneNodeFronTreeStreamStr(stringstream &streamStr, TreeNode*& newNode) {
        string nodeStr;
        if(!getline(streamStr, nodeStr, NODE_SPLIT_CHAR) || nodeStr.empty()) {
            return false;
        }

        if(nodeStr == NULL_NODE_STR) {
            newNode = nullptr;
        }
        else {
            newNode = new TreeNode(stoi(nodeStr));
        }

#if DEBUG
cout<<"[Create Node] "<<nodeStr<<endl;
#endif

        return true;
    }

public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        
#if DEBUG
cout<<"[Serialize Str]"<<endl;
#endif
        // the stack to store the nodes where the children have not been totally traversed
        stack<TreeNode*> pendingNodes;
        pendingNodes.push(root);

        // initialize result
        string serializeStr = "";

        // traverse through the tree
        while(!pendingNodes.empty()) {
            // get one pending node
            TreeNode *node = pendingNodes.top();
            pendingNodes.pop();

            // node str
            if(!node) {
                serializeStr += NULL_NODE_STR;
            }
            else {
                serializeStr += to_string(node->val);
                pendingNodes.push(node->right);
                pendingNodes.push(node->left);
            }

            // split str
            serializeStr += NODE_SPLIT_STR;
        }

#if DEBUG
cout<<serializeStr<<endl;
#endif
        return serializeStr;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {

        // debug print
        deserializCheckTreeStr(data);

        // convert string to stream for de-serialization
        stringstream streamStr(data);

        // create root node
        TreeNode* root;
        if(buildOneNodeFronTreeStreamStr(streamStr, root)==false) return nullptr;

        // a stack to store nodes of which the child nodes has not been fully proceeded
        stack<TreeNode*> pendingNodes;
        TreeNode* traverseNode = root;

        // build tree
        while(traverseNode || !pendingNodes.empty()) {

            // (1) Traverse and build node to the left end of the current "straight branch"
            //     ONLY push node to pending stack in this phase
            TreeNode *leftChildNode;
            while(traverseNode) {

                // build child node of the current traverse node
                if(!buildOneNodeFronTreeStreamStr(streamStr, leftChildNode)) return root;

                // push the traversed node to pending stack
                pendingNodes.push(traverseNode);

                // link to child node
                traverseNode->left = leftChildNode;

                // traverse to child
                traverseNode = traverseNode->left;

                // debug check node build condition
                debugCheckSerialize(root);
            }

            // (2) Build the right child of the leftest un-finished node
            TreeNode *rightChildNode;
            if(!buildOneNodeFronTreeStreamStr(streamStr, rightChildNode)) return root;

            // (3) the latest node on the right side has been created
            // -> both the left / right children of this node has been created
            // -> pop out the node in pending stack
            pendingNodes.top()->right = rightChildNode;
            pendingNodes.pop();

            // debug check node build condition
            debugCheckSerialize(root);

            // (4) if the right child exist -> traverse to this node
            if(rightChildNode) {
                traverseNode = rightChildNode;
                continue;
            }
        }

        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```
## BFS V1: streamstring
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
#define DEBUG (0)
#define NODE_SPLIT_STR  ","
#define NULL_NODE_STR   "n"
#define NODE_SPLIT_CHAR NODE_SPLIT_STR[0]

class Codec {
private:
#if DEBUG
    void debugCheckSerialize(TreeNode* root) {
        serialize(root);
    }

    void deserializCheckTreeStr(string &str ) {
        deque<string> dequeStr;
        stringstream streamStr(str);
        string segmentStr;
        while(getline(streamStr, segmentStr, NODE_SPLIT_CHAR)) dequeStr.push_back(segmentStr);
        cout<<endl<<"[deserialize Tree Str]"<<endl;
        for(auto i = 0; i < dequeStr.size(); i++) {
            cout<<dequeStr[i]<<", ";
        }
        cout<<endl;
    }
#else
#define debugCheckSerialize(_DUMMY_INPUT_)
#define deserializCheckTreeStr(_DUMMY_INPUT_)
#endif

    bool buildOneNodeFronTreeStreamStr(stringstream &streamStr, TreeNode*& newNode) {
        string nodeStr;
        if(!getline(streamStr, nodeStr, NODE_SPLIT_CHAR) || nodeStr.empty()) {
            return false;
        }

        if(nodeStr == NULL_NODE_STR) {
            newNode = nullptr;
        }
        else {
            newNode = new TreeNode(stoi(nodeStr));
        }

#if DEBUG
cout<<"[Create Node] "<<nodeStr<<endl;
#endif

        return true;
    }

public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        
#if DEBUG
cout<<"[Serialize Str]"<<endl;
#endif
        // initialize result
        string serializeStr = "";

        // the queue to store the nodes of each layer
        queue<TreeNode*> curLayerNodes;
        queue<TreeNode*> nextLayerNodes;

        // push the root to current layer nodes queue
        curLayerNodes.push(root);

        // traverse through the tree
        while(!curLayerNodes.empty()) {

            // finish all the nodes of the current layer
            while(!curLayerNodes.empty()) {
                // get one node of the current layer
                TreeNode *node = curLayerNodes.front();
                curLayerNodes.pop();

                // node str
                if(!node) {
                    serializeStr += NULL_NODE_STR;
                }
                else {
                    serializeStr += to_string(node->val);
                    nextLayerNodes.push(node->left);
                    nextLayerNodes.push(node->right);
                }

                // split str
                serializeStr += NODE_SPLIT_STR;
            }

            // swap queue of current layer & next layer
            swap(curLayerNodes, nextLayerNodes);
        }

#if DEBUG
cout<<serializeStr<<endl;
#endif
        return serializeStr;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {

        // debug print
        deserializCheckTreeStr(data);

        // convert string to stream for de-serialization
        stringstream streamStr(data);

        // create root node
        TreeNode* root;
        if(buildOneNodeFronTreeStreamStr(streamStr, root)==false || !root) return nullptr;

        // the queue to store the nodes of each layer
        queue<TreeNode*> curLayerNodes;
        queue<TreeNode*> nextLayerNodes;

        // push the root to current layer nodes queue
        curLayerNodes.push(root);

        // rebuild the tree from layer nodes
        while(!curLayerNodes.empty()) {

            // finish all the nodes of current layer
            while(!curLayerNodes.empty()) {

                // pop one node from current layer
                TreeNode* node = curLayerNodes.front();
                curLayerNodes.pop();

                // create left child of current node & push it to next layer node queue if valid
                if(buildOneNodeFronTreeStreamStr(streamStr, node->left)==false) return root;
                if(node->left) nextLayerNodes.push(node->left);

                // create right child of current node & push it to next layer node queue if valid
                if(buildOneNodeFronTreeStreamStr(streamStr, node->right)==false) return root;
                if(node->right) nextLayerNodes.push(node->right);                
            }

            // swap between current layer & next layer
            swap(curLayerNodes, nextLayerNodes);
        }


        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```

## BFS V2: string only - 沒有優化記憶體，但表示比較明確
```Cpp
#define SERIALIZE_BFS_LAYER_START_CHAR  ('L')
#define SERIALIZE_CHILD_NULL_CHAR       ('N')
#define SERIALIZE_NODE_VAL_START_CHAR   ('#')
#define SERIALIZE_NODE_VAL_END_CHAR     ('!')
class Codec {
private:
    TreeNode* createOneNodeFromStr(string &str, int startIdx, int &finishIdx) {
        if(startIdx >= str.size()) return nullptr;
        TreeNode* newNode = nullptr;

        int valStartIdx = -1;
        int valLen = 0;
        for(int i = startIdx; i < str.size(); i++) {
            switch (str[i]) {
            case SERIALIZE_BFS_LAYER_START_CHAR:
                break;

            case SERIALIZE_CHILD_NULL_CHAR:
                finishIdx = i+1;
                return nullptr;
            
            case SERIALIZE_NODE_VAL_START_CHAR:
                valStartIdx = i+1;
                break;
            
            case SERIALIZE_NODE_VAL_END_CHAR:
                finishIdx = i+1;
                valLen = i - valStartIdx;
                newNode = new TreeNode(stoi(str.substr(valStartIdx, valLen)));
                return newNode;
            }
        }

        return nullptr;
    }
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string serializedStr = "";

        queue<TreeNode*> thisLayerNodes;
        queue<TreeNode*> nextLayerNodes;

        thisLayerNodes.push(root);
        while(thisLayerNodes.size()) {
            serializedStr += SERIALIZE_BFS_LAYER_START_CHAR;

            while(thisLayerNodes.size()) {
                TreeNode* node = thisLayerNodes.front();
                thisLayerNodes.pop();

                if(!node) {
                    serializedStr += SERIALIZE_CHILD_NULL_CHAR;
                    continue;
                }
                
                serializedStr += (SERIALIZE_NODE_VAL_START_CHAR + to_string(node->val) + SERIALIZE_NODE_VAL_END_CHAR);
                nextLayerNodes.push(node->left);
                nextLayerNodes.push(node->right);
            }

            swap(thisLayerNodes, nextLayerNodes);
        }

        return serializedStr;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {

        int curDeserialIdx = 0, nextDeserialIdx = 0;

        TreeNode* root = createOneNodeFromStr(data, curDeserialIdx, nextDeserialIdx);
        curDeserialIdx = nextDeserialIdx;

        queue<TreeNode*> pendingNodes;
        pendingNodes.push(root);

        while(pendingNodes.size()) {

            TreeNode* parentNode = pendingNodes.front();
            pendingNodes.pop();

            if(!parentNode) continue;

            parentNode->left = createOneNodeFromStr(data, curDeserialIdx, nextDeserialIdx);
            if(parentNode->left) pendingNodes.push(parentNode->left);
            curDeserialIdx = nextDeserialIdx;

            parentNode->right = createOneNodeFromStr(data, curDeserialIdx, nextDeserialIdx);
            if(parentNode->right) pendingNodes.push(parentNode->right);
            curDeserialIdx = nextDeserialIdx;
        }

        return root;
    }
};

```

## BFS V3: string only - 優化記憶體，簡化 serialized string
```Cpp
#define SERIALIZE_CHILD_NULL_CHAR       ('N')
#define SERIALIZE_NODE_VAL_END_CHAR     ('!')
class Codec {
private:
    TreeNode* createOneNodeFromStr(string &str, int startIdx, int &nextTermStartIdx) {
        if(startIdx >= str.size()) return nullptr;
        TreeNode* newNode = nullptr;

        int valLen = 0;
        for(int i = startIdx; i < str.size(); i++) {
            switch (str[i]) {

            case SERIALIZE_CHILD_NULL_CHAR:
                nextTermStartIdx = i+1;
                return nullptr;
            
            case SERIALIZE_NODE_VAL_END_CHAR:
                nextTermStartIdx = i+1;
                valLen = i - startIdx;
                newNode = new TreeNode(stoi(str.substr(startIdx, valLen)));
                return newNode;
            }
        }

        return nullptr;
    }
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string serializedStr = "";

        queue<TreeNode*> thisLayerNodes;
        queue<TreeNode*> nextLayerNodes;

        thisLayerNodes.push(root);
        while(thisLayerNodes.size()) {

            while(thisLayerNodes.size()) {
                TreeNode* node = thisLayerNodes.front();
                thisLayerNodes.pop();

                if(!node) {
                    serializedStr += SERIALIZE_CHILD_NULL_CHAR;
                    continue;
                }
                
                serializedStr += (to_string(node->val) + SERIALIZE_NODE_VAL_END_CHAR);
                nextLayerNodes.push(node->left);
                nextLayerNodes.push(node->right);
            }

            swap(thisLayerNodes, nextLayerNodes);
        }

        return serializedStr;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {

        int curDeserialIdx = 0, nextDeserialIdx = 0;

        TreeNode* root = createOneNodeFromStr(data, curDeserialIdx, nextDeserialIdx);
        curDeserialIdx = nextDeserialIdx;

        queue<TreeNode*> pendingNodes;
        pendingNodes.push(root);

        while(pendingNodes.size()) {

            TreeNode* parentNode = pendingNodes.front();
            pendingNodes.pop();

            if(!parentNode) continue;

            parentNode->left = createOneNodeFromStr(data, curDeserialIdx, nextDeserialIdx);
            if(parentNode->left) pendingNodes.push(parentNode->left);
            curDeserialIdx = nextDeserialIdx;

            parentNode->right = createOneNodeFromStr(data, curDeserialIdx, nextDeserialIdx);
            if(parentNode->right) pendingNodes.push(parentNode->right);
            curDeserialIdx = nextDeserialIdx;
        }

        return root;
    }
};

```