# LeetCode
[235. Lowest Common Ancestor of a BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-bst/)

# Answer
## V1: DFS + 透過 Binary Tree 特性快速判斷（較慢）
- 這版判斷沒完全利用 binary tree 特性 -> 既然已經先確保 p < q，則檢查是 left / right size，只需要比對 p / q 其中一個即可
- 也就是這部分其實只需要比對 q 即可：`if((p->val < checkNode->val) && (q->val < checkNode->val))`
- 注意：「p <= node <= q」 本身涵蓋了「p 是 q 的 root」及「 q 是 p 的 root 的情況」
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        // to ensure p value < q value
        if(p->val > q->val) swap(p,q);

        // a node to indicate the traverse position on the tree
        TreeNode *checkNode = root;

        // traverse through the tree and check nodes
        while(checkNode) {

            // if the node is null ptr
            if(!checkNode) continue;

            // if the node satisfies the middle point
            if((p->val <= checkNode->val) && (checkNode->val <= q->val)) return checkNode;

            // if p & q are on the left side of the checked node -> move to left child of the checked node
            if((p->val < checkNode->val) && (q->val < checkNode->val)) {
                checkNode = (checkNode->left);
                continue;
            }

            // if p & q are on the right side of the check node -> move to right child of the checked node
            else {
                checkNode = (checkNode->right);
                continue;
            }
        }

        // not expected to be here: if no node on the tree could be the common ancestor of p & q
        return nullptr;
    }
};
``` 

## V2: DFS + 透過 Binary Tree 特性快速判斷（較快）
### V2.1 複習 1st 寫的 - while loop DFS Binary Tree
- 這版本是複習時候寫的
- 檢查的情況比較簡化，只比對「小於 p」、「大於q」、「p <= node <= q」
- 注意：「p <= node <= q」 本身涵蓋了「p 是 q 的 root」及「 q 是 p 的 root 的情況」
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {

public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(p->val > q->val) swap(p, q);

        TreeNode *travNode = root;
        while(travNode) {
            if((p->val <= travNode->val) && (travNode->val <= q->val)) {
                return travNode;
            }

            if(q->val < travNode->val) {
                travNode = travNode->left;
                continue;
            }

            if(p->val > travNode->val) {
                travNode = travNode->right;
                continue;
            }
        }

        return nullptr;
    }
};

```

### V2.2 複習 2nd 寫的 - recursive DFS Binary Tree
```Cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return nullptr;

        int rootVal = root->val;
        int pVal = p->val;
        int qVal = q->val;

        if((pVal <= rootVal) && (rootVal <= qVal)) return root;
        if((qVal <= rootVal) && (rootVal <= pVal)) return root;

        if((pVal <= rootVal) && (qVal <= rootVal)) {
            return lowestCommonAncestor(root->left, p, q);
        }

        if((rootVal <= pVal) && (rootVal <= qVal)) {
            return lowestCommonAncestor(root->right, p, q);
        }

        return nullptr;
    }
};
```

## V3：Brute Force（這個比較難，當作練習）
### V3.1 - 複習1st - Type1： reference variable as output -> 比較快
- 這是萬用解，不論是否為 binary tree 都可以使用
- 先檢查「p 包含 q」和「q 包含 p」兩種情況
	- p 當做 root，看往下檢查有沒有包含 q
	- q 當中 root，看往下檢查有沒有包含 p
- 再檢查「p 和 q 」沒有互相包含的情況
	- 因為 p / q 不互相包含 -> 所以檢查的時候一旦檢查到「node = p」或「node = q」，則可以停止 DFS，因為繼續往下一定沒有另外一個 node
	- 必須把「child 包含 p」和「child 包含 q」的資訊，從底下傳上來
- 因為 output 是用 reference bool
	- **return 前一定要確保兩個 bool reference output 有設，否則會出錯**
	- **input 的時候定要確保量 bool reference reset，否則會出錯** -> *因為原理是「bottom up set value」，所以從上帶下來的數值，必須清除*
	- **reference value output 速度比較快**
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
private:
    bool isTreeContainsNode(TreeNode* root, TreeNode* node) {
        if(!node) return true;
        if(!root) return false;

        if(root->val == node->val) return true;
        if(root->left && isTreeContainsNode(root->left, node)) return true;
        if(root->right && isTreeContainsNode(root->right, node)) return true;
        return false;
    }

    void lowestNodeContainDiffSizePQ(TreeNode* root, TreeNode* p, TreeNode* q, bool &childHasP, bool &childHasQ, TreeNode* &resultNode) {
        if(!root) {
            childHasP = false;
            childHasQ = false;
            return;
        }

        if(root->val == p->val) {
            childHasP = true;
            childHasQ = false;
            return;
        }

        if(root->val == q->val) {
            childHasQ = true;
            childHasP = false;
            return;
        }

        childHasP = false;
        childHasQ = false;

        bool LchildHasP = false, LchildHasQ = false;
        if(root->left) {
            lowestNodeContainDiffSizePQ(root->left, p, q, LchildHasP, LchildHasQ, resultNode);
        }

        bool RchildHasP = false, RchildHasQ = false;
        if(root->right) {
            lowestNodeContainDiffSizePQ(root->right, p, q, RchildHasP, RchildHasQ, resultNode);
        }

        childHasP = (LchildHasP || RchildHasP);
        childHasQ = (LchildHasQ || RchildHasQ);

        if(childHasP && childHasQ && !resultNode) {
            resultNode = root;
        }
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if(!root) return nullptr;
        if(isTreeContainsNode(p, q)) return p;
        if(isTreeContainsNode(q, p)) return q;

        TreeNode* resultNode = nullptr;
        bool childHasP = false, childHasQ = false;

        lowestNodeContainDiffSizePQ(root, p, q, childHasP, childHasQ, resultNode);
        return resultNode;
    }
};
```


### V3.2 - 複習1st - Type2: direct output -> 比較慢
- 可以不處理「bottom up set value」時候要先 reset output value 的問題
- 但是寫法比較麻煩，而去比較慢
- 因為function output 一直傳遞回傳值，速度較慢
```Cpp
class Solution {
private:
    bool isTreeContainsNode(TreeNode* root, TreeNode* node) {
        if(!node) return true;
        if(!root) return false;

        if(root->val == node->val) return true;
        if(root->left && isTreeContainsNode(root->left, node)) return true;
        if(root->right && isTreeContainsNode(root->right, node)) return true;
        return false;
    }

    enum nodeContainCond {
        CHILD_HAS_P,
        CHILD_HAS_Q,
        CHILD_HAS_BOTH,
        CHILD_CONTAIN_NOTHING
    };

    nodeContainCond lowestNodeContainDiffSizePQ(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode* &resultNode) {
        if(root->val == p->val) {
            return CHILD_HAS_P;
        }

        if(root->val == q->val) {
            return CHILD_HAS_Q;
        }

        nodeContainCond leftChildCond = CHILD_CONTAIN_NOTHING;
        if(root->left) {
            leftChildCond = lowestNodeContainDiffSizePQ(root->left, p, q, resultNode);
        }

        nodeContainCond rightChildCond = CHILD_CONTAIN_NOTHING;
        if(root->right) {
            rightChildCond = lowestNodeContainDiffSizePQ(root->right, p, q, resultNode);
        }

        bool childHasP = (leftChildCond == CHILD_HAS_P) || (rightChildCond == CHILD_HAS_P);
        bool childHasQ = (leftChildCond == CHILD_HAS_Q) || (rightChildCond == CHILD_HAS_Q);

        if(childHasP && childHasQ && !resultNode) {
            resultNode = root;
        }

        if(childHasP && childHasQ) return CHILD_HAS_BOTH;
        if(childHasP) return CHILD_HAS_P;
        if(childHasQ) return CHILD_HAS_Q;
        return CHILD_CONTAIN_NOTHING;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if(!root) return nullptr;
        if(isTreeContainsNode(p, q)) return p;
        if(isTreeContainsNode(q, p)) return q;

        TreeNode* resultNode = nullptr;
        lowestNodeContainDiffSizePQ(root, p, q, resultNode);
        return resultNode;
    }
};
```

### V3.2 - 複習2nd - 最精簡版本
- **和前兩個寫法不同：「這個寫法不用把 p / q 互相包含的情況先判斷一次，而是直接能處理 p / q 互相包含的情況」**
- **traverse 到路徑涵蓋 p & q 時停止**
- **traverse 回退的時候如果「parent node 不飽和 PQ」並且「current node 往下包含 PQ」 -> 回傳 valid node**
	- **其他情況一律回傳 nullptr**
	- 情況1：P / Q 不互相包含
		- parent node 完全不包含 p / q，current node 也不包含 P / Q，但 current node 往下包含了 P & Q -> current node = common ancestor
	- 情況2：P / Q 互相包含
		-  parent node 完全不包含 p / q，current node 包含 P 或 Q 但沒有靈感包含，且 current node 往下包含了 P & Q -> current node = common ancestor
	- 情況3：P / Q 相等
		- 不看 parent node 的情況，而是第一次檢查到 branch contain p & q 的時候，如果當前是 match P & match Q (代表 node = p = q) -> 回傳 valid current node
```Cpp
class Solution {
private:
    bool rootContailNode(TreeNode* root, TreeNode* node) {
        if(!root) return false;
        if(!node) return true;

        if(root->val == node->val) return true;
        if(rootContailNode(root->left, node)) return true;
        if(rootContailNode(root->right, node)) return true;

        return false;
    }

    TreeNode* lowestCommonAncestorDiffSides(TreeNode* root, TreeNode* p, TreeNode* q, pair<bool, bool> &branchContainPQ) {
        if(!root) return nullptr;

        auto &[branchHasP, branchHasQ] = branchContainPQ;
        if(branchHasP && branchHasQ) return nullptr;

        bool parentWithoutPAndQ = (!branchHasP && !branchHasQ);
        branchHasP = branchHasP || (root->val == p->val);
        branchHasQ = branchHasQ || (root->val == q->val);

        if(branchHasP && branchHasQ) {
            return (parentWithoutPAndQ) ? (root) : (nullptr);
        }

        TreeNode* result_L = lowestCommonAncestorDiffSides(root->left, p, q, branchContainPQ);
        if(result_L) return result_L;

        TreeNode* result_R = lowestCommonAncestorDiffSides(root->right, p, q, branchContainPQ);
        if(result_R) return result_R;

        if(parentWithoutPAndQ && branchContainPQ.first && branchContainPQ.second) return root;
        return nullptr;
    }

public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if(rootContailNode(p, q)) return p;
        if(rootContailNode(q, p)) return q;

        pair<bool, bool> branchContainPQ = {false, false};
        return lowestCommonAncestorDiffSides(root, p, q, branchContainPQ);
    }
};
```