---
ParentTask:
  - "[[trees]]"
LeetCodeLv: Easy
Algorithm:
  - Tree
  - BFS
  - Queue
---

# LeetCode
[226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
# Answer: BFS + single Queue - O(N)
BFS 就是要 double queue 意義才明確，single queue 不寫！

# Answer: BFS + double Queue - O(N)
```Cpp
/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode() : val(0), left(nullptr), right(nullptr) {}
*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
* };
*/
class Solution {
public:
	TreeNode* invertTree(TreeNode* root) {

		// queue to store nodes of current / next layers
		queue<TreeNode*> LayerNodes;
		queue<TreeNode*> NextLayerNodes;

		// initial cond: root as current layer node
		LayerNodes.push(root);

		// traverse each layers and swap
		while(!LayerNodes.empty()) {

			// pop all nodes of the current layer and swap left & right
			while(!LayerNodes.empty()){
				// pop one node of prev layer
				TreeNode* CheckNode=LayerNodes.front();
				LayerNodes.pop();

				// if node is enpty->skip
				if(!CheckNode) continue;

				// store left&right for the swap of next layer
				NextLayerNodes.push(CheckNode->left);
				NextLayerNodes.push(CheckNode->right);

				// swap the left & right of the current node
				swap(CheckNode->left,CheckNode->right);
			}

			// swap layer nodes storage
			// then enter next layer
			swap(LayerNodes,NextLayerNodes);
		}
		return root;
	}
};
``` 
題目需求
- tree 底下每個 node 左右對調

執行方式
- 使用 BFS
	- 使用一個 queue 把 node 存起來，一層一層處理
	- queue: 先進先出
- 爲了方便排查『目前這一層的 node』和『下一層要處理的 node』各自是多少
	- 使用兩個 queue 各自儲存 thisLayerNodes 和 nextLayerNodes
	- 注意：爲了確保 node 取出後都是 valid -> **在存入 node 前就先檢查是否爲 valid node，如果是 NULL 則不存入 queue**
- 每一層處理的時候
	- 把 thisLayerNodes 這個 queue 裏面的 node 取出
	- 把上述 Node 的 left / right child node 存到 nextLayerNodes
	- 當 thisLayerNodes 裏面的 node 處理完畢
		- 代表這一層處理完畢
		- 此時執行 swap(thisLayerNodes, nextLayerNodes) -> 並開始處理下一層的 node

# Answer: BFS + quadra Stack - O(N)
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void pushValidNodeAndChildToPending(TreeNode* node, stack<TreeNode*> &parentLayerPendingNodes, stack<TreeNode*> &childLayerPendingNodes) {
        if(!node) return;

        parentLayerPendingNodes.push(node);
        childLayerPendingNodes.push(node->left);
        childLayerPendingNodes.push(node->right);
    }
public:
    TreeNode* invertTree(TreeNode* root) {

        // current operation
        stack<TreeNode*> parentLayerPendingNodes;
        stack<TreeNode*> childLayerPendingNodes;
        pushValidNodeAndChildToPending(root, parentLayerPendingNodes, childLayerPendingNodes);

        // next operation
        stack<TreeNode*> nextParentLayerPendingNodes;
        stack<TreeNode*> nextChildLayerPendingNodes;

        // handle layer by layer
        while(parentLayerPendingNodes.size()) {

            while(parentLayerPendingNodes.size()) {

                // reverse tree
                TreeNode* parent = parentLayerPendingNodes.top();
                parentLayerPendingNodes.pop();
                
                TreeNode* newLeft = childLayerPendingNodes.top();
                childLayerPendingNodes.pop();

                TreeNode* newRight = childLayerPendingNodes.top();
                childLayerPendingNodes.pop();

                parent->left = newLeft;
                parent->right = newRight;
                
                // prepare for next operation
                pushValidNodeAndChildToPending(newLeft, nextParentLayerPendingNodes, nextChildLayerPendingNodes);
                pushValidNodeAndChildToPending(newRight, nextParentLayerPendingNodes, nextChildLayerPendingNodes);
            }

            swap(parentLayerPendingNodes, nextParentLayerPendingNodes);
            swap(childLayerPendingNodes, nextChildLayerPendingNodes);
        }

        return root;
    }
};
```
- 概念
	- 一次把 parent + child 放到 stack
	- 從 stack 取出 parent + child 並且連結 -> child 會被反序取出 -> 剛好達成 left / right 對調
- 注意
	- 處理一層 parent node：需要兩個 stack 裝 parent + child
	- layer traverse 的時候，總共需要 4 個 stack {cur layer parent / cur layer child} + {next layer parent / next layer child}
	- **這邊一定要把 curlayer / nextlayer 用不同資料結構來裝，絕對 *不能像是 BFS 那樣只用一個 queue 套用到這邊只用一個 stack* 
	- -> **因為把 next layer node push 到 cur layer stack 後，下次從 stack 會直接取出 next layer node，而 this layer nodex 在 stack 中可能還沒處理完畢**