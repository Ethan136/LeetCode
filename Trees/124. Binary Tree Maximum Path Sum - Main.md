---
LeetCodeNeedNextReview: false
LeetCodeLv: Hard
---

# LeetCode
[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)

# Answer
## 解題概念
- Path = {node} + {left child 連下去最大 single side path} + {right child 連下去最大 single side path}
	- node 一定要有
	- {left child 連下去最大 single side path} 如果數值小於 0 -> *可以不往 left child 連下去*
	- {right child 連下去最大 single side path} 如果數值小於 0 -> *可以不往 right child 連下去*
- single side path = {node} + {往 left child / right child 其中一條連去選最大值}
	- node 一定要有
	- {往 left child / right child 其中一條連下去選最大值} 如果數值小於 0 -> *可以不往 left & right child 連下去*
- 使用 DFS 或是 BFS 沿路檢查下去，走到底後再 buttom up 更新 parent 的 max Path 及 max single side path


## V2: DFS + Recursive
- **注意：如果 left / right child 沒有走下去，則 left / right child 的 single side sum 要視為 0** -> 沒有走的視為 0，合理！
- **注意：如果 left / right child 沒有走下去，則 left / right child 的 PathSum 要視為 INT_MIN** -> 沒有走的不能視為 0
	- 否則可能會誤判「當前 node 小於 0 的時候，底下的 left / right child 的 path 卻等於 0」
	- > **上面這個情況會誤判：明明 left / right child 沒有往下走，卻誤認為 left / right child 往下掉 path sum = 0，而拿來和 node value < 0 比較 path
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int maxPathSum(TreeNode* root, int &maxSideSumUnderRoot) {
        maxSideSumUnderRoot = 0;
        if(!root) return 0;

        // try to include left child side
        // -> don't include left child side if the sum of it less than zero
        int leftChildPathSum = INT_MIN, leftChildSideSum = 0;
        if(root->left) {
            leftChildPathSum = maxPathSum(root->left, leftChildSideSum);
            leftChildSideSum = max(0, leftChildSideSum);
        }

        // try to include right child side
        // -> don't include right child side if the sum of it less than zero
        int rightChildPathSum = INT_MIN, rightChildSideSum = 0;
        if(root->right) {
            rightChildPathSum = maxPathSum(root->right, rightChildSideSum);
            rightChildSideSum = max(0, rightChildSideSum);
        }

        // return the max side sum under root (may or maynot include child)
        maxSideSumUnderRoot = root->val + max(leftChildSideSum, rightChildSideSum);

        // return the max sum "under" root, can be max sum of sub tree
        return max( (root->val + leftChildSideSum + rightChildSideSum), max(leftChildPathSum, rightChildPathSum));
    }
public:
    int maxPathSum(TreeNode* root) {
        int maxSideSumUnderRoot = 0;
        return maxPathSum(root, maxSideSumUnderRoot);
    }
};
``` 


## V1: BFS + Iteration + Self Defined Struct (奇怪的做法，只是好玩)
```Cpp
#define DEBUG (0)
class Solution {
private:
    struct tNodePathInfo {
        TreeNode* node;
        int maxLeftChildPathAfterNode;
        int maxRightChildPathAfterNode;
    };
public:
    int maxPathSum(TreeNode* root) {
        // if the tree is empty
        if (!root) return 0;

        // initialize the result
        int maxPath = INT_MIN;

        // vector to store the nodes of each layer
        vector<vector<tNodePathInfo>> vecOfEachLayerPathInfo;
        vecOfEachLayerPathInfo.push_back({{root, 0, 0}});

        // store all nodes to the 2D vector
        while(vecOfEachLayerPathInfo.back().size()) {

            // create space for current layer
            vecOfEachLayerPathInfo.push_back({});

            // index of parent layer & current layer
            int curLayerIdx = vecOfEachLayerPathInfo.size()-1;
            int parentLayerIdx = curLayerIdx-1;

            // path info storage of parent layer & current layer
            vector<tNodePathInfo> &parentLayerPathInfo = vecOfEachLayerPathInfo[parentLayerIdx];
            vector<tNodePathInfo> &childLayerPathInfo = vecOfEachLayerPathInfo[curLayerIdx];

            // put nodes of current layer to the vector
            for(int i = 0; i < parentLayerPathInfo.size(); i++) {
                if(!parentLayerPathInfo[i].node) {
                    continue;
                }

                if(parentLayerPathInfo[i].node->left) {
                    childLayerPathInfo.push_back({parentLayerPathInfo[i].node->left, 0, 0});
                }

                if(parentLayerPathInfo[i].node->right) {
                    childLayerPathInfo.push_back({parentLayerPathInfo[i].node->right, 0, 0});
                }
            }
        }

#if DEBUG
        // debug print layer nodes
        cout<<"-------------node BFS Finish------------"<<endl;
        for(int i = 0; i < vecOfEachLayerPathInfo.size(); i++) {
            cout<<"[Layer "<<i<<"]"<<endl;
            for(int j = 0; j < vecOfEachLayerPathInfo[i].size(); j++) {
                cout<<vecOfEachLayerPathInfo[i][j].node->val<<" ";
            }
            cout<<endl;
        }

        cout<<"-------Start Check Max Path from Lowest Layer---------"<<endl;
#endif

        // calculate the max path sum from the lowest layer to layer1 (layer next to root)
        int maxLayer = int(vecOfEachLayerPathInfo.size())-1;
        for(int layer = maxLayer-1; layer >= 0; layer-- ) {

            // path info storage of parent layer & current layer
            vector<tNodePathInfo> &parentLayerPathInfo = vecOfEachLayerPathInfo[layer];
            vector<tNodePathInfo> &childLayerPathInfo = vecOfEachLayerPathInfo[layer+1];

#if DEBUG
            // debug print layer nodes
            cout<<"[Parent Layer]"<<endl;
            for(int i = 0; i < parentLayerPathInfo.size(); i++) {
                cout<<parentLayerPathInfo[i].node->val<<" ";
            }
            cout<<endl;

            cout<<"[Current Layer]"<<endl;
            for(int i = 0; i < childLayerPathInfo.size(); i++) {
                cout<<childLayerPathInfo[i].node->val<<" ";
            }
            cout<<endl;
#endif
            // update max sum path from the current layer back to the parent layer
            for(int i = 0, j = 0; i < parentLayerPathInfo.size(); i++) {
                // if parent node is NULL
                if(!parentLayerPathInfo[i].node) {
                    continue;
                }

                // check path only contains parent node itself
                maxPath = max(maxPath, parentLayerPathInfo[i].node->val);

                // check path from parent node to valid left child
                if(parentLayerPathInfo[i].node->left && parentLayerPathInfo[i].node->left == childLayerPathInfo[j].node) {
#if DEBUG
                    cout<<"ParentNode["<<i<<"] "<<parentLayerPathInfo[i].node->val<<" -> left = "<<"ChildNode["<<j<<"] "<<childLayerPathInfo[j].node->val<<endl;
#endif
                    // update left child path after parent node
                    parentLayerPathInfo[i].maxLeftChildPathAfterNode = childLayerPathInfo[j].node->val 
                                                                    + max(childLayerPathInfo[j].maxLeftChildPathAfterNode, 
                                                                          childLayerPathInfo[j].maxRightChildPathAfterNode);

                    parentLayerPathInfo[i].maxLeftChildPathAfterNode = max(parentLayerPathInfo[i].maxLeftChildPathAfterNode, 0);


                    // calculate path from parent node
                    int maxPathFromParentNode = parentLayerPathInfo[i].node->val 
                                                + parentLayerPathInfo[i].maxLeftChildPathAfterNode 
                                                + parentLayerPathInfo[i].maxRightChildPathAfterNode;

                    // update max path
                    maxPath = max(maxPath, maxPathFromParentNode);

                    // check next child node
                    j++;
                }

                // check path from parent node to valid right child
                if(parentLayerPathInfo[i].node->right && parentLayerPathInfo[i].node->right == childLayerPathInfo[j].node) {
#if DEBUG
                    cout<<"ParentNode["<<i<<"] "<<parentLayerPathInfo[i].node->val<<" -> right = "<<"ChildNode["<<j<<"] "<<childLayerPathInfo[j].node->val<<endl;
#endif
                    // update left child path after parent node
                    parentLayerPathInfo[i].maxRightChildPathAfterNode = childLayerPathInfo[j].node->val 
                                                                    + max(childLayerPathInfo[j].maxLeftChildPathAfterNode, 
                                                                          childLayerPathInfo[j].maxRightChildPathAfterNode);

                    parentLayerPathInfo[i].maxRightChildPathAfterNode = max(parentLayerPathInfo[i].maxRightChildPathAfterNode, 0);


                    // calculate path from parent node
                    int maxPathFromParentNode = parentLayerPathInfo[i].node->val 
                                                + parentLayerPathInfo[i].maxLeftChildPathAfterNode 
                                                + parentLayerPathInfo[i].maxRightChildPathAfterNode;

                    // update max path
                    maxPath = max(maxPath, maxPathFromParentNode);

                    // check next child node
                    j++;
                }
            }
        }

        // return result
        return maxPath;
    }
};
```


## V1: DFS + Iteration + Self Defined Struct
- 等於是 DFS + Recursive 的版本，把func call 的情況用 struct 記錄起來
```Cpp
class Solution {
private:
    struct tNodePathInfo {
        TreeNode* node;
        int maxLeftChildPathAfterNode;
        int maxRightChildPathAfterNode;
    };
public:
    int maxPathSum(TreeNode* root) {
        // if the tree is empty
        if (!root) return 0;

        // initialize the result
        int maxPath = INT_MIN;

        // to store the node path info which the max path sum has not been determined
        std::stack<tNodePathInfo> pendingPathInfo;

        // the indicator for node traverse and last visited node
        TreeNode* nodeTraverse = root;
        TreeNode* nodeVisited = nullptr;

        // go through the tree and check the max path sum
        while (nodeTraverse || !pendingPathInfo.empty()) {

            // (1) go to the left end of the current "straight branch"
            //     only push the node to the stack during "left traverse process"
            while (nodeTraverse) {
                pendingPathInfo.push({nodeTraverse, 0, 0});
                nodeTraverse = nodeTraverse->left;
                continue;
            }

            // (2) check whether the right child of the latest pending node needs to be traverse
            if (pendingPathInfo.top().node->right && pendingPathInfo.top().node->right != nodeVisited) {
                nodeTraverse = pendingPathInfo.top().node->right;
                continue;
            }

            // (3) if there's no need to traverse right child of the latest pending node -> calculate max path sum
            tNodePathInfo nodePathInfo = pendingPathInfo.top();
            pendingPathInfo.pop();

            // calculate the max path of the latest pending node
            nodePathInfo.maxLeftChildPathAfterNode = max(0, nodePathInfo.maxLeftChildPathAfterNode);
            nodePathInfo.maxRightChildPathAfterNode = max(0, nodePathInfo.maxRightChildPathAfterNode);
            maxPath = max(maxPath, nodePathInfo.node->val + nodePathInfo.maxLeftChildPathAfterNode + nodePathInfo.maxRightChildPathAfterNode);

            // (4) check if the parent node exist -> update the path info of the parent node
            if (!pendingPathInfo.empty()) {
                tNodePathInfo &parentNodePathInfo = pendingPathInfo.top();

                // update the path info of the parent node
                int downWardPathMax = nodePathInfo.node->val + max(nodePathInfo.maxRightChildPathAfterNode, nodePathInfo.maxLeftChildPathAfterNode);
                if (parentNodePathInfo.node->left == nodePathInfo.node) {
                    parentNodePathInfo.maxLeftChildPathAfterNode = downWardPathMax;
                }
                else {
                    parentNodePathInfo.maxRightChildPathAfterNode = downWardPathMax;
                }
            }

            // (5) record the checked node
            nodeVisited = nodePathInfo.node;
        }
        return maxPath;
    }
};
```