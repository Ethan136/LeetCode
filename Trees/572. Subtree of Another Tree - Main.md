# LeetCode
[572. Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)

# Answer
## V1: DFS + Stack Iteration (實作複雜)
- DFS traverse main tree: 把 node value 和 subTree Roote 相同的都記錄到 stack -> candidate node
- 檢查前一步記錄到所有 candidate node，看是否有其中一個往下延伸符合 subTree
	- 檢查 candidate node 和 subTree 是否一樣的時候: 使用 DFS + Stack iteration
- **注意：使用 stack 一直 push / pop 速度比較慢**
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    struct NodePair {
        TreeNode* node1;
        TreeNode* node2;
    };

    bool isTwoNodesSameTree(TreeNode* p, TreeNode* q) {
        stack<NodePair> pendingCheckNodePair;
        pendingCheckNodePair.push({p, q});

        while(pendingCheckNodePair.empty()==false) {
            NodePair nodePairToCheck = pendingCheckNodePair.top();
            pendingCheckNodePair.pop();

            if(isTwoNodesIdentical(nodePairToCheck.node1, nodePairToCheck.node2)==false) return false;
            if(nodePairToCheck.node1->left) {
                pendingCheckNodePair.push({nodePairToCheck.node1->left, nodePairToCheck.node2->left});
            }
            if(nodePairToCheck.node1->right) {
                pendingCheckNodePair.push({nodePairToCheck.node1->right, nodePairToCheck.node2->right});
            }
        }
        return true;
    }

    bool isTwoNodesIdentical(TreeNode* p, TreeNode* q) {
        if(isSameVal(p, q)==false) return false;

        if(isSameVal(p->left, q->left)==false) return false;

        if(isSameVal(p->right, q->right)==false) return false;

        return true;
    }

    static bool isSameVal(TreeNode* p, TreeNode* q) {
        if(!p || !q) return (p==q);

        return (p->val == q->val);
    }

public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        // to traverse the main Tree and find the nodes = sub-Root
        stack<TreeNode*> nodeWaitTraverse;
        nodeWaitTraverse.push(root);

        // the nodes on main Tree which is equal to the root of target sub-tree
        stack<TreeNode*> nodesSameAsTargetSubRoot;
        while(nodeWaitTraverse.empty()==false) {
            TreeNode* trsvNode = nodeWaitTraverse.top();
            nodeWaitTraverse.pop();

            if(!trsvNode) {
                continue;
            }

            if(isTwoNodesIdentical(trsvNode, subRoot)==true) {
                nodesSameAsTargetSubRoot.push(trsvNode);
            }

            if(trsvNode->left) {
                nodeWaitTraverse.push(trsvNode->left);
            }

            if(trsvNode->right) {
                nodeWaitTraverse.push(trsvNode->right);
            }
        }

        // check the candidate nodes with the target
        while(!nodesSameAsTargetSubRoot.empty()) {
            TreeNode* checkNode = nodesSameAsTargetSubRoot.top();
            nodesSameAsTargetSubRoot.pop();

            if(isTwoNodesSameTree(checkNode, subRoot)) {
                return true;
            }
        }
        return false;
    }
};``` 


## V2: DFS + Recursive (實作簡單)
- traverse through main tree
	- 檢查每一個 node 是否和 sub-tree 一致 -> 一致的話回傳 true
	- 如果 node 和 sub-tree 不一致 -> 繼續 DFS traverse main tree -> 檢查 child node 是否和 sub-tree 一致
- 如果所有 node of main tree 都不符合 sub-tree 的情況 -> 回傳 false
- **注意：使用 recursive 速度比較快**

```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p && !q) return true;

        if(!p || !q) return false;
        if(p->val != q->val) return false;

        if(isSameTree(p->left, q->left) == false) return false;
        if(isSameTree(p->right, q->right) == false) return false;

        return true;
    }
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(isSameTree(root, subRoot) == true) return true;
        if(!root) return false;

        if(isSubtree(root->left, subRoot)) return true;
        if(isSubtree(root->right, subRoot)) return true;

        return false;
    }
};```