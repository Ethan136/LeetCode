---
ParentTask:
  - "[[trees]]"
---

# LeetCode
[100. Same Tree](https://leetcode.com/problems/same-tree/)

# Answer
## Note
- 一次檢查 parent + child
	- 實作比較複雜
	- 但可以減少 child BFS 的情況，整體記憶體消耗比較少
- 只檢查 parent
	- 實作簡單擔當
	- 但會把 mis match child 放到 BFS 裡面等下一輪執行，整體記憶體消耗比較多

## V1: Check Parent + Child (實作複雜 / 速度是 100%)
- 使用 Pair
- 實作複雜
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    struct NodePair{
        TreeNode* node1;
        TreeNode* node2;
    };
    bool isSameNodeVal(TreeNode* node1, TreeNode* node2) {
        // one of the node is null -> both should be null
        if(!node1 || !node2) return (node1==node2);

        // check node value
        return (node1->val == node2->val);
    }
    bool isSameNode(TreeNode* node1, TreeNode* node2, NodePair &leftChild12, NodePair &rightChild12) {
        // check node value
        if(!isSameNodeVal(node1, node2)) return false;

        // (0) if node1 & node2 are empty
        if(node1==node2 && node1==nullptr) {
            leftChild12 = {nullptr, nullptr};
            rightChild12 = {nullptr, nullptr};
            return true;
        }

        // (1) check left1-left2 & right1-right2
        if(isSameNodeVal(node1->left, node2->left) && isSameNodeVal(node1->right, node2->right)) {
            leftChild12 = {node1->left, node2->left};
            rightChild12 = {node1->right, node2->right};
            return true;
        }
        // (2) childs of node1 & node2 do not match
        else {
            return false;
        }
    }
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // stack of nodes need to be checked
        stack<NodePair> pendingNodePairStack;
        pendingNodePairStack.push({p,q});

        // check nodes and traverse through the tree
        while(!pendingNodePairStack.empty()) {
            // pop one node to be checked
            NodePair checkPair=pendingNodePairStack.top();
            pendingNodePairStack.pop();

            // check node
            NodePair leftChilds12, rightChilds12;
            if(isSameNode(checkPair.node1, checkPair.node2, leftChilds12, rightChilds12)==false) return false;
            
            // push left childs to pending if they're not null
            if(leftChilds12.node1) {
                pendingNodePairStack.push(leftChilds12);
            }

            // push right childs to pending if ther're not null
            if(rightChilds12.node1) {
                pendingNodePairStack.push(rightChilds12);
            }
            
        }
        return true;

    }
};```

## V2: Check Parent + Child (實作簡化很多 / 速度是 100%)
- 自訂資料結構
- 實作簡化很多
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    struct nodePair {
        TreeNode *pNode1;
        TreeNode *pNode2;
    };
    bool checkSameNodeItself(TreeNode *pNode1, TreeNode *pNode2) {
        if(!pNode1 && !pNode2) return true;

        if(!pNode1 || !pNode2) return false;
        
        return (pNode1->val == pNode2->val);
    }
    bool checkSameNodeWithChild(nodePair pair, nodePair &childPairL, nodePair &childPairR) {
        // check node
        if(checkSameNodeItself(pair.pNode1, pair.pNode2) == false) return false;

        // check if both nodes are empty
        if(!pair.pNode1 && !pair.pNode2) return true;

        // check child left-left
        if(checkSameNodeItself(pair.pNode1->left, pair.pNode2->left) == false) return false;
        childPairL = {pair.pNode1->left, pair.pNode2->left};

        // check child right-right
        if(checkSameNodeItself(pair.pNode1->right, pair.pNode2->right) == false) return false;
        childPairR = {pair.pNode1->right, pair.pNode2->right};

        // otherwise -> not match
        return true;
    }
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<nodePair> pendingNodePair;
        pendingNodePair.push({p, q});

        while(pendingNodePair.size()) {
            nodePair checkPair = pendingNodePair.front();
            pendingNodePair.pop();

            nodePair childPairL, childPairR;
            if(checkSameNodeWithChild(checkPair, childPairL, childPairR) == false) {
                return false;
            }

            if(!checkPair.pNode1 && !checkPair.pNode2) {
                continue;
            }
            
            pendingNodePair.push(childPairL);
            pendingNodePair.push(childPairR);
        }

        return true;
    }
};
```

## V3: Only Check Parent (實作最簡單 / 速度一樣是 100% / 記憶體消耗最多)
- 自訂資料結構
- 實作簡化很多

```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    struct nodePair {
        TreeNode *pNode1;
        TreeNode *pNode2;
    };
    bool checkSameNodeItself(TreeNode *pNode1, TreeNode *pNode2) {
        if(!pNode1 && !pNode2) return true;

        if(!pNode1 || !pNode2) return false;
        
        return (pNode1->val == pNode2->val);
    }
    /*
    bool checkSameNodeWithChild(nodePair pair, nodePair &childPairL, nodePair &childPairR) {
        // check node
        if(checkSameNodeItself(pair.pNode1, pair.pNode2) == false) return false;

        // check if both nodes are empty
        if(!pair.pNode1 && !pair.pNode2) return true;

        // check child left-left
        if(checkSameNodeItself(pair.pNode1->left, pair.pNode2->left) == false) return false;
        childPairL = {pair.pNode1->left, pair.pNode2->left};

        // check child right-right
        if(checkSameNodeItself(pair.pNode1->right, pair.pNode2->right) == false) return false;
        childPairR = {pair.pNode1->right, pair.pNode2->right};

        // otherwise -> not match
        return true;
    }
    */
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<nodePair> pendingNodePair;
        pendingNodePair.push({p, q});

        while(pendingNodePair.size()) {
            nodePair checkPair = pendingNodePair.front();
            pendingNodePair.pop();

            if(checkSameNodeItself(checkPair.pNode1, checkPair.pNode2) == false) {
                return false;
            }

            if(!checkPair.pNode1 && !checkPair.pNode2) {
                continue;
            }
            
            pendingNodePair.push({checkPair.pNode1->left, checkPair.pNode2->left});
            pendingNodePair.push({checkPair.pNode1->right, checkPair.pNode2->right});
        }

        return true;
    }
};```