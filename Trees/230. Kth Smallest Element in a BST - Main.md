---
LeetCodeNeedNextReview:
LeetCodeNeedEnhance:
  - BinarySearchTree的特性
  - Heap分堆
  - MorrisTraverse
LeetCodeLv: Medium
---

# LeetCode
[230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

# 題目特性
- Binary Search Tree
	- 一路往左一定會是往最小的走
	- 一旦往右，則right child 的 node 都會比 current node 來得大
	- 往上退回 -> parent node 為 child 的 next large
	- 如果 parent node 有 right child -> right child 往下會是 parent node 的 next large
- **可以把題目視為：找到最小的之後，找出比他大的 node 第 k-1 個**
- Traverse Direction
	- 一路left child 走到最小的 -> 為 least k =1 的 node
		- 接著往上退回，每個 parent 為 left child 的 next large
	- 如果 parent 有 right child，走 parent->right child 一次，然後持續走 right child 的 left grand child -> 找出 right child 這個分支裡面最小的
		- right child 這個分支裡面最小的，就在 right child 一路往 left grand child 走到最低 -> 這個 node 就是 parent node 的 next large
		- 接著往上退回，每個 left granc child 退回一次，都是前一個的 next large
- 口訣：**夕字走法**
- **這題也可以用 Morris Traverse： 但我不會，之後有時間再看**

# Answer: DFS + Stack + BST Optimal Traverse (可以明確看到是怎樣走的)
- smallIdx: 代表當前 node 是 i-th smallest (0-based)
- 外層 loop: 處理 overall traverse
	- current node != nullptr -> **代表還沒 traverse 完畢** -> *可能是 traverse to right child，或是從 left least child of branch 退回的途中*
	- !pendingCheckNodes.empty() -> **代表還沒 traverse 完畢** -> *當下可能 traverse to left min child 並且走到 nullptr -> current node = nullptr*，但stack 還有 node 需要會退
- 每次 stack pop 一個 node -> 代表回退一次 -> **代表從這個 left child branch 往上退回 -> 更新 smallIdx**
```Cpp
#define DEBUG (1)
class Solution {
private:
    void traverseToLeftEndAndRecordValidNodes(TreeNode *node, stack<TreeNode*>& nodeStack) {
        while(node) {
            nodeStack.push(node);
            node=node->left;
        }
    }
public:
    int kthSmallest(TreeNode* root, int k) {
        // check whether the tree is empty
        if(!root) return -1;
        
        // to store the nodez waiting to be checked
        stack<TreeNode*> pendingCheckNodes;
        
        // to indicate N-th smallest of the current node
        int smallIdx = 0;
        TreeNode *curNode=root;
        do {

            // traverse to the end of left childs
            traverseToLeftEndAndRecordValidNodes(curNode, pendingCheckNodes);

            // check node from the very end of left child upward to the ancestors
            while(!pendingCheckNodes.empty()) {
            
                // pop out the smallest pending left child
                curNode=pendingCheckNodes.top();
                pendingCheckNodes.pop();
#if DEBUG
cout<<"pop "<<curNode->val<<endl;
#endif

                // update the small index of current node
                smallIdx++;
                
                // if the current node is the N-th smallest one
                if(smallIdx==k) return curNode->val;

                // if the xurrent node has right-side child
                // -> need to check the childs on the right side
                // break the left-side childs check loop
                if(curNode->right) {
                    curNode=curNode->right;
#if DEBUG
cout<<"go right -> "<<curNode->val<<endl;
#endif
                    break;
                }
            }

        } while(curNode || !pendingCheckNodes.empty());
        
        return -1;
    }
};
``` 

# Answer: DFS + Recursive + BST Optimal Traverse (Stack 架構 code 簡化)
- 和 DFS + Stack 走法意義相同
- code 比較簡單，但要先懂上面那個 stack 架構走法
- 但設計上，想法比較複雜： **主要是 kthSmallestOnBST 回傳值，要分為「Invalid」和「Other Valid Value」來實現「上面 while loop 裡面的 early return」
	- 在 recrusive 裡面，early return of answer 需要做成「符合某個條件就一路回傳不繼續 traverse」
```Cpp
#define INVALID_RESULT (-1)
class Solution {
private:
    int kthSmallestOnBST(TreeNode* root, int k, int &smallIdxOfNode) {

		// traverse BST to the leftest end -> which is the smallest node under the root
        if(root->left) {
        
	        // traverse left child
            int leftTravResult = kthSmallestOnBST(root->left, k, smallIdxOfNode);
            
            // if branch under left child satisfies k-smallest -> no need to traverse more
            if(leftTravResult != INVALID_RESULT) return leftTravResult;
            
        }

		// traverse back from child node to parent node -> smallest index++
        smallIdxOfNode++;
        if(k == smallIdxOfNode) return root->val;

		// traverse BST to the right child, and in next call of kthSmallestOnBST -> will traverse left child first
        if(root->right) {
	        // traverse right child
            int rightTravResult = kthSmallestOnBST(root->right, k, smallIdxOfNode);
            
            // if branch under right child satisfies k-smallest -> no need to traverse more
            if(rightTravResult != INVALID_RESULT) return rightTravResult;
            
        }
        
        // if the previous traverse does not match k-smallest -> return invalid
        return INVALID_RESULT;
    }
public:
    int kthSmallest(TreeNode* root, int k) {
        if(!root) return 0;

        int smallIdxOfNode = 0;
        return kthSmallestOnBST(root, k, smallIdxOfNode);
    }
};
```

# Answer: Brute Force + MinHeap & MaxHeap
- 暴力解，適用於任何類型的 tree（不是 binary tree 也可以用）
- 使用兩個 Heap
	- 走過的 node 把 least K values 存起來 -> 用 max heap 自動排序 -> heap top 就是 K-th smallest value
	- 還沒走的 node 放到 waitTraverseNodes -> 用 min heap 自動排序 -> heap top 就是 waiting nodes 裡面 value 最小的
- 注意： **這個方式因為不知道 current node 的 left 是否可以更小而足以更小 K-th smallest value，也不知道是否 left child 分支的 node 不足，需要 right child 來補到 k-th smallest**
	- > **所以這個做法沒辦法直接比對 pending least value node 和 traversed least K-th smallest value 來決定「是否要繼續 traverse left / right child」
	- > 簡單來說「沒辦法像上面這個 DFS 架構，利用 BST 到特性做最短路徑 traverse」
```Cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
    
	    // store the traversed K smallest node values
        auto CmpValSmall = [](int a, int b) {return a < b;};
        priority_queue<int, vector<int>, decltype(CmpValSmall)> valMaxHeapLeastK;

		// the nodes wait to be traversed
        auto CmpNodeLarge = [](TreeNode* a, TreeNode *b) {return a->val > b->val;};
        priority_queue<TreeNode*, vector<TreeNode*>, decltype(CmpNodeLarge)> waitTraverseNodes;

		// traverse through all nodes
        waitTraverseNodes.push(root);
        while( waitTraverseNodes.size() ){

			// select the node with min value in pending list
            TreeNode* node = waitTraverseNodes.top();
            waitTraverseNodes.pop();

			// check whether the node in "traversed least K" needs to be "replaced" or "replemented"
            if(valMaxHeapLeastK.size() < k || (valMaxHeapLeastK.top() > node->val))
                valMaxHeapLeastK.push(node->val);

			// pop out the traversed node values larger than k-smallest 
            while(valMaxHeapLeastK.size() > k)
                valMaxHeapLeastK.pop();

			// push the childs of the current node (the node with least value in pending list) to the heap
            if(node->left) waitTraverseNodes.push(node->left);
            if(node->right) waitTraverseNodes.push(node->right);
        }

        return valMaxHeapLeastK.top();
    }
};
```

# Answer: DFS + InOrder Traverse (複習 2nd 時候寫的 - 利用 BST 的特性最佳化路徑)
```Cpp
class Solution {
private:
    void kthSmallest(TreeNode* node, int k, int &curSmallIdx, int &result) {
        if(!node) return;

        kthSmallest(node->left, k, curSmallIdx, result);

        if(++curSmallIdx == k) result = node->val;
        if(curSmallIdx >= k) return;

        kthSmallest(node->right, k, curSmallIdx, result);
    }    
public:
    int kthSmallest(TreeNode* root, int k) {
        int curSmallIdx = 0, result;
        kthSmallest(root, k, curSmallIdx, result);
        return result;
    }
};
```