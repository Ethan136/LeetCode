---
LeetCodeNeedNextReview: false
LeetCodeNeedEnhance:
  - BinarySearchTree的特性
LeetCodeLv: Medium
---

# LeetCode
[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

# Answer
## 重要性質
- Binary Search Tree - single node
	- 每個 left < parent
	- 每個 right > parent
- Binary Search Tree - **Overall**
	- 所有 left size < parent -> **left child 的 right child，要比 current node 來得小**
		- node->left < node->left->right < node
	- 所有 right size > parent -> **right child 的 left child，要比 current node 來得大**
		- node->right > node->right->left > node
- **注意 grand child node 的大小限制** -> **Current node value 要當作一個 limitation 帶到下 child nodes 給 grand child node 做判斷**
	- left side grand childe right node
		- **[node->left->right] < node**
	- right side grand child left node
		- **[node->right->left] > node**
- 口訣
	- 右左 -> 不能低於 current node
	- 左右 -> 不能超過 current node

## 1st: BFS + Augmented Struct (硬要 BFS)
- 因為node value 可能是 INT_MAX / INT_MIN -> **一開始初始化 limit max / min 的時候必須用更大範圍的 LONG_MIN / LONG_MAX**
- 邪魔歪道，應邀做 BFS，記憶體開銷極大
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    struct checkNode {
        TreeNode* node;
        long limitMin;
        long limitMax;
    };

public:
    bool isValidBST(TreeNode* root) {
        if(!root) return true;

        queue<checkNode> prevLayerNodes;
        queue<checkNode> curLayerNodes;

        prevLayerNodes.push({root, LONG_MIN, LONG_MAX});
        while(prevLayerNodes.empty()==false) {

            while(prevLayerNodes.empty()==false) {
                auto [node, limitMin, limitMax] = prevLayerNodes.front();
                prevLayerNodes.pop();

                if(!node) continue;

                bool leftChkPass = !(node->left) ? (true) : (limitMin < node->left->val) && (node->left->val < node->val);
                if(!leftChkPass) return false;

                bool rightChkPass = !(node->right) ? (true) : (node->right->val < limitMax) && (node->val < node->right->val);
                if(!rightChkPass) return false;

                if(node->left) curLayerNodes.push({node->left, limitMin, node->val});
                if(node->right) curLayerNodes.push({node->right, node->val, limitMax});
            }
            swap(prevLayerNodes, curLayerNodes);
        }
        return true;
    }
};
```
## 2nd: DFS + Recursive
- 因為node value 可能是 INT_MAX / INT_MIN -> **一開始初始化 limit max / min 的時候必須用更大範圍的 LONG_MIN / LONG_MAX**
```Cpp
class Solution {
private:
    bool isValidBST(TreeNode* node, long long minLimit, long long maxLimit) {
        if(!node) return true;

        if(node->left) {
            if(node->left->val >= node->val) return false;
            if(node->left->val <= minLimit) return false;

            if(!isValidBST(node->left, minLimit, node->val)) return false;
        }

        if(node->right) {
            if(node->right->val <= node->val) return false;
            if(node->right->val >= maxLimit) return false;

            if(!isValidBST(node->right, node->val, maxLimit)) return false;
        }

        return true;
    }
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST(root, LONG_LONG_MIN, LONG_LONG_MAX);
    }
};
``` 

## 3rd: DFS + Recursive + Calc Optz
- 先檢查完畢 current node，再做 DFS，有機會較快檢查到 false 的情況
```Cpp
class Solution {
private:
    bool isValidBST(TreeNode* node, long minLimit, long maxLimit) {
        if(!node) return true;

        bool leftNodeCheckPass = (!node->left) || 
                                 ((node->left->val < node->val) && (node->left->val > minLimit));
        if(!leftNodeCheckPass) return false;

        bool rightNodeCheckPass = (!node->right) || 
                                  ((node->val < node->right->val) && (node->right->val < maxLimit));
        if(!rightNodeCheckPass) return false;

        if(node->left && !isValidBST(node->left, minLimit, node->val)) return false;
        if(node->right && !isValidBST(node->right, node->val, maxLimit)) return false;

        return true;
    }
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST(root, LONG_MIN, LONG_MAX);
    }
};

```