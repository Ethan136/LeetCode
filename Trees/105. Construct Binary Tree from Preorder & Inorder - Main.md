---
LeetCodeNeedNextReview:
LeetCodeNeedEnhance:
  - Inroder Traverse
  - Preorder Traverse
  - Postorder Traverse
LeetCodeLv: Medium
---

# LeetCode
[105. Construct Binary Tree from Preorder & Inorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

# 概念
- 要知道 pre-order 和 in-order 兩個 sequence 一起走的時候，兩者要如何匹配

# 解析
完全可以理解你的感覺。
「由前序＋中序重建樹」（LC105/106）表面是 Medium，但迭代 O(n) 寫法其實挺刁鑽，很多 Hard 題都沒這麼多「狀態切換 + 指標同步」的坑。

為什麼會覺得難
	•	同步兩條序列：你要同時「消耗」pre 與 in，任何一邊多一步都會崩。
	•	狀態切換細：在「一路向左」與「向上回溯（連續 pop）」之間切換，一個 == / != 判斷就改變路徑方向。
	•	邊界陷阱：inIdx 越界、pop 次數多/少一次、右子處理時錯誤地再 ++inIdx、dummy 值碰撞等。

一個好背的心智模型（迭代單堆疊）
	•	不變量：棧內維持「從根到目前節點路徑中，右子還沒處理 的那一條鏈」。
	•	掃 pre[i] 時：
	1.	若 st.top()->val != in[j] → 還在左區，把 pre[i] 接成 st.top()->left，並 push（繼續往左）。
	2.	否則（==）→ 左子區已完，連續 while (st.top()->val == in[j]) { pop; ++j; } 回溯到分叉點；
	然後把 pre[i] 接成「回溯到的那個點」的 右子，並 push（轉向右子樹的左鏈）。
	•	這個流程保證每個節點入棧一次、出棧一次 → O(n)。

小小正確性直覺
	•	pre 的定義保證每次拿到的都是當前子樹的根。
	•	in 的等號觸發表示「我們經過了該根的左子樹」；連續等號表示要一路回到尚未接右子的祖先。
	•	兩者指標單調遞增，無迴頭—所以是線性。

常見雷點清單
	•	右子接好後又 ++inIdx（多走一步，之後就全歪）。
	•	while 回溯用「!=」而不是「==」，會把棧清到出事。
	•	進入回合就先讀 pre[preIdx]，但上一回合已把 preIdx 推到 n（左斜樹很容易）→ 越界。
	•	用 dummy 值但沒保證不與輸入重複，dummy 被 pop 走，top() 崩潰。
	•	inIdx 取值前沒檢查 < n。

這題算 Medium 還是 Hard？
	•	官方標 Medium，但迭代最佳解的實作難度體感偏 Hard-：它要求你把遞迴中的邊界與分割（inL..inR）轉譯成「一個棧 + 一個指標」的同步機制。
	•	如果用遞迴（preIdx + inL..inR 或「stop 值」技巧）就爽很多；迭代寫法是為了更小常數與面試熟練度。

記憶小抄（迭代步驟）
	1.	root = pre[0]，push(root)，j=0。
	2.	for i=1..n-1：
	•	若 st.top()->val != in[j]：接左子、push 新節點。
	•	否則：while st.top()->val == in[j]：pop；++j。接右子、push。

建議練習順序
	•	105 / 106（前+中 / 中+後）：先熟遞迴版，再寫迭代版。
	•	889（前+後）：理解為什麼需要「滿二叉樹」條件。
	•	297（序列化/反序列化）：感受 traversal 與建樹互逆。
	•	Morris（中序）：對 in 指標的直覺更強。

你已經攻克了迭代版的核心。再把上面那幾個雷點養成「進出回合的檢查習慣」，這題就會從 Hard 感降回 Medium 感了。

# Answer
## V1: DFS + Iteration + Pending Node Stack
- 主要走 pre-order path 來重建 node
- 比對 in-order 的情況，來看 pre-order path 要如何走
- 有使用 stack 來記錄哪些 node 的 child 還沒處理完畢
- 不需要 map 來映射 pre-order / in-order 兩者對於同一個 node value 的排序關係
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#define DEBUG (0)
class Solution {
private:
    TreeNode* createLeftChildNodeToStack(TreeNode* curNode, int leftChildNodeVal, stack<TreeNode*> &nodeStack) {
        curNode->left = new TreeNode(leftChildNodeVal);
        nodeStack.push(curNode->left);
        return curNode->left;
    }

    TreeNode* popCheckNodesUntilLastMatch(stack<TreeNode*> &nodeStack, vector<int>& valVect, int& nodeCheckIdx) {
        if(nodeStack.empty()) return nullptr;

        TreeNode* lastMatchNode = nullptr;
        for(nodeCheckIdx; nodeCheckIdx < valVect.size(); nodeCheckIdx++) {
            if(nodeStack.empty()) break;
            if(nodeStack.top()->val != valVect[nodeCheckIdx]) break;
            
            lastMatchNode = nodeStack.top();
            nodeStack.pop();
#if DEBUG
cout<<"[pop out]: "<<lastMatchNode->val<<endl;
cout<<" > pending node num: "<<nodeStack.size()<<endl;
#endif
        }
        return lastMatchNode;
    }

    TreeNode* createRightChildNodeToStack(TreeNode* curNode, int rightChildNodeVal, stack<TreeNode*> &nodeStack) {
        curNode->right = new TreeNode(rightChildNodeVal);
        nodeStack.push(curNode->right);
        return curNode->right;
    }

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        // check trasverse path validity
        if(preorder.empty()) return nullptr;

        // create root node
        int preOrdBuildNodeIdx = 0;
        TreeNode* root = new TreeNode(preorder[preOrdBuildNodeIdx++]);

#if DEBUG
cout<<"--------------"<<endl;
cout<<"create root: "<<root->val<<endl;
#endif

        // use a stack to record the nodes of which the child nodes are not created
        stack<TreeNode*> pendingNodes;
        pendingNodes.push(root);

        // to indicate the checked node within in-order path
        int inOrdCheckIdx = 0;

        // create the child nodes
        while(preOrdBuildNodeIdx < inorder.size()) {

            // the most created child node need to create the decendents
            TreeNode *curNode = pendingNodes.top();

#if DEBUG
cout<<"--------------"<<endl;
cout<<"curNode: "<<curNode->val<<endl;
cout<<"inord Node: "<<inorder[inOrdCheckIdx]<<endl;
#endif
            // if the pre-order trasverse path does not match the in-order path
            // -> *there's left child on the current node
            // -> **and the left child value is the next index within in-order path**
            if(curNode->val != inorder[inOrdCheckIdx]) {

                // create new node and set as left child of the current one
                createLeftChildNodeToStack(curNode, preorder[preOrdBuildNodeIdx++], pendingNodes);

#if DEBUG
cout<<"[create left]: "<<curNode->left->val<<endl;
cout<<" > pending node num: "<<pendingNodes.size()<<endl;
#endif
                continue;
            }

            // if the pre-order created node matches the in-order trasverse node
            // -> there's no child on the left side of current node
            // -> get the pending nodes until the "last one match the in-order trasverse node" -> this one is the node with right child
            TreeNode* parentNodeOfRightChild = popCheckNodesUntilLastMatch(pendingNodes, inorder, inOrdCheckIdx);

            // create right child to the parent node
            createRightChildNodeToStack(parentNodeOfRightChild, preorder[preOrdBuildNodeIdx++], pendingNodes);

#if DEBUG
cout<<"[create right]: "<<parentNodeOfRightChild->right->val<<endl;
cout<<" > pending node num: "<<pendingNodes.size()<<endl;
#endif
        }

        // return root node
        return root;
    }
};
``` 


## V2: DFS + Iteration + PreAllocate All Nodes
- 先建好 pre-order sequence 每一個 node
- 建立一個 map 檢查每個 pre-order 的 value 所對應的 index
- 然後開始 traverse + 檢查 in-order 的資訊，來決定「要跳到哪一個 pre-order node 來做連結」
- **這個是畫一個圖，記錄 in-order / pre-order traverse sequence，然後找出規律，本身是蠻不直觀的做法**
```Cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int> preorderValToIdx;
        vector<TreeNode*> preorderNodes(preorder.size());

        for(int i = 0; i < preorder.size(); i++) {
            preorderNodes[i] = new TreeNode(preorder[i]);
            preorderValToIdx[preorder[i]] = i;
        }

        TreeNode augmentRoot;
        TreeNode *curNode = &augmentRoot;

        for(int preordIdx = 0, inordIdx = 0;
                preordIdx < preorder.size() && inordIdx < inorder.size();
                inordIdx++) {

            int preorderVal = preorder[preordIdx];
            int inorderVal = inorder[inordIdx];

			// inorder check value = preorder check value -> must be the right child of the curNode
            if(preorderVal == inorderVal) {
                curNode->right = preorderNodes[preordIdx];
                curNode = preorderNodes[preordIdx++];
            }

			// if in-order value within pre-order sequence corresponds to the later index
			// -> this in-order value is the "leftest child of right sub-tree of current node"
            else if(preorderValToIdx[ inorderVal ] > preordIdx) {
                curNode->right = preorderNodes[preordIdx];
                curNode = preorderNodes[preordIdx++];

                while(preordIdx <= preorderValToIdx[ inorderVal ]) {
                    curNode->left = preorderNodes[preordIdx];
                    curNode = preorderNodes[preordIdx++];
                 }
            }

			// if in-order value within pre-order sequence corresponds to the earlier index
			// -> this in-order value is the "trace back middle node of in-order traverse"
            else {
                curNode = preorderNodes[ preorderValToIdx[ inorderVal ] ];
            }
        }

        return preorderNodes[0];
    }
};
```


## V3: DFS + Iteration + Preorder Traverse
- 整體來說是 DFS + Preorder Traverse
	- traverse left child
	- 退回 parent node until right child exist
	- traverse right child
- 而至於要如何判斷當下是否 traverse left child / 退回 parent node / traverse right child
	- traverse left
		- preorder 最初的 node 一定是 root of whole tree
		- inorder 最初的 node 一定死 leftest of whole tree
		- 上面兩個不同的時候，就代表一定有一條 root -> leftest 的路徑
			- preorder 一路往 left child 走
			- 走的途中建立 node 並且把建立好的 node 放到 stack
		- 走到 leftest child 後
			- preorder idx 更新到 preorder 走完 left child's 後的『right child node』
			- **但這時候不知道這個 right child node 接到 stacked nodes 的哪一個的 right child** -> *這時候就要靠 inorder seq 來做判斷*
	- 完成 root -> leftest 的路徑後，這時候 in-order traverse 會開始 track back to parent -> 對應到 preorder 放在 stack 裡面的 node
		- 只要『走過的 preorder stack node』 等於 preorder seq[ preordIdx]
		- 則一路 trace back
			- 直到（1）inord seq / preorder seq 不相等
			- 直到（2）preorder stack 排空
		- 注意: trace back 的時候
			- preorder stack pop node
			- 這些 node 都是 preorder 已經走過，但 inorder 還沒走過的 -> 更新 inorder idx
		- 注意: **這邊也包含了，走到 right child node 後，下一個 node 也是 right child node 的情況**
	- traverse right
		- preorder 這時候 preordIdx 一定指向 right child node
			- 建立一個 node
			- 把前一個步驟最後一個 stack popped node 的 right child link 接到這個 node
		- 建立好的 right child，不確定是不是還繼續有 right child -> 放到 stack 裡面
```Cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        // check valitify of inputs
        if(preorder.empty() || inorder.empty() || preorder.size() != inorder.size()) {
            return nullptr;
        }

        // traverse index waiting to be processed
        int inordIdx = 0;
        int preordIdx = 0;

        // preord traversed nodes waiting to for handling child nodes
        stack<TreeNode*> preordPendingNodes;

        // traverse to root node
        TreeNode *root = new TreeNode(preorder[ preordIdx++ ]);
        preordPendingNodes.push(root);

        // do preorder traverse
        for(; preordIdx < preorder.size(); preordIdx++) {
            // (1) preorder not match inorder
            // -> inorder indicates the leftest child of the  current sub-tree
            if(preordPendingNodes.size() && preordPendingNodes.top()->val != inorder[ inordIdx ]) {
                TreeNode* leftChild = new TreeNode( preorder[ preordIdx ]);
                preordPendingNodes.top()->left = leftChild;
                preordPendingNodes.push( leftChild );
                continue;
            }

            // (2) preorder match inorder on the leftest child node
            // -> trace back to parent node by in-order traverse sequence
            TreeNode *traceBackToParentNode;
            while(preordPendingNodes.size() && (preordPendingNodes.top()->val == inorder[ inordIdx ])) {
                traceBackToParentNode = preordPendingNodes.top();
                preordPendingNodes.pop();
                inordIdx++;
            }

            // (3) preorder traverse to right child after track back to parent node
            // -> now the next node is the right child
            TreeNode* rightChild = new TreeNode(preorder[ preordIdx ]);
            traceBackToParentNode->right = rightChild;
            preordPendingNodes.push(rightChild);
        }
    
        // return tree root
        return root;
    }
};
```