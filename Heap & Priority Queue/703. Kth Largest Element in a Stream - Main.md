---
ParentTask:
  - "[[heap___priority_queue]]"
---

# LeetCode
[703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/)

# Concept
- **直覺上來說，會想儲存所有數字，用兩個 heap 來紀錄儲存的內容**
- **但實際上來說，題目只要求 K-th，也就是比這些小的，其實都可以捨棄**

# Answer
## V1 - 針對 val < k-th value 的情況沒有優化，仍然會 push / pop heap
```Cpp
#define STORE_NUM_AFTER_K_LARGEST   (FALSE)
class KthLargest {
private:
    int m_k;

    // to store the largest k-th nums (min-heap)
    // from samll (k-th) to large (1st)
    priority_queue<int, vector<int>, greater<int>> m_largest_k_minHeap;

#if STORE_NUM_AFTER_K_LARGEST
    // to store the nums after k-th (max-heap)
    // from largest (k+1)-th to smallest
    priority_queue<int, vector<int>, less<int>> m_other_maxHeap;
#endif

public:
    KthLargest(int k, vector<int>& nums) {
        // k-th setting
        m_k = k;

        // (1) put all the nums to the largetst-k minHeap
        for(auto num : nums) m_largest_k_minHeap.push(num);

        // (2) then will pop out the number after k-th
        while(m_largest_k_minHeap.size() > m_k) {

#if STORE_NUM_AFTER_K_LARGEST
            // push the smallest num after k-th to the other group
            m_other_maxHeap.push( m_largest_k_minHeap.top() );
#endif

            // pop out the num after k-th
            m_largest_k_minHeap.pop();
        }
    }
    
    int add(int val) {

        // put the new value to the largetst-k minHeap
        m_largest_k_minHeap.push(val);

        // if the stored num does not exceed k -> return the smallest one
        if(m_largest_k_minHeap.size() <= m_k) return m_largest_k_minHeap.top();

#if STORE_NUM_AFTER_K_LARGEST
        // push the smallest num after k-th to the other group
        m_other_maxHeap.push( m_largest_k_minHeap.top() );
#endif

        // pop out the num after k-th
        m_largest_k_minHeap.pop();

        // return the k-th num
        return m_largest_k_minHeap.top();
    }
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest* obj = new KthLargest(k, nums);
 * int param_1 = obj->add(val);
 */
``` 

## V2 - 針對 val < k-th value 的情況優化，此時不用 push / pop heap
```Cpp
class KthLargest {
private:
    int m_K;
    priority_queue<int, vector<int>, greater<int>> m_minHeapMaxKVal;
public:
    KthLargest(int k, vector<int>& nums) {
        m_K = k;
        for(int num : nums) m_minHeapMaxKVal.push(num);
        while(m_minHeapMaxKVal.size() > k) m_minHeapMaxKVal.pop();
    }
    
    int add(int val) {
        if(m_minHeapMaxKVal.size() < m_K) {
            m_minHeapMaxKVal.push(val);
            return m_minHeapMaxKVal.top();
        }

        if(val <= m_minHeapMaxKVal.top()) {
            return m_minHeapMaxKVal.top();
        }

        m_minHeapMaxKVal.push(val);
        m_minHeapMaxKVal.pop();
        return m_minHeapMaxKVal.top();
    }
};

```
