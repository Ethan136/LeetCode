---
ParentTask:
  - "[[heap___priority_queue]]"
---

# LeetCode
[973. K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)

# Answer - 使用 min heap：每個 point 都 push 進去，再取前 k 個出來
```Cpp
#define VEC_TO_RIGIN_DIST(vec) (vec[0]*vec[0] + vec[1]*vec[1])
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {

        // compare the distance to the origin of two 2D points
        // -> the larget should be on the bottom
        // -> smaller on the top of heap
        auto distLessToOrigin = [](const vector<int>& a, const vector<int>& b) {
            return (VEC_TO_RIGIN_DIST(a) > VEC_TO_RIGIN_DIST(b));
        };

        // create a min distance heap and push all the point into
        priority_queue< vector<int>, vector<vector<int>>, decltype(distLessToOrigin) > minDistToOriginHeap;
        for(auto point : points) minDistToOriginHeap.push(point);

        // initialize the result
        vector<vector<int>> result(k);

        // push the k-the smallest points to the result
        for(int i = 0; i < k; i++) {
            result[i] = minDistToOriginHeap.top();
            minDistToOriginHeap.pop();
        }

        // finish
        return result;
    }
};
``` 

# Answer - 使用 max heap：heap 維持 K 個 element 從最近排到 k-th further
## V1 - 直覺版：所有 point 都 push 進去，size() 超過 k 的時候 pop 一個出來
```Cpp
#define VEC_TO_RIGIN_DIST(vec) (vec[0]*vec[0] + vec[1]*vec[1])
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {

        // compare the distance to the origin of two 2D points
        // -> the larget should be on the bottom
        // -> smaller on the top of heap
        auto distLargerToOrigin = [](const vector<int>& a, const vector<int>& b) {
            return (VEC_TO_RIGIN_DIST(a) < VEC_TO_RIGIN_DIST(b));
        };

        // create a min distance heap and push all the point into
        // keep ONLY THE SMALLEST K POINTS -> the larger points will be popped out
        priority_queue< vector<int>, vector<vector<int>>, decltype(distLargerToOrigin) > heapKeepOnlyKPoint;
        for(auto point : points) {
            heapKeepOnlyKPoint.push(point);
            if(heapKeepOnlyKPoint.size() > k) heapKeepOnlyKPoint.pop();
        }

        // initialize the result
        vector<vector<int>> result(k);

        // the remained k-nums in the heap is the K-th smallest of all the nums
        // the top of heap is the largest within k-nums
        // push the k-the smallest points to the result
        for(int i = (k-1); i >= 0; i--) {
            result[i] = heapKeepOnlyKPoint.top();
            heapKeepOnlyKPoint.pop();
        }

        // finish
        return result;
    }
};
```


## V2 - 優化版：size 小於 k 的時候一律 push，後續要 push 前先檢查 point dist <= heap.top()
```Cpp
#define POINT_DIST_TO_ORIGIN(_POINT_)   (_POINT_[0] * _POINT_[0] + _POINT_[1] * _POINT_[1])
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        auto cmpCloser = [](auto &a, auto &b) {
            return (POINT_DIST_TO_ORIGIN(a) <= POINT_DIST_TO_ORIGIN(b));
        };
        priority_queue< vector<int>, vector<vector<int>>, decltype(cmpCloser) > maxDistHeap;

        for(auto &point : points) {
            
            if( maxDistHeap.size() < k) {
                maxDistHeap.push(point);
                continue;
            }

            if( POINT_DIST_TO_ORIGIN(point) <= POINT_DIST_TO_ORIGIN(maxDistHeap.top())) {
                maxDistHeap.push(point);
                maxDistHeap.pop();
            }
        }

        vector<vector<int>> result; result.reserve(k);
        while(result.size() < k) {
            result.push_back(maxDistHeap.top());
            maxDistHeap.pop();
        }

        return result;
    }
};
```

## V3：複習2nd - 模板化寫法
```Cpp
class Solution {
private:
    struct distInfo {
        int distSqrt;
        int idx;
    };
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        auto cmpPointLess = [](auto &a, auto &b) {return a.distSqrt < b.distSqrt;};
        priority_queue<distInfo, vector<distInfo>, decltype(cmpPointLess)> maxHeapKClosest;

        for(int i = 0; i < points.size(); i++) {
            auto &point = points[i];
            int distSqrt = point[0] * point[0] + point[1] * point[1];

            if(maxHeapKClosest.size() < k) {
                maxHeapKClosest.push({distSqrt, i});
                continue;
            }

            if(distSqrt >= maxHeapKClosest.top().distSqrt) {
                continue;
            }

            else {
                maxHeapKClosest.push({distSqrt, i});
                maxHeapKClosest.pop();
            }
        }

        vector<vector<int>> result; result.reserve(k);
        while(maxHeapKClosest.size()) {
            result.push_back( points[ maxHeapKClosest.top().idx ] );
            maxHeapKClosest.pop();
        }
        return result;
    }
};
```
# Answer - 使用 key - ordered - map 來做 bulk sort（速度很慢，當作練習）
**注意：map<key, val> 速度超慢**
```Cpp
#define POINT_DIST_TO_ORIGIN(_POINT_)   (_POINT_[0] * _POINT_[0] + _POINT_[1] * _POINT_[1])
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        map<int, vector<vector<int>> > distToPointVec;
        for(auto &point : points) {
            int dist = POINT_DIST_TO_ORIGIN(point);
            distToPointVec[dist].push_back(point);
        }

        vector<vector<int>> result; result.reserve(k);
        for(auto &[dist, pointsOfDist]: distToPointVec) {
            for(auto &point : pointsOfDist) {
                result.push_back(point);
                if(result.size() >= k) return result;
            }
        }
        return result;
    }
};
```