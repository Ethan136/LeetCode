---
ParentTask:
  - "[[heap___priority_queue]]"
---

# LeetCode
[355. Design Twitter](https://leetcode.com/problems/design-twitter/)

# Concept
- 依照使用者分開儲存 -> 需要一個 map
- 每次都 post 要記得當下 post 是最新的，而且 postID 分配是隨機的 -> 需要一個 time stamp 作為 class member 
- 每次 getPost 會取得『自己的 ，或 其他人的』 最新 post，總共 10 個 -> 檢查 time stamp，並且找出符合的 user ID 的 10 個 post
	- userID + time stamp 存在各個 user 的區塊內 -> 要喇在一起排序 -> maxTimeStampHeap
	- 各個 followed + oneself 各自把最新的 post 放到 heap
	- 然後開始分配 post -> heap 取出 time stamp 最大的 post -> 然後看這個 post 是哪個 user -> 再從這個 user 往前取一筆 post

# Answer：Brute Force - 所有 post + userID 依照順序儲存到 vector，再一個一個取出來
```Cpp
#define MAX_NEWS_FEED_NUM   (10)
class Twitter {
private:
    struct tTweetInfo {
        int userId;
        int tweetId;
    };
    vector<tTweetInfo> m_tweetHistory;
    unordered_map<int, unordered_set<int>> m_feedMap;

public:
    Twitter() {

    }
    
    void postTweet(int userId, int tweetId) {
        m_tweetHistory.push_back({userId, tweetId});
    }
    
    vector<int> getNewsFeed(int userId) {

        // initialize result
        vector<int> tweetIdVec;

        // check follow condition and add to result
        int lastTweetIdx = int(m_tweetHistory.size()) - 1;
        for(int i = lastTweetIdx; i >= 0; i--) {

            if(tweetIdVec.size() >= MAX_NEWS_FEED_NUM) {
                break;
            }

            if( m_tweetHistory[i].userId == userId ) {
                tweetIdVec.push_back( m_tweetHistory[i].tweetId );
                continue;
            }

            if(m_feedMap[userId].count(m_tweetHistory[i].userId)) {
                tweetIdVec.push_back( m_tweetHistory[i].tweetId );
                continue;
            }
        }

        // finish
        return tweetIdVec;
    }
    
    void follow(int followerId, int followeeId) {
        m_feedMap[followerId].insert(followeeId);
    }
    
    void unfollow(int followerId, int followeeId) {
        m_feedMap[followerId].erase(followeeId);
    }
};

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter* obj = new Twitter();
 * obj->postTweet(userId,tweetId);
 * vector<int> param_2 = obj->getNewsFeed(userId);
 * obj->follow(followerId,followeeId);
 * obj->unfollow(followerId,followeeId);
 */
```

# Answer：所有 Post 分 User 儲存並加上 TimeStamp，再把 followee post 放到 Heap 做分配
## V1：加上 debug print 的詳細版
```Cpp
 #define DEBUG (0)
#define MAX_NEWS_FEED_NUM   (10)
class Twitter {
private:
    struct postInfo{
        int tweetId;
        int timeStamp;
    };

    struct postPtr {
      int userId;
      int storeIdx;
    };

    int getTweetIdFromPostPtr(postPtr const &a) {
        return m_tweetHistoryOfUser[a.userId].size() ? m_tweetHistoryOfUser[a.userId][a.storeIdx].tweetId : -1;
    }

    int getTimeStamp(postPtr ptr) {
        return m_tweetHistoryOfUser[ptr.userId].size() ? m_tweetHistoryOfUser[ptr.userId][ptr.storeIdx].timeStamp : -1;
    }
        
    int m_timeStamp;
    unordered_map<int, unordered_set<int>> m_feedMap;
    unordered_map<int, vector<postInfo>> m_tweetHistoryOfUser;

#if DEBUG
#define dbgPrintStr(STR) cout<<STR<<endl;

    void debugPrintFollowingPostsOfUsertId(int userId) {
        for(auto userId : m_feedMap[userId]) {
            cout << "[Following Id]: " << userId << endl;

            for(auto postInfo : m_tweetHistoryOfUser[userId]) {
                cout << "tweet id: " << postInfo.tweetId << " | timestamp: " << postInfo.timeStamp << endl;
            }

            cout << endl;
        }
    }
    void debugPrintAfterPostTweet(int userId, int tweetId) {
        cout << "------------post tweet-------------" << endl;
        cout << "userId: " << userId << " | " << "tweetId: " << tweetId << endl;
        debugPrintFollowingPostsOfUsertId(userId);
    }
    void debugPrintNewsFeed(int userId) {
        cout <<"------------Get News Feed - User Id: "<< userId << "-----------------" << endl;
        debugPrintFollowingPostsOfUsertId(userId);
    }
    void debugPrintPostInfo(postPtr ptr) {
        cout
        << "userId: " << ptr.userId
        << " | storeIdx: " << ptr.storeIdx 
        << " | timeStamp: " << getTimeStamp(ptr)
        << " | tweetId: " << getTweetIdFromPostPtr(ptr)
        << endl;
    }

#define dbgPrintFollowerAndFollowee(title, followerId, relation, followeeId) \
cout << title << endl << "followerId: " << followerId << relation << "followeeId: " << followeeId << endl;

#else
#define dbgPrintStr(STR)
#define debugPrintAfterPostTweet(_DUMMY1_, _DUMMY2_)
#define debugPrintNewsFeed(_DUMMY_)
#define debugPrintPostInfo(_DUMMY_)
#define dbgPrintFollowerAndFollowee(_DUMMY_1, _DUMMY2_, _DUMMY3_, _DUMMY4_)
#endif

public:
    Twitter() {
        m_timeStamp = 0;
    }
    
    void postTweet(int userId, int tweetId) {

        // any user follows one-self
        if(!m_feedMap[userId].contains(userId)) m_feedMap[userId].insert(userId);

        // add post to history
        m_tweetHistoryOfUser[userId].push_back({
            .tweetId = tweetId,
            .timeStamp = m_timeStamp++
        });

        // debug print info
        debugPrintAfterPostTweet(userId, tweetId);
    }
    
    vector<int> getNewsFeed(int userId) {

        // debug print function start
        debugPrintNewsFeed(userId);

        // initialize result
        vector<int> tweetIdVec;

        // use a max heap to sort out the posts of the following users
        // pair = {timestamp , postPtr}
        auto cmpLessOfPostPtr = [](pair<int, postPtr> const &a, pair<int, postPtr> const &b) { return (a.first < b.first); };
        priority_queue<pair<int, postPtr>, vector<pair<int, postPtr>>, decltype(cmpLessOfPostPtr)> latestPostsHeap;

        // kind of sort: push the newest posts of all the following users into the heap
        dbgPrintStr("[Init Max TimeStamp Post Heap]");
        for(auto followId : m_feedMap[userId]) {
            if(m_tweetHistoryOfUser[followId].empty()) continue;

            postPtr latestPostPtrOfFollowUser = {
                    .userId = followId,
                    .storeIdx = int(m_tweetHistoryOfUser[followId].size()) - 1
            };

            latestPostsHeap.push( {getTimeStamp(latestPostPtrOfFollowUser), latestPostPtrOfFollowUser} );

            // debug print
            debugPrintPostInfo(latestPostPtrOfFollowUser);
        }

        // sort posts by time stamp
        dbgPrintStr("[Start Fetch TweetId From Heap]");
        for(int postNum = 0; (postNum < MAX_NEWS_FEED_NUM && !latestPostsHeap.empty()); postNum++) {

            // pop out the ptr of latest post
            postPtr latestPostPtr = latestPostsHeap.top().second; 
            latestPostsHeap.pop();
            
            // debug print
            debugPrintPostInfo(latestPostPtr);

            // fetch the latest post from the user
            tweetIdVec.push_back( getTweetIdFromPostPtr( latestPostPtr ) );

            // push the earlier post of the user to the heap (since the latest one has been popped out)
            if( --latestPostPtr.storeIdx >= 0) latestPostsHeap.push( {getTimeStamp(latestPostPtr), latestPostPtr} );
        }

        // finish
        return tweetIdVec;
    }
    
    void follow(int followerId, int followeeId) {
        dbgPrintFollowerAndFollowee("--------follow--------", followerId, " --> ", followeeId);
        m_feedMap[followerId].insert(followeeId);
    }
    
    void unfollow(int followerId, int followeeId) {
        dbgPrintFollowerAndFollowee("--------unfollow--------", followerId, " -X-> ", followeeId);
        m_feedMap[followerId].erase(followeeId);
    }
};

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter* obj = new Twitter();
 * obj->postTweet(userId,tweetId);
 * vector<int> param_2 = obj->getNewsFeed(userId);
 * obj->follow(followerId,followeeId);
 * obj->unfollow(followerId,followeeId);
 */
```

## V2: 複習時候的簡化版
```Cpp
#define FETCH_NEW_FEED_NUM  (10)
class Twitter {
private:
    struct postTimeInfo {
        int timeStamp;
        int tweetId;
    };
    unordered_map<int, vector<postTimeInfo>> m_userPosts;

    unordered_map<int, unordered_set<int>> m_followMap;

    int m_timeStamp;

private:
    struct postFullInfo {
        int userId;
        int timeStamp;
        int tweetId;
    };
    
public:
    Twitter() {
        m_timeStamp = 0;
    }
    
    void postTweet(int userId, int tweetId) {
        m_userPosts[userId].push_back({m_timeStamp++, tweetId});
    }
    
    vector<int> getNewsFeed(int userId) {

        // set the arbiter
        auto cmpPostTime = [](auto &a, auto &b) {return a.timeStamp < b.timeStamp;};
        priority_queue<postFullInfo, vector<postFullInfo>, decltype(cmpPostTime)> newPostHeap;

        // available un-feed posts from the followee
        unordered_map<int, int> availablePostLen;

        // user's posts
        if(m_userPosts[userId].size() ) {
            availablePostLen[userId] = m_userPosts[userId].size();
            auto [timeStamp, tweetId] = m_userPosts[userId][ --availablePostLen[userId] ];
            newPostHeap.push({ userId, timeStamp, tweetId } );
        }

        // follower posts
        for(int f : m_followMap[userId]) {
            if(m_userPosts[f].empty()) continue;
            availablePostLen[f] = m_userPosts[f].size();

            auto [timeStamp, tweetId] = m_userPosts[f][ --availablePostLen[f] ];
            newPostHeap.push({ f, timeStamp, tweetId });
        }

        // assign post from newest to oldest
        vector<int> newsFeed; newsFeed.reserve(FETCH_NEW_FEED_NUM);
        for(int i = 0; ( newPostHeap.size() && (i < FETCH_NEW_FEED_NUM) ); i++) {
            auto [f, timeStamp, tweetId] = newPostHeap.top();
            newPostHeap.pop();

            newsFeed.push_back(tweetId);

            if(availablePostLen[f] <= 0) continue;
            auto [timeStampNext, tweetIdNext] = m_userPosts[f][ --availablePostLen[f] ];
            newPostHeap.push( {f, timeStampNext, tweetIdNext} );
        }

        return newsFeed;
    }
    
    void follow(int followerId, int followeeId) {
        if(followerId == followeeId) return;
        m_followMap[followerId].insert(followeeId);
    }
    
    void unfollow(int followerId, int followeeId) {
        if(followerId == followeeId) return;
        m_followMap[followerId].erase(followeeId);
    }
};

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter* obj = new Twitter();
 * obj->postTweet(userId,tweetId);
 * vector<int> param_2 = obj->getNewsFeed(userId);
 * obj->follow(followerId,followeeId);
 * obj->unfollow(followerId,followeeId);
 */
```