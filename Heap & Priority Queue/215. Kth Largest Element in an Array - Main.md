---
ParentTask:
  - "[[heap___priority_queue]]"
---

# LeetCode
[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

# Answer：max heap - 全部 num push / 然後 pop K 個 -> 操作量較大，速度較慢
```Cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, less<int>> maxHeap;

        for(auto num : nums) {
            maxHeap.push(num);
        }

        int lastPopNum;
        for(int i = 0; i < k; i++) {
            // pop one element from heap
            lastPopNum=maxHeap.top();

            // pop out the num
            maxHeap.pop();

        }
        return lastPopNum;
    }
};
``` 

# Answer：min heap - 維持 heap size = K 個
## V1：一律 push 進去，size > K 的時候 pop 一個出來 -> 大量 push / pop 速度最慢
```Cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> minHeap;

        for(auto num : nums) {
            minHeap.push(num);
            if(minHeap.size()>k) minHeap.pop();
        }

        return minHeap.top();
    }
};
```

## V2：只有在 size < K 或是 num 大於 heap.top() 的時候才 push 進去 -> 操作量最佳化速度最快
```Cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int> > minHeapKLargest;

        for(int num : nums) {
            if(minHeapKLargest.size() < k) {
                minHeapKLargest.push(num);
                continue;
            }

            if(minHeapKLargest.top() < num) {
                minHeapKLargest.push(num);
                minHeapKLargest.pop();
            }
        }

        return minHeapKLargest.top();
        
    }
};
```