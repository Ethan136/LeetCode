---
ParentTask:
  - "[[heap___priority_queue]]"
---

# LeetCode
[621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)

# Concept
極端 case 情況思考
- **基本 case：各個 task 的情況分散 -> 輪流分配** -> AA, BB, CC, DD, EE
- **極端 case：某一種 task 很多，其他類型 task 很少 -> 需要用 heap，從多的開始分配，每一輪分配不重複** -> AAAAAAA, BB
- **極端 case2：某一種 task 很多，其他類型 task 很少，但其他的 task『類型很多』，從多的開始分配，每一輪 (n+1) interval** -> AAAAAAAAA, B, C, D, E, F, G, H

**型別注意**
- 'A' + i 這種計算（int i） 可能會出錯
- 如果要走一輪 'A' to 'Z' 可以用  `for(char c = 'A'; c <= 'Z'; c++)`

執行思考
- 『這一輪輪流處理不同 task + 最多處理 (n+1) different tasks』 -> **要思考下一步是：如何沒做完的放到下一輪，因為 (n+1) 限制沒輪刀的如何放到下一輪**

資訊簡化
- **其實可以不用存『每個 task 的 type char，只要存有幾個 task 即可』** -> **可以直接一個 array 紀錄各個 task type 的時間，array size = total types**

# Answer：每一輪以 (n+1) 個 Interval 來分配 Task，每個 Task 一輪分配一次，直到全部分配完畢
```Cpp
#define PRINT_VAR(var) cout << #var << ": " << var << endl;
class Solution {
private:
    struct taskInfo {
        char task;
        int cnt;
    };
public:
    int leastInterval(vector<char>& tasks, int n) {
        // bulk sort the tasks
        vector<int> taskTypeCnt(26,0);

        // set in groups with n+1 different members
        for(char task : tasks) {
            taskTypeCnt[task - 'A']++;
        }

        // use a maxHeap to store the grouped stasks
        auto cmpTaskCnt = [](auto &a, auto &b) {
            return a.cnt < b.cnt;
        };
        priority_queue<taskInfo, vector<taskInfo>, decltype(cmpTaskCnt)> thisTermTaskHeap;

        // push all classified tasks to the heap
        for(char c = 'A'; c <= 'Z'; c++) {
            int taskCnt = taskTypeCnt[c - 'A'];
            if(taskCnt) thisTermTaskHeap.push({.task = c, .cnt = taskCnt});
        }

        // to store all the used tasks in current term and have to be scheduled in the next term
        priority_queue<taskInfo, vector<taskInfo>, decltype(cmpTaskCnt)> nextTermTaskHeap;

        // schedule all tasks until finish
        int scheduleInterval = 0;
        while(thisTermTaskHeap.size()) {

            // schedule the tasks
            for(int i = 0; i < (n+1); i++) {

				// if there's no task remain
				if(thisTermTaskHeap.empty() && nextTermTaskHeap.empty()) break;
	
				// update overall interval counter for the scheduling
	            scheduleInterval++;

				// if there's not task could be scheduled in this term -> keep waiting
				if(thisTermTaskHeap.empty()) continue;

				// schedule from the task with most count
				auto [task, cnt] = thisTermTaskHeap.top();
				thisTermTaskHeap.pop();

				// proceed the task
				cnt--;
			
				// if this type of task has not been finished -> push to the next term
				if(cnt) nextTermTaskHeap.push({.task = task, .cnt = cnt});
            }

			// move all the un-scheduled tasks to next term
			while(thisTermTaskHeap.size()) {
				nextTermTaskHeap.push(thisTermTaskHeap.top());
				thisTermTaskHeap.pop();
			}

            // swap the heap for the next term of scheduling
            swap(thisTermTaskHeap, nextTermTaskHeap);
        }

        return scheduleInterval;
    }
};
```

# Answer：每一輪以 (n+1) 個 interval 分配 Task，但不使用 heap，而是每一輪分配完畢後重新vector sort
```Cpp
#define DEBUG (0)
class Solution {
private:
    struct tTask{
        char label;
        int count;
    };
public:
    int leastInterval(vector<char>& tasks, int n) {

        // count the task num
        unordered_map<char,int> taskCntMap;
        for(auto label : tasks) taskCntMap[label]++;

        // the overall remained tasks
        vector<tTask> taskVec;
        for(auto [label, count] : taskCntMap) {
            taskVec.push_back({label, count});
        }

        // sort the tasks by the required operation count
        sort(taskVec.begin(), taskVec.end(),
            [](auto &a, auto &b) {return a.count > b.count;}
        );


        // operat all tasks
        int timeElapse=0;
        while(taskVec.size()) {

            // one term of tasks operation: operate each task at most one time
            for(int i=0, taskIdx=0;
                (i<n+1);
                i++, timeElapse++) {

                // if there's no tasks to be operated
                if(taskVec.empty()) {
                    break;
                }

                // if all the available tasks have been operated in this term -> wait in idle
                if(taskIdx >= taskVec.size()) {
                    continue;
                }

                // operate a task and update remained count
                taskVec[ taskIdx ].count--;

                // take out the task if is has been finished
                if(taskVec[ taskIdx ].count == 0) {
                    taskVec.erase(taskVec.begin() + taskIdx);
                    continue;
                }

                // update the index of task to be operated
                taskIdx++;
            }

            // sort the tasks after each term of operation
            sort(taskVec.begin(), taskVec.end(),
                 [](auto &a, auto &b)
                 {return a.count > b.count;}
            );
        }
        return timeElapse;
        
    }
};
```

# Answer：直接思考『max cnt tasks 排序完畢的情況』來推算最多有幾個 idle -> 再看這些 idle 如何填入 other tasks
- **瓶頸會發生在『重複次數最多的 task』**
	- 比如 AAAAAAA, BBB, CC, DD, E, F, G, H, I, J, K, L, M
	- 則 schedule 的結果一定是 [A ...], [A...], [A...], [A...], [A...], [A], [Other Remained Non-Idle Schedule]
	- 其中 [...] 為可能的 idle 發生之處
- **這時候會發現， idle max cnt = (n) * (Task Max Cnt - 1)**
	- (Task Max Cnt - 1) = 會發生 idle cnt 的 term number
- 然後再檢查 idle 如何填滿 -> 從剩餘的 tasks 從 task 量大的，依序填到 task 量少的
	- 剩餘 task，一種最多減少 (Task Max Cnt - 1) 個 idle cnt（因為一個 term 最多安排一種 task）
- 最後計算 total task cnt + idle cnt = solution

```Cpp

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
	    // statistics of all tasks
		vector<int> taskCnt(26, 0);
		for(char task : tasks) taskCnt[ task - 'A' ]++;

		// sort all tasks in descending order
		sort(taskCnt.begin(), taskCnt.end(), greater<int>());

		// arrange the max cnt task to each group | [TaskType, _, _, _, ...] x K, [TaskType] x 1 | (where _ means idle)
		int mostUsedTaskCnt = taskCnt[0];
		int maxTermNumWithIdle = (mostUsedTaskCnt - 1);
		int maxIdleCnt = n * maxTermNumWithIdle;

		// calculate how many idle interval could be filled by the remained tasks
		int idleCnt = maxIdleCnt;
		for(int i = 1; (i < 26) && (idleCnt); i++) {
			idleCnt -= min(taskCnt[i], maxTermNumWithIdle);
			if(idleCnt < 0) idleCnt = 0;
		}

		// return total intervals
		return tasks.size() + idleCnt;
    }
};

```