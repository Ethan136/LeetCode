---
ParentTask:
  - "[[heap___priority_queue]]"
---

# LeetCode
[295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

# Concept
- 動態加入 num，隨時更新 middle value
- 使用兩個 heap：max heap / min heap
	- max heap 放小數字
	- min heap 放大數字
- 左：max heap（放 N/2 + 1 個 element，也就是包含中間值）
	- 如果 max heap 是空的 -> 第一個放進來的 element -> 放到 max heap
	- 如果 num < max heap.top() -> 有新的小值放到左邊 -> 放到 max heap
	- 如果放到 max heap 後，『左邊數量 > 右邊+1』 -> 左邊取出一個放到右邊
- 右：min heap（放 N/2 個 element，不包含中間值）
	- 如果 num > min heap.top() -> 有新的小值放到右邊 -> 放到 min heap
	- 如果放到 min heap 後，『右邊數量 > 左邊』 -> 右邊取出一個放到左邊

# Answer: double heap balance
```Cpp
class MedianFinder {
private:
    // store (n/2+1) smaller numbers
    priority_queue<int, vector<int>, less<int>> m_smallerHalfMaxHeap;

    // store (n/2) larget numbers
    priority_queue<int, vector<int>, greater<int>> m_largerHalfMinHeap;

    int getStoredCnt() {
        return (m_smallerHalfMaxHeap.size() + m_largerHalfMinHeap.size());
    }

public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        // if the num store is empty
        if(!getStoredCnt()) {
            m_smallerHalfMaxHeap.push(num);
            return;
        }

        // if the num <= smaller part max
        if(num <= m_smallerHalfMaxHeap.top()) {

            // add new number to smaller half
            m_smallerHalfMaxHeap.push(num);

            // re-balance the elements stored in smaller half(n/2+1) and larget half(n/2)
            while( (m_smallerHalfMaxHeap.size() - m_largerHalfMinHeap.size()) > 1 ) {
                m_largerHalfMinHeap.push( m_smallerHalfMaxHeap.top() );
                m_smallerHalfMaxHeap.pop();
            }
        }
        // if the num > larger part min
        else {
            // add new number to larger half
            m_largerHalfMinHeap.push(num);

            // re-balance the elements stored in smaller half(n/2+1) and larget half(n/2)
            while( m_largerHalfMinHeap.size() > m_smallerHalfMaxHeap.size() ) {
                m_smallerHalfMaxHeap.push( m_largerHalfMinHeap.top() );
                m_largerHalfMinHeap.pop();
            }
        }
    }
    
    double findMedian() {
        // if there's no stored number at all
        // if( getStoredCnt() == 0 ) return 0;

        // even number of stored number
        if( (getStoredCnt() % 2) == 0) {
            return double(m_smallerHalfMaxHeap.top() + m_largerHalfMinHeap.top()) * 0.5;
        }
        // odd number of stored number
        else {
            return double(m_smallerHalfMaxHeap.top());
        }
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

# Answer：維持兩個 Heap 每次 add num 做更新
## V1：複習1st - 計算量比前面的少很多 + 精細速度優化 -> **做法比較不直觀，看不出來 single mid 放在哪個 Heap**
```Cpp
class MedianFinder {
private:
    // two heap
    // (max heap): [smallest to mid_l / mid] (include middle element)
    priority_queue<int, vector<int>, less<int>> m_maxHeapSmallerNum;

    // (min heap): [mid_r to biggest] (mid right element to end)
    priority_queue<int, vector<int>, greater<int>> m_minHeapLargerNum;

public:
    MedianFinder() {
    }
    
    void addNum(int num) {
        if(m_maxHeapSmallerNum.empty() || num < m_maxHeapSmallerNum.top()) {
            // push to left side
            m_maxHeapSmallerNum.push(num);

            // move one to right
            if(m_maxHeapSmallerNum.size() > (m_minHeapLargerNum.size() + 1)) {
                m_minHeapLargerNum.push( m_maxHeapSmallerNum.top() );
                m_maxHeapSmallerNum.pop();
            }
        }
        else {
            // push to right side
            m_minHeapLargerNum.push(num);

            // move one to left
            if(m_minHeapLargerNum.size() > m_maxHeapSmallerNum.size()) {
                m_maxHeapSmallerNum.push( m_minHeapLargerNum.top() );
                m_minHeapLargerNum.pop();
            }
        }
    }
    
    double findMedian() {
        if(m_maxHeapSmallerNum.size() != m_minHeapLargerNum.size()) {
            return m_maxHeapSmallerNum.top();
        }
        else {
            return 0.5*(m_maxHeapSmallerNum.top() + m_minHeapLargerNum.top());
        }
    }
};
```

## V2：複習2nd - 流程比較簡單，但條件判斷比較不精細，速度不是最佳 -> **能直覺看出 mid 放在哪個 heap，比較好**
```Cpp
class MedianFinder {
private:
    int m_numCnt;
    priority_queue<int, vector<int>, less<int>> m_MinHalfHeap;
    priority_queue<int, vector<int>, greater<int>> m_MaxHalfHeap;
public:
    MedianFinder() {
        m_numCnt = 0;
    }
    
    void addNum(int num) {
        // odd num of element -> old mid value in MinHalfHeap.top
        // -> new mid value = avg( two heaps.top )
        if(m_numCnt % 2) {
            // compare to old mid value
            m_MinHalfHeap.push(num);

            // transfer one number from minHalf -> maxHalf
            m_MaxHalfHeap.push( m_MinHalfHeap.top() );
            m_MinHalfHeap.pop();
        }
        // even num of element -> mid value = avg( two heaps.top )
        // -> new mid value = MinHalfHeap.top
        else {
            // compare to right-mid value (larger one)
            m_MaxHalfHeap.push(num);

            // transfer one number from maxHalf -> minHalf
            m_MinHalfHeap.push( m_MaxHalfHeap.top() );
            m_MaxHalfHeap.pop();
        }

        // update number count
        m_numCnt++;
    }
    
    double findMedian() {
        if(m_numCnt % 2) return m_MinHalfHeap.top();
        else return 0.5 * (m_MinHalfHeap.top() + m_MaxHalfHeap.top());
    }
};
```
