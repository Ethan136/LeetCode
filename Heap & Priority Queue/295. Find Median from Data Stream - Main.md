---
ParentTask:
  - "[[heap___priority_queue]]"
---

# LeetCode
[295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

# Concept
- 動態加入 num，隨時更新 middle value
- 使用兩個 heap：max heap / min heap
	- max heap 放小數字
	- min heap 放大數字
- 左：max heap（放 N/2 + 1 個 element，也就是包含中間值）
	- 如果 max heap 是空的 -> 第一個放進來的 element -> 放到 max heap
	- 如果 num < max heap.top() -> 有新的小值放到左邊 -> 放到 max heap
	- 如果放到 max heap 後，『左邊數量 > 右邊+1』 -> 左邊取出一個放到右邊
- 右：min heap（放 N/2 個 element，不包含中間值）
	- 如果 num > min heap.top() -> 有新的小值放到右邊 -> 放到 min heap
	- 如果放到 min heap 後，『右邊數量 > 左邊』 -> 右邊取出一個放到左邊

# Answer: double heap balance
```Cpp
class MedianFinder {
private:
    // store (n/2+1) smaller numbers
    priority_queue<int, vector<int>, less<int>> m_smallerHalfMaxHeap;

    // store (n/2) larget numbers
    priority_queue<int, vector<int>, greater<int>> m_largerHalfMinHeap;

    int getStoredCnt() {
        return (m_smallerHalfMaxHeap.size() + m_largerHalfMinHeap.size());
    }

public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        // if the num store is empty
        if(!getStoredCnt()) {
            m_smallerHalfMaxHeap.push(num);
            return;
        }

        // if the num <= smaller part max
        if(num <= m_smallerHalfMaxHeap.top()) {

            // add new number to smaller half
            m_smallerHalfMaxHeap.push(num);

            // re-balance the elements stored in smaller half(n/2+1) and larget half(n/2)
            while( (m_smallerHalfMaxHeap.size() - m_largerHalfMinHeap.size()) > 1 ) {
                m_largerHalfMinHeap.push( m_smallerHalfMaxHeap.top() );
                m_smallerHalfMaxHeap.pop();
            }
        }
        // if the num > larger part min
        else {
            // add new number to larger half
            m_largerHalfMinHeap.push(num);

            // re-balance the elements stored in smaller half(n/2+1) and larget half(n/2)
            while( m_largerHalfMinHeap.size() > m_smallerHalfMaxHeap.size() ) {
                m_smallerHalfMaxHeap.push( m_largerHalfMinHeap.top() );
                m_largerHalfMinHeap.pop();
            }
        }
    }
    
    double findMedian() {
        // if there's no stored number at all
        // if( getStoredCnt() == 0 ) return 0;

        // even number of stored number
        if( (getStoredCnt() % 2) == 0) {
            return double(m_smallerHalfMaxHeap.top() + m_largerHalfMinHeap.top()) * 0.5;
        }
        // odd number of stored number
        else {
            return double(m_smallerHalfMaxHeap.top());
        }
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```