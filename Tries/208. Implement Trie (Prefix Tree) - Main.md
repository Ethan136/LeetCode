# LeetCode
[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)

# Concept
- **雖然是 Tree 結構，但因為不用 trace back，所以其實類似 link list，可以用 iteration，而不需要 recursive**
- **NextNode 可以用 unordered_map 也可以用 array -> 使用 array 速度快很多**
- 除了建立 trie，還需要記錄「trie 途中是否有 recorded word end」 -> **insert word 的時候，要記得 word end flag 如果當下是 true，不能設為 false**
- Trie 結構
	- Root -> traverse to idx 0 -> traverse to idx1 -> traverse to idx2
	- **Root 本身類似 index -1**，但是 index 0 的 node 是在 traverse to root 的時候建立的 -> **這樣才能連 next node 過去**
		- **這個概念類似 link list 裡面的 「create node 的時候，要traverse 到前一個 node，連到 new create node」
- **traverse curNode 會比 index 超前 1 的特性**
	- 因為 root 其實是 first node index 0 的前一個 node
	-  -> **如果 root traverse 的時候，搭配 index 0 -》 則每一個 index 檢查的時候，必須是 curNode->next 才為實際的 index node**
	- -> search 的時候，如果在 root 的時候，是檢查 index 0 -> 則是檢查 「curNode 的 Next 是否為 word[idx]」，並且要 traverse
- 整理
	- **如果是 root 檢查 index 0 -> 則每次檢查都是 traverse curNode->next 對應 current index** -> 這樣比較直覺
		- 處理流程：先檢查有沒有 current index 所對應的 next -> 有：traverse to next node 檢查資訊 / 無：無法繼續走下去 return
	- **如果是 root 檢查 index -1 -> 則每次檢查都是 traverse curNode 對應 current index**


# Answer - Iteration + Array of Next Node (curNode->next 檢查 current index：採用這個)
## V1 - 第一次寫的版本 -> 比較簡潔
- **雖然是 Tree 結構，但因為不用 trace back，所以其實類似 link list，可以用 iteration，而不需要 recursive**
```Cpp
#define START_CHAR 'a'
#define END_CHAR 'z'
#define CHAR_MAP_SIZE (END_CHAR - START_CHAR + 1)
class Trie {
private:
    struct TrieNode {
        TrieNode* nextChar[CHAR_MAP_SIZE];
        bool wordEnd;
    };

    TrieNode m_rootNode;

public:
    Trie() {
        for(int i = 0; i < CHAR_MAP_SIZE; i++) m_rootNode.nextChar[i] = nullptr;
        m_rootNode.wordEnd = false;
    }
    
    void insert(string word) {
        // traverse from root node
        TrieNode* curNode = &m_rootNode;

        // create the trie of the whole word
        for(char c : word) {
            // shift the char to index
            c = c - START_CHAR;

            // if next node does not on the map -> next node does not exist -> create a new one
            if(!curNode->nextChar[c]) curNode->nextChar[c] = new TrieNode({});

            // traverse to next noe
            curNode = curNode->nextChar[c];
        }

        // set the end mark
        curNode->wordEnd = true;
    }
    
    bool search(string word) {
        // traverse from root node
        TrieNode* curNode = &m_rootNode;

        // traverse through the trie with the sequence of char in word
        for(char c : word) {
            // shift the char to index
            c = c - START_CHAR;

            // if this char does not exist in trie
            if(!curNode->nextChar[c]) return false;

            // traverse to next chart
            curNode = curNode->nextChar[c];
        }

        // return whether the current word with end mark
        return curNode->wordEnd;
    }
    
    bool startsWith(string prefix) {
        // traverse from root node
        TrieNode* curNode = &m_rootNode;

        // traverse through the trie with the sequence of char in word
        for(char c : prefix) {
            // shift the char to index
            c = c - START_CHAR;

            // if this char does not exist in trie
            if(!curNode->nextChar[c]) return false;

            // traverse to next chart
            curNode = curNode->nextChar[c];
        }

        // no need to check the end mark of the word
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
``` 


## V2 - 複習1st 時候寫的版本 - struct 資料結構裡面封裝函式（當作練習參考）
- **注意： 如果要使用 function 取得數值放在 "=" 左邊做指派 -> function 必須回傳 reference**
```Cpp
#define FIRST_CHAR  ('a')
#define LAST_CHAR   ('z')
#define CHAR_NUM    (LAST_CHAR - FIRST_CHAR + 1)
class Trie {
private:
    struct Node {
        Node *next[CHAR_NUM];
        char chr;
        bool endWord;

        Node() {
            resetAllVar();
        };

        Node(char setChar, bool setEndWord = false) {
            resetAllVar();
            chr = setChar;
            endWord = setEndWord;
        };

        void resetAllVar(void) {
            chr = '#';
            endWord = false;
            for(int i = 0; i < CHAR_NUM; i++) next[i] = nullptr;
        };

        Node*& getNextNodePtr(char targetChar) {
            return next[targetChar - FIRST_CHAR];
        };
    };

    Node *m_pRoot;

public:
    Trie() {
        m_pRoot = new Node();
    }
    
    void insert(string word) {
        Node *curNode = m_pRoot;
        for(char c : word) {
            // create new node if necessary
            if(!curNode->getNextNodePtr(c)) {
                curNode->getNextNodePtr(c) = new Node(c);
            }

            // traverse to next word
            curNode = curNode->getNextNodePtr(c);
        }

        // set end word (on the last node of this word)
        curNode->endWord = true;
    }
    
    bool search(string word) {
        Node *curNode = m_pRoot;
        for(char c : word) {
            if(!curNode->getNextNodePtr(c)) return false;
            curNode = curNode->getNextNodePtr(c);
        }
        return curNode->endWord;
    }
    
    bool startsWith(string prefix) {
        Node *curNode = m_pRoot;
        for(char c : prefix) {
            if(!curNode->getNextNodePtr(c)) return false;
            curNode = curNode->getNextNodePtr(c);
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```


# Answer - Recursive + Array of Next Node (curNode->next 檢查 current index，寫法複雜不推薦）
- 寫法比較複雜
- 而且速度慢很多
```Cpp
#define FIRST_CHAR  ('a')
#define LAST_CHAR   ('z')
#define CHAR_NUM    (LAST_CHAR - FIRST_CHAR + 1)
class Trie {
private:
    struct Node {
        Node *next[CHAR_NUM];
        char chr;
        bool endWord;

        Node() {
            resetAllVar();
        };

        Node(char setChar, bool setEndWord = false) {
            resetAllVar();
            chr = setChar;
            endWord = setEndWord;
        };

        void resetAllVar(void) {
            chr = '#';
            endWord = false;
            for(int i = 0; i < CHAR_NUM; i++) next[i] = nullptr;
        };

        Node*& getNextNodePtr(char targetChar) {
            return next[targetChar - FIRST_CHAR];
        };
    };

    Node *m_pRoot;

private:
    void insert(string &word, int insertIdx, Node *curNode) {
        if((insertIdx >= word.size()) || !curNode) return;

        char setChar = word[insertIdx];
        bool setEndWord = ( insertIdx == (word.size()-1) );

        Node *pNextNode;
        if(!curNode->getNextNodePtr(setChar)) {
            pNextNode = new Node(setChar, setEndWord);
            curNode->getNextNodePtr(setChar) = pNextNode;
        }
        else {
            pNextNode = curNode->getNextNodePtr(setChar);
            pNextNode->endWord = (pNextNode->endWord || setEndWord);
        }

        insert(word, insertIdx+1, pNextNode);
    }

    bool search(string &word, int searchIdx, Node *curNode) {
        if(!curNode) return false;
        if(searchIdx == word.size()) return (curNode->endWord);

        Node *pNextNode = curNode->getNextNodePtr(word[searchIdx]);
        return search(word, searchIdx+1, pNextNode);
    }

    bool startWith(string &word, int searchIdx, Node *curNode) {
        if(!curNode) return false;
        if(searchIdx == word.size()) return true;

        Node *pNextNode = curNode->getNextNodePtr(word[searchIdx]);
        return startWith(word, searchIdx+1, pNextNode);
    }
public:
    Trie() {
        m_pRoot = new Node();
    }
    
    void insert(string word) {
        insert(word, 0, m_pRoot);
    }
    
    bool search(string word) {
        return search(word, 0, m_pRoot);
    }
    
    bool startsWith(string prefix) {
        return startWith(prefix, 0, m_pRoot);
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

# Answer：複習2nd - 模板化寫法
## Recursive
```Cpp
class Trie {
private:
    struct Node {
        Node* nextNodes[26] = {};
        bool endWord = false;
    };

    Node m_root;

private:
    void travAndAddWord(Node *node, string &word, int idx) {
        // not expected to be here
        if(!node) return;

        // idx out of range
        if( (idx < 0) || (idx >= word.size()) ) {
            return;
        }

        // create node of word[i] in next word
        Node* &nodeOfCharIdx = node->nextNodes[word[idx] - 'a'];
        if(!nodeOfCharIdx) nodeOfCharIdx = new Node();

        // set end word flag
        if(idx == (word.size() - 1)) {
            nodeOfCharIdx->endWord = true;
        }

        // traverse to word[i+1]
        travAndAddWord(nodeOfCharIdx, word, idx+1);
    }

    bool travAndSearchWord(Node *node, string &word, int idx) {
        // not expected to be here
        if(!node) return false;

        // idx out of range
        if( (idx < 0) || (idx >= word.size()) ) {
            return false;
        }

        // search if word[i] is in next nodes
        Node* nodeOfCharIdx = node->nextNodes[word[idx] - 'a'];
        if(!nodeOfCharIdx) return false;

        // if current idx is word end char
        if(idx == (word.size() - 1)) {
            return nodeOfCharIdx->endWord;
        }

        // traverse to word[i+1]
        return travAndSearchWord(nodeOfCharIdx, word, idx+1);
    }

    bool travAndSearchPrefix(Node *node, string &preFix, int idx) {
        // not expected to be here
        if(!node) return false;

        // idx out of range
        if( (idx < 0) || (idx >= preFix.size()) ) {
            return false;
        }

        // search if preFix[i] is in next nodes
        Node* nodeOfCharIdx = node->nextNodes[preFix[idx] - 'a'];
        if(!nodeOfCharIdx) return false;

        // if current idx is prefix end char
        if(idx == (preFix.size() - 1)) {
            return true;
        }

        // traverse to preFix[i+1]
        return travAndSearchPrefix(nodeOfCharIdx, preFix, idx+1);
    }


public:
    Trie() {
        
    }
    
    void insert(string word) {
        travAndAddWord(&m_root, word, 0);
    }
    
    bool search(string word) {
        return travAndSearchWord(&m_root, word, 0);
    }
    
    bool startsWith(string prefix) {
        return travAndSearchPrefix(&m_root, prefix, 0);
    }
};

```


## Iteration
```Cpp
class Trie {
private:
    struct Node {
        Node* nextNodes[26] = {};
        bool endWord = false;
    };

    Node m_root;

private:
    Node* travAndCreateNode(Node *node, string &word, int idx) {
        // not expected to be here
        if(!node) return nullptr;

        // word finish
        if(idx >= word.size()) {
            return nullptr;
        }

        // create node of word[i] in next word
        Node* &nodeOfCharIdx = node->nextNodes[word[idx] - 'a'];
        if(!nodeOfCharIdx) nodeOfCharIdx = new Node();

        // set end word if current index is the last one
        if(idx == (word.size() - 1)) {
            nodeOfCharIdx->endWord = true;
        }

        // traverse to word[i+1]
        return nodeOfCharIdx;
    }

    Node* travAndFindNextNode(Node *node, string &word, int idx) {
        // not expected to be here
        if(!node) return nullptr;

        // word finish
        if(idx >= word.size()) {
            return nullptr;
        }

        // search if word[i] is in next nodes
        Node* nodeOfCharIdx = node->nextNodes[word[idx] - 'a'];

        // traverse to word[i+1]
        return nodeOfCharIdx;
    }


public:
    Trie() {
        
    }
    
    void insert(string word) {
        Node* node = &m_root;
        for(int i = 0; i < word.size(); i++) {
            node = travAndCreateNode(node, word, i);
        }
    }
    
    bool search(string word) {
        Node* node = &m_root;
        for(int i = 0; i < word.size(); i++) {
            node = travAndFindNextNode(node, word, i);
            if(!node) return false;
        }
        return node->endWord;
    }
    
    bool startsWith(string prefix) {
        Node* node = &m_root;
        for(int i = 0; i < prefix.size(); i++) {
            node = travAndFindNextNode(node, prefix, i);
            if(!node) return false;
        }
        return true;
    }
};
```