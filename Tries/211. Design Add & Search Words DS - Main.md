# LeetCode
[211. Design Add & Search Words DS](https://leetcode.com/problems/design-add-search-words-ds/)

# Concept
- 有 '.' 任意字元 match -> 需要試錯 -> **recursive 或是 stack 儲存 trace back 資訊**
- 為了加速，可以在「沒有 '.' 的時候，先用 iteration」並且在「遇到 '.' 的時候，再用 recursive」

# Answer：Iteration + DFS + Trie -> 寫法複雜，不建議
```Cpp
#define START_CHAR 'a'
#define END_CHAR 'z'
#define CHAR_MAP_SIZE (END_CHAR - START_CHAR + 1)

#define DOT_CHAR_MATCH_ANY  '.'

class WordDictionary {
private:
    struct TrieNode {
        TrieNode* nextChar[CHAR_MAP_SIZE];
        bool endWord;

        TrieNode() {
            for(int i = 0; i < CHAR_MAP_SIZE; i++) nextChar[i] = nullptr;
            endWord = false;
        }
    };

    struct tPendingCheckInfo {
        int charIdx;
        TrieNode *node;
    };

    TrieNode m_entryNode;

public:
    WordDictionary() {
        
    }
    
    void addWord(string word) {
        TrieNode *curNode = &m_entryNode;
        for(auto c : word) {

            // convert char to index
            int idx = c - START_CHAR;
            
            // create new node if the next one does not exist
            if(!curNode->nextChar[idx]) curNode->nextChar[idx] = new TrieNode();

            // traverse to the next node
            curNode = curNode->nextChar[idx];
        }
        curNode->endWord = true;
    }
    
    bool search(string word) {
        // if the word is empty
        if(word.empty()) return true;

        // use a stack to record the conditions needing to be checked later
        stack<tPendingCheckInfo> pendingCheckInfo;
        pendingCheckInfo.push({.charIdx = 0, .node = &m_entryNode});

        // traverse through the trie
        TrieNode* curNode;
        while(!pendingCheckInfo.empty()) {

            // get the check info from stack top
            curNode = pendingCheckInfo.top().node;
            int charIdx = pendingCheckInfo.top().charIdx;

            // pop out the check info after fetch from stack
            pendingCheckInfo.pop();

            // Cond0: if check index reaches the end of the world
            if(charIdx == word.size()) {
                // (a) if match end mark
                if(curNode->endWord) return true;

                // (b) if not match end mark -> check next pending info
                continue;
            }

            // Cond1: if the check char is one-to-one
            char checkChar = word[charIdx];
            if(checkChar != DOT_CHAR_MATCH_ANY) {
                TrieNode* nextNode = curNode->nextChar[ checkChar - START_CHAR ];
                if(nextNode) pendingCheckInfo.push({.charIdx = (charIdx+1), .node = nextNode});
                continue;
            }

            // Cond2: if the check char is "any"
            for(int i = 0; i < CHAR_MAP_SIZE; i++) {
                TrieNode* nextNode = curNode->nextChar[i];
                if(nextNode) pendingCheckInfo.push({.charIdx = (charIdx+1), .node = nextNode});
            }
        }

        // for the condition that the trasverse finish before checking the end of the word
        return false;
    }
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary* obj = new WordDictionary();
 * obj->addWord(word);
 * bool param_2 = obj->search(word);
 */
``` 


# Answer：Full Recursive + DFS + Trie
- **不論是否為 '.' 都一律使用 recursive**

## V1 - 第一次寫的
```Cpp
#define START_CHAR 'a'
#define END_CHAR 'z'
#define CHAR_MAP_SIZE (END_CHAR - START_CHAR + 1)

#define DOT_CHAR_MATCH_ANY  '.'

class WordDictionary {
private:
    struct TrieNode {
        TrieNode* nextChar[CHAR_MAP_SIZE];
        bool endWord;

        TrieNode() {
            for(int i = 0; i < CHAR_MAP_SIZE; i++) nextChar[i] = nullptr;
            endWord = false;
        }
    };

    TrieNode m_entryNode;

private:
    bool searchFromIdx(string& word, int charIdx, TrieNode* curNode) {
        // Check whether current node is valid
        if(!curNode) return false;

        // Cond0: if check index reaches the end of the world
        if(charIdx == word.size()) {
            return curNode->endWord;
        }

        // Cond1: if the check char is one-to-one
        char checkChar = word[charIdx];
        if(checkChar != DOT_CHAR_MATCH_ANY) {
            TrieNode* nextNode = curNode->nextChar[ checkChar - START_CHAR ];
            return searchFromIdx(word, charIdx+1, nextNode);
        }

        // Cond2: if the check char is "any"
        for(int i = 0; i < CHAR_MAP_SIZE; i++) {
            TrieNode* nextNode = curNode->nextChar[i];
            if(searchFromIdx(word, charIdx+1, nextNode)) return true;
        }
        return false;
    }

public:
    WordDictionary() {
        
    }
    
    void addWord(string word) {
        TrieNode *curNode = &m_entryNode;
        for(auto c : word) {

            // convert char to index
            int idx = c - START_CHAR;
            
            // create new node if the next one does not exist
            if(!curNode->nextChar[idx]) curNode->nextChar[idx] = new TrieNode();

            // traverse to the next node
            curNode = curNode->nextChar[idx];
        }
        curNode->endWord = true;
    }
    
    bool search(string word) {

        return searchFromIdx(word, 0, &m_entryNode);
    }
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary* obj = new WordDictionary();
 * obj->addWord(word);
 * bool param_2 = obj->search(word);
 */
```


## V2 - 複習時候寫的 ->採用這個
- **順便練習 designate initializer**
```Cpp
#define CHAR_NUM    ('z' - 'a' + 1)
class WordDictionary {
private:
    struct Node {
        Node *next[CHAR_NUM] = {};
        char setChar = '#';
        bool endWord = false;
    };

    Node *m_pRoot;

    bool search(string &word, int idx, Node *curNode) {
        // check if node exist
        if(!curNode) return false;

        // if reach word end
        if(idx >= word.size()) return curNode->endWord;

        // non-special char -> search specific next node
        if(word[idx] != '.') {
            if(!curNode->next[ word[idx] - 'a' ]) return false;
            return search(word, idx+1, curNode->next[ word[idx] - 'a' ]);
        }

        // special char -> try all next nodes
        for(int i = 0; i < CHAR_NUM; i++) {
            if(!curNode->next[i]) continue;
            if(search(word, idx+1, curNode->next[i])) return true;
        }
        return false;
    }

public:
    WordDictionary() {
        m_pRoot = new Node();
    }
    
    void addWord(string word) {
        Node *curNode = m_pRoot;
        for(char c : word) {
            // index of next node
            int charIdx = c - 'a';

            // create new node if necessary
            if(!curNode->next[charIdx]) curNode->next[charIdx] = new Node({.setChar = c});

            // traerse to next node
            curNode = curNode->next[charIdx];
        }
        curNode->endWord = true;
    }
    
    bool search(string word) {
        return search(word, 0, m_pRoot);
    }
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary* obj = new WordDictionary();
 * obj->addWord(word);
 * bool param_2 = obj->search(word);
 */
```


# Answer：Recursive-Iteration Hybrid + DFS + Trie
## V1 - 寫的比較複雜，但概念一樣
```Cpp
#define START_CHAR 'a'
#define END_CHAR 'z'
#define CHAR_MAP_SIZE (END_CHAR - START_CHAR + 1)

#define DOT_CHAR_MATCH_ANY  '.'

class WordDictionary {
private:
    struct TrieNode {
        TrieNode* nextChar[CHAR_MAP_SIZE];
        bool endWord;

        TrieNode() {
            for(int i = 0; i < CHAR_MAP_SIZE; i++) nextChar[i] = nullptr;
            endWord = false;
        }
    };

    TrieNode m_entryNode;

private:
    bool searchFromIdx(string& word, int charIdx, TrieNode* curNode) {
        // Check whether current node is valid
        if(!curNode) return false;

        // Cond0: if check index reaches the end of the world
        if(charIdx == word.size()) {
            return curNode->endWord;
        }

        // Cond1: if the check char is one-to-one
        while(word[charIdx] != DOT_CHAR_MATCH_ANY) {
            // check char match
            TrieNode* nextNode = curNode->nextChar[ word[charIdx] - START_CHAR ];
            if(!nextNode) return false;

            // traverse to next char
            curNode = nextNode;
            charIdx++;

            // check if reach the end of the word
            if(charIdx == word.size()) return curNode->endWord;
        }

        // Cond2: if the check char is "any"
        for(int i = 0; i < CHAR_MAP_SIZE; i++) {
            TrieNode* nextNode = curNode->nextChar[i];
            if(searchFromIdx(word, charIdx+1, nextNode)) return true;
        }
        return false;
    }

public:
    WordDictionary() {
        
    }
    
    void addWord(string word) {
        TrieNode *curNode = &m_entryNode;
        for(auto c : word) {

            // convert char to index
            int idx = c - START_CHAR;
            
            // create new node if the next one does not exist
            if(!curNode->nextChar[idx]) curNode->nextChar[idx] = new TrieNode();

            // traverse to the next node
            curNode = curNode->nextChar[idx];
        }
        curNode->endWord = true;
    }
    
    bool search(string word) {

        return searchFromIdx(word, 0, &m_entryNode);
    }
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary* obj = new WordDictionary();
 * obj->addWord(word);
 * bool param_2 = obj->search(word);
 */
```


## V2 - 寫的比較簡潔 -> 採用這個
```Cpp
#define CHAR_NUM    ('z' - 'a' + 1)
class WordDictionary {
private:
    struct Node {
        Node *next[CHAR_NUM] = {};
        char setChar = '#';
        bool endWord = false;
    };

    Node *m_pRoot;

    bool search(string &word, int idx, Node *curNode) {
        // check if node exist
        if(!curNode) return false;

        // if word end is reached
        if(idx >= word.size()) return curNode->endWord;

        // non-special char -> keep search next specific char
        for(; (idx < word.size()) && (word[idx] != '.'); idx++) {
            if(!curNode->next[ word[idx] - 'a' ]) return false;
            curNode = curNode->next[ word[idx] - 'a' ];

            if(idx == (word.size() - 1)) return curNode->endWord;
        }

        // special char -> try all next nodes
        for(int i = 0; i < CHAR_NUM; i++) {
            if(!curNode->next[i]) continue;
            if(search(word, idx+1, curNode->next[i])) return true;
        }
        return false;
    }

public:
    WordDictionary() {
        m_pRoot = new Node();
    }
    
    void addWord(string word) {
        Node *curNode = m_pRoot;
        for(char c : word) {
            // index of next node
            int charIdx = c - 'a';

            // create new node if necessary
            if(!curNode->next[charIdx]) curNode->next[charIdx] = new Node({.setChar = c});

            // traerse to next node
            curNode = curNode->next[charIdx];
        }
        curNode->endWord = true;
    }
    
    bool search(string word) {
        return search(word, 0, m_pRoot);
    }
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary* obj = new WordDictionary();
 * obj->addWord(word);
 * bool param_2 = obj->search(word);
 */
```