# LeetCode
[212. Word Search II](https://leetcode.com/problems/word-search-ii/)

# Concept
- 走棋盤的時候，看能不能一次檢查多個「前綴相同的字串」 -> 把 word 濃縮成 Trie
	- 棋盤 size 有限制 -> word 太長的時候，可以不加入 trie
	- 最終結果是要記錄「棋盤上有的 word」 -> Trie 的 endWord flag 可以改成 word idx 
		- -> **這樣在走棋盤的時候，就不需要額外一個變數記錄當下 check pass 的暫態字串，而是可以直接走到 word end 的時候，依據 word idx 從原始的 words[ word idx ] 取得 check pass 的完整字串
		- **這個做法效能好很多**
	- **棋盤走過的地方要把上面字元改掉，避免來回走，並且 track back 退回的時候再還原字元**
	- Trie 是「word[i] 存在的時候， curNode->next[ word[i] ] 存在 -> 也就是當前的 char word[i] 是用 nextNode[ word[i] ] 來檢查的
		- **走棋盤的時候，就是把 board[row][col] 的字元，丟到 trie 裡面檢查有沒有 next node**
- 棋盤不需要特別作 trie -> 因為棋盤在走的時候，一定是照某個順序走，不可能說一次檢查好幾條路線
- **為了避免已經 check pass 加入 result 的 word 重複檢查到 -> traverse trie to endWord 的時候，要把 endWord 的 flag / word store idx 改為 invalid**

# Answer：使用額外 string 記錄走棋盤途中的 check pass subWord -> 效能較差
## 注意
- 預先配置 string size 避免 push_back 的時候動態配置記憶體 + 搬動的方式有兩個
- （1）一開始宣告一個很長的 string(max_word_length, '#') + length indicator 變數
	- **string 宣告某個長度，必須是 string( length , '某個char' ) -> **不能像是 vector 那樣只指定 size，必須也指定 char**
- （2）使用 string.reserve(max_word_length)

## V1：預配置 string 某個長度 + 搭配 length indicator
```Cpp

#define INVALID_CHAR ('#')
class Solution {
private:
    struct Node {
        Node* next['z'-'a'+1] = {};
        //char setChar = INVALID_CHAR;
        bool endWord = false;
    };

    Node* buildWordsToTrie(auto& words, int maxStoreWordLen, int &trieDepth) {
        Node *pRoot = new Node();

        trieDepth = 0;
        for(auto &word : words) {

            if(word.size() > maxStoreWordLen) continue;

            Node *curNode = pRoot;
            for(char c : word) {
                Node *&nextNode = curNode->next[c - 'a'];
                if(!nextNode) nextNode = new Node();

                curNode = nextNode;
            }
            curNode->endWord = true;

            if(trieDepth < word.size()) trieDepth = word.size();
        }

        return pRoot;
    };
    
    void checkTrieWordsOnBoard(auto &board, int row, int col, 
                               Node* curNode, string &subWordStr, int subWordLen, 
                               auto &wordsOnBoard) {
        if(row < 0 || row >= board.size()) return;
        if(col < 0 || col >= board[row].size()) return;
        if(board[row][col] == INVALID_CHAR) return;

        char c = board[row][col];
        Node *nextNode = curNode->next[c - 'a'];
        if(!nextNode) return;

        board[row][col] = INVALID_CHAR;

        subWordStr[subWordLen++] = c;

        if(nextNode->endWord) {
            // stor the matched word to result
            wordsOnBoard.push_back(subWordStr.substr(0, subWordLen));

            // take out the matched word from trie
            // TO PREVENT DUPLICATED RESULT ON SET
            nextNode->endWord = false;
        }

        checkTrieWordsOnBoard(board, row+1, col, nextNode, subWordStr, subWordLen, wordsOnBoard);

        checkTrieWordsOnBoard(board, row-1, col, nextNode, subWordStr, subWordLen, wordsOnBoard);

        checkTrieWordsOnBoard(board, row, col+1, nextNode, subWordStr, subWordLen, wordsOnBoard);

        checkTrieWordsOnBoard(board, row, col-1, nextNode, subWordStr, subWordLen, wordsOnBoard);

        subWordLen--;

        board[row][col] = c;
    }
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        int wordMaxLen = 0;
        int maxStoreWordLen = board.size() * board[0].size();
        Node *pRoot = buildWordsToTrie(words, maxStoreWordLen, wordMaxLen);

        int subWordLen = 0;
        string subWordStr(wordMaxLen, INVALID_CHAR);

        vector<string> wordsOnBoard;
        for(int row = 0; row < board.size(); row++) {
            for(int col = 0; col < board[row].size(); col++) {
                checkTrieWordsOnBoard(board, row, col, pRoot, subWordStr, subWordLen, wordsOnBoard);
            }
        }

        return wordsOnBoard;
    }
};
```

## V2：預配置 string 使用 reserve（不需要 length indicator）
```Cpp

#define INVALID_CHAR ('#')
class Solution {
private:
    struct Node {
        Node* next['z'-'a'+1] = {};
        //char setChar = INVALID_CHAR;
        bool endWord = false;
    };

    Node* buildWordsToTrie(auto& words, int maxStoreWordLen, int &trieDepth) {
        Node *pRoot = new Node();

        trieDepth = 0;
        for(auto &word : words) {

            if(word.size() > maxStoreWordLen) continue;

            Node *curNode = pRoot;
            for(char c : word) {
                Node *&nextNode = curNode->next[c - 'a'];
                if(!nextNode) nextNode = new Node();

                curNode = nextNode;
            }
            curNode->endWord = true;

            if(trieDepth < word.size()) trieDepth = word.size();
        }

        return pRoot;
    };
    
    void checkTrieWordsOnBoard(auto &board, int row, int col, 
                               Node* curNode, string &subWordStr, auto &wordsOnBoard) {
        if(row < 0 || row >= board.size()) return;
        if(col < 0 || col >= board[row].size()) return;
        if(board[row][col] == INVALID_CHAR) return;

        char c = board[row][col];
        Node *nextNode = curNode->next[c - 'a'];
        if(!nextNode) return;

        board[row][col] = INVALID_CHAR;

        subWordStr.push_back(c);

        if(nextNode->endWord) {
            // stor the matched word to result
            wordsOnBoard.push_back(subWordStr);

            // take out the matched word from trie
            // TO PREVENT DUPLICATED RESULT ON SET
            nextNode->endWord = false;
        }

        checkTrieWordsOnBoard(board, row+1, col, nextNode, subWordStr, wordsOnBoard);

        checkTrieWordsOnBoard(board, row-1, col, nextNode, subWordStr, wordsOnBoard);

        checkTrieWordsOnBoard(board, row, col+1, nextNode, subWordStr, wordsOnBoard);

        checkTrieWordsOnBoard(board, row, col-1, nextNode, subWordStr, wordsOnBoard);

        subWordStr.pop_back();

        board[row][col] = c;
    }
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        int wordMaxLen = 0;
        int maxStoreWordLen = board.size() * board[0].size();
        Node *pRoot = buildWordsToTrie(words, maxStoreWordLen, wordMaxLen);

        string subWordStr = "";
        subWordStr.reserve(wordMaxLen);

        vector<string> wordsOnBoard;
        for(int row = 0; row < board.size(); row++) {
            for(int col = 0; col < board[row].size(); col++) {
                checkTrieWordsOnBoard(board, row, col, pRoot, subWordStr, wordsOnBoard);
            }
        }

        return wordsOnBoard;
    }
};
```


# Answer：trie 的 wordEnd Flag 改成用 words 裡面對應的 store index 來記錄 -> 效能最好
## 注意
- 要看是不是 endWord -> 如果 wordStoreIdx 不為 invalid (-1) -> *代表 word end*

## V1：第一次寫的 + 沒有針對 word length 和 board max grid num 做優化
```Cpp
#define DEBUG (0)
#define CHAR_FOR_USED_POS_ON_BOARD  '#'
#define START_CHAR  'a'
#define LAST_CHAR   'z'
#define CHAR_NUM    (LAST_CHAR - START_CHAR + 1)
class Solution {
private:
    struct TrieNode {
        TrieNode* childNode[CHAR_NUM] = {};
        int wordStoreIdx = -1;
    };

    void insertWordToTrie(vector<string>& words, int checkWordIdx, TrieNode* root) {
        // if the root node is empty
        if(!root) return;

        // insert word to trie
        TrieNode* curNode = root;
        for(char c : words[checkWordIdx]) {
            TrieNode*& refNextNode = curNode->childNode[c - START_CHAR];
            if(!refNextNode) refNextNode = new TrieNode();
            curNode = refNextNode;
        }

        // set end word mark
        curNode->wordStoreIdx = checkWordIdx;
    }
    
    TrieNode* buildWordsToTrie(vector<string>& words) {

        // create root node
        TrieNode* root = new TrieNode();

        // add words to trie
        for(auto i=0; i<words.size(); i++) {
            insertWordToTrie(words, i, root);
        }

        // return root node
        return root;
    }


    void checkWordsOnBoard( vector<vector<char>>& board, int row, int col, 
                            vector<string>& words, TrieNode* node, 
                            vector<string> &matchWord) {

        // if the trie nodes is invalid
        if(!node) return;

        // if the check position out of the board
        if(row < 0 || row >= board.size()) return;
        if(col < 0 || col >= board[0].size()) return;

        // if the check position had been used -> the char on board had been modified to "out of range"
        char charOnPosition = board[row][col];
        if(charOnPosition == CHAR_FOR_USED_POS_ON_BOARD) return;

        // do traverse to check if the assigned position on the board matches the trie node
        node = node->childNode[ charOnPosition - START_CHAR ];
        if(!node) return;

        // if the trie node is the end of a word
        if(node->wordStoreIdx >= 0) {
            // add current word to result vector
            matchWord.push_back(words[ node->wordStoreIdx ]);
            
            // set the wordIdx within the word to invalid to prevent finding the same word again
            node->wordStoreIdx = -1;
        }

        // set the traversed position to invalid char
        board[row][col] = CHAR_FOR_USED_POS_ON_BOARD;

        // check if the adjacent word on board matches any word within the trie
        checkWordsOnBoard(board, row+1, col  , words, node, matchWord);
        checkWordsOnBoard(board, row-1, col  , words, node, matchWord);
        checkWordsOnBoard(board, row  , col+1, words, node, matchWord);
        checkWordsOnBoard(board, row  , col-1, words, node, matchWord);

        // reset the traversed position mark after check
        board[row][col] = charOnPosition;
    }

public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        // build words into trie
        TrieNode* wordsTrieRoot = buildWordsToTrie(words);

        // check trie on board
        vector<string> matchWord;
        for(int row = 0; row < board.size(); row++) {
            for(int col = 0; col < board[0].size(); col++) {
                checkWordsOnBoard(board, row, col, words, wordsTrieRoot, matchWord);
            }
        }
        return matchWord;
    }
};
```


## V2：複習時候寫的 + 有針對 word length > board grid num 的情況做優化
```Cpp

#define INVALID_CHAR ('#')
#define INVALID_IDX (-1)
class Solution {
private:
    struct Node {
        Node* next['z'-'a'+1] = {};
        int wordStoreIdx = INVALID_IDX;
    };

    Node* buildWordsToTrie(auto& words, int maxStoreWordLen) {
        Node *pRoot = new Node();

        for(int i = 0; i < words.size(); i++) {

            string &word = words[i];
            if(word.size() > maxStoreWordLen) continue;

            Node *curNode = pRoot;
            for(char c : words[i]) {
                Node *&nextNode = curNode->next[c - 'a'];
                if(!nextNode) nextNode = new Node();
                curNode = nextNode;
            }
            curNode->wordStoreIdx = i;
        }

        return pRoot;
    };
    
    void checkTrieWordsOnBoard(auto &board, int row, int col, auto &words, 
                               Node* curNode, auto &wordsOnBoard) {

        // if row / col is out of range
        if(row < 0 || row >= board.size()) return;
        if(col < 0 || col >= board[row].size()) return;

        // if row / col had been traversed
        if(board[row][col] == INVALID_CHAR) return;

        // backup char on board & check whether this word is on the trie
        char c = board[row][col];
        Node *nextNode = curNode->next[c - 'a'];
        if(!nextNode) return;
        
        // if current board match the word-end on the trie
        if(nextNode->wordStoreIdx != INVALID_IDX) {
            // stor the matched word to result
            wordsOnBoard.push_back(words[ nextNode->wordStoreIdx ]);

            // take out the matched word from trie
            // TO PREVENT DUPLICATED RESULT ON SET
            nextNode->wordStoreIdx = INVALID_IDX;
        }

        // traverse on position -> mark board char
        board[row][col] = INVALID_CHAR;

        // traverse to the adjacent boards
        checkTrieWordsOnBoard(board, row+1, col, words, nextNode, wordsOnBoard);
        checkTrieWordsOnBoard(board, row-1, col, words, nextNode, wordsOnBoard);
        checkTrieWordsOnBoard(board, row, col+1, words, nextNode, wordsOnBoard);
        checkTrieWordsOnBoard(board, row, col-1, words, nextNode, wordsOnBoard);

        // traverse back -> restore board char
        board[row][col] = c;
    }
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {

        int maxStoreWordLen = board.size() * board[0].size();
        Node *pRoot = buildWordsToTrie(words, maxStoreWordLen);

        vector<string> wordsOnBoard;
        for(int row = 0; row < board.size(); row++) {
            for(int col = 0; col < board[row].size(); col++) {
                checkTrieWordsOnBoard(board, row, col, words, pRoot, wordsOnBoard);
            }
        }

        return wordsOnBoard;
    }
};
```


# Answer：複習2nd - Backtracking + Trie 模板寫法
```Cpp
#define MARK_TRAV_CHAR  ('#')
class Solution {
private:
    struct Node {
        Node *nextNode[26];
        bool endWord;
    };

private:
    void travAndCreateNode(Node *pRoot, auto &word) {
        if(!pRoot) return;

        Node *node = pRoot;
        for(int i = 0; i < word.size(); i++) {
            Node* &nodeOfChar = node->nextNode[ word[i] - 'a' ];
            if(!nodeOfChar) nodeOfChar = new Node();
            node = nodeOfChar;
        }
        node->endWord = true;
    }

    Node* buildTrieOfWords(auto &words) {
        Node *pRoot = new Node();
        for(auto &word : words) {
            travAndCreateNode(pRoot, word);
        }
        return pRoot;
    }

    void travAndFindWords(auto &board, int row, int col,
                        Node *node, auto &curTravWord, auto &wordsOnBoard) {
        // invalid position
        if( (row < 0) || (row >= board.size()) ) return;
        if( (col < 0) || (col >= board[row].size()) ) return;

        // if the board had been traversed
        if(board[row][col] == MARK_TRAV_CHAR) return;

        // if the char on board does not exist on trie
        char toChar = board[row][col];
        if(!node->nextNode[ toChar - 'a' ]) return;

        // mark board traversed
        board[row][col] = MARK_TRAV_CHAR;

        // traverse along the trie
        Node *nodeOfChar = node->nextNode[ toChar - 'a' ];

        // record the trav path on trie
        curTravWord.push_back(toChar);
        
        // if traverse to end word
        // (1) record the word
        // (2) clear endword flag incase record duplicate words
        if(nodeOfChar->endWord) {
            wordsOnBoard.push_back(curTravWord);
            nodeOfChar->endWord = false;
        }
        
        // traverse to boards besides
        int dir[4][2] = {{1,0}, {-1, 0}, {0, 1}, {0, -1}};
        for(int i = 0; i < 4; i++) {
            travAndFindWords(board, row + dir[i][0], col + dir[i][1], 
                            nodeOfChar, curTravWord, wordsOnBoard);
        }

        // pop out the traversed path
        curTravWord.pop_back();

        // recover char on board
        board[row][col] = toChar;
    }
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        Node *pRoot = buildTrieOfWords(words);

        string curTravWord;
        vector<string> wordsOnBoard; wordsOnBoard.reserve(words.size());

        for(int row = 0; row < board.size(); row++) {
            for(int col = 0; col < board[row].size(); col++) {
                travAndFindWords(board, row, col,
                                pRoot, curTravWord, wordsOnBoard);
            }
        }
        return wordsOnBoard;
    }
};
```