---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

# Concept
- **Dijkstra 可以搭配一個類似 DP 的 memo，來記錄『更新的內容』，是否可以讓 cost 更符合預期方向
	- push 前更新 memo 數值 + 比對情況不把會變差的推進去 -> 最能減少分支
	- pop 後檢查當前處理的 case 並且比對 memo -> 分支比較多（因為有可能在 push 的時候多推了好幾個可以過濾掉的情況進去）
- **上面這個 memo 依照情況，可能是 1D vector，也可能是 2D vector -> 這題是 2D Vector 的情況**

# Answer：Brute Force DFS
```Cpp
typedef vector<int> vec_int;
#define INVALID_COST    (-1)
class Solution {
private:
    int minCostFromSrcToDst(auto &flightMap, int src, int dst, int remainFlightCnt) {
        if(remainFlightCnt < 0) return INVALID_COST;
        if(src == dst) return 0;

        int minCost = INVALID_COST;
        for(auto pFlight : flightMap[src]) {

            int toPlace = (*pFlight)[1];
            int toPlaceCost = (*pFlight)[2];
            
            // check the ticket had been used & record ticket used by set price as invalid
            if(toPlaceCost == INVALID_COST) continue;
            (*pFlight)[2] = INVALID_COST;

            // calculate cost of next flight & restore ticket price
            int costAfterToPlace = minCostFromSrcToDst(flightMap, toPlace, dst, remainFlightCnt-1);
            (*pFlight)[2] = toPlaceCost;

            // check if the cost is valid & calculate total cost of path
            if(costAfterToPlace == INVALID_COST) continue;
            int costToDst = toPlaceCost + costAfterToPlace;

            // update minimal cost
            minCost = (minCost == INVALID_COST) ? (costToDst) : (min(minCost, costToDst));
        }

        return minCost;
    }
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        unordered_map<int, vector<vec_int*>> flightMap;
        for(auto &flight : flights) flightMap[ flight[0] ].push_back( &flight );

        int maxFlightCnt = k + 1;
        return minCostFromSrcToDst(flightMap, src, dst, maxFlightCnt );
    }
};
```


# Answer：Dijkstra

## V1：Update MinCostCond To Trim Branch After Pop New Cond (後剪枝)
```Cpp
#define INVALID_FLIGHT_COST (INT_MAX)
#define STOP_NUM_OF_START_POINT (-1)
class Solution {
private:
    struct flightInfo {
        int toIdx;
        int totalCost;
        int totalStopNum;
    };

    struct flightCost {
        int dest;
        int flightCost;
    };

public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {

        vector<vector<flightCost>> flightCostMap(n);
        for(auto &flight : flights) flightCostMap[ flight[0] ].push_back( { flight[1] , flight[2] } );

        auto compFlightInfo = [](flightInfo &a, flightInfo &b) { return (a.totalCost > b.totalCost); };
        priority_queue<flightInfo, vector<flightInfo>, decltype(compFlightInfo)> flightOptionHeap;

        vector<vector<int>> bestCityVisitCostByStop(n, vector<int>(k+1, INVALID_FLIGHT_COST));
        flightOptionHeap.push({src, 0, STOP_NUM_OF_START_POINT});

        while(flightOptionHeap.size()) {
            auto [destIdx, curTotalCost, curTotalStopNum] = flightOptionHeap.top();
            flightOptionHeap.pop();

            if(destIdx == dst) {
                return curTotalCost;
            }

            if(curTotalStopNum != STOP_NUM_OF_START_POINT) {
                if(curTotalCost >= bestCityVisitCostByStop[destIdx][curTotalStopNum]) continue;
                bestCityVisitCostByStop[destIdx][curTotalStopNum] = curTotalCost;
            }

            int nextTotalStopNum = curTotalStopNum + 1;
            if(nextTotalStopNum > k) continue;

            for(auto [newDest, flightCost] : flightCostMap[destIdx]) {

                int nextTotalCost = curTotalCost + flightCost;
                flightOptionHeap.push({newDest, nextTotalCost, nextTotalStopNum});
            }
        }

        return -1;
    }
};
```

## V2：Update MinCostCond To Trim Branch Before Push New Cond (前剪枝)
```Cpp
#define INVALID_FLIGHT_COST (INT_MAX)
#define STOP_NUM_OF_START_POINT (-1)
class Solution {
private:
    struct flightInfo {
        int toIdx;
        int totalCost;
        int totalStopNum;
    };

    struct flightCost {
        int dest;
        int flightCost;
    };

public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {

        vector<vector<flightCost>> flightCostMap(n);
        for(auto &flight : flights) flightCostMap[ flight[0] ].push_back( { flight[1] , flight[2] } );

        auto compFlightInfo = [](flightInfo &a, flightInfo &b) { return (a.totalCost > b.totalCost); };
        priority_queue<flightInfo, vector<flightInfo>, decltype(compFlightInfo)> flightOptionHeap;

        vector<vector<int>> bestCityVisitCostByStop(n, vector<int>(k+1, INVALID_FLIGHT_COST));
        flightOptionHeap.push({src, 0, STOP_NUM_OF_START_POINT});

        while(flightOptionHeap.size()) {
            auto [destIdx, curTotalCost, curTotalStopNum] = flightOptionHeap.top();
            flightOptionHeap.pop();

            if(destIdx == dst) {
                return curTotalCost;
            }

            int nextTotalStopNum = curTotalStopNum + 1;
            if(nextTotalStopNum > k) continue;

            for(auto [newDest, flightCost] : flightCostMap[destIdx]) {

                int nextTotalCost = curTotalCost + flightCost;
                if(nextTotalCost >= bestCityVisitCostByStop[newDest][nextTotalStopNum]) continue;

                bestCityVisitCostByStop[newDest][nextTotalStopNum] = nextTotalCost;
                flightOptionHeap.push({newDest, nextTotalCost, nextTotalStopNum});
            }
        }

        return -1;
    }
};
```

## V3：複習2nd - 模板化寫法
```Cpp
#define INITIAL_STOP_CNT (-1)
class Solution {
private:
	struct arriveInfo {
		int placeIdx;
		int stopCnt;
		int cost;
	};
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
	    // arrange flights by src
	    vector<vector<int>> flightIdxFromSrcIdx(n);
	    for(int i = 0; i < flights.size(); i++) flightIdxFromSrcIdx[flights[i][0]].push_back(i);
	    
        // reached flight condition
        vector<vector<int>> arrivePlaceCost(n, vector<int>(k+1, -1));

		// preview of cost to dst
		vector<vector<int>> previewOfCostToPlace(n, vector<int>(k+1, INT_MAX));

		// heap as flight arbiter
		auto cmpArriveInfo = [](auto &a, auto &b) {return a.cost > b.cost;};
		priority_queue<arriveInfo, vector<arriveInfo>, decltype(cmpArriveInfo)> minCostHeap(cmpArriveInfo);

		// initial condition
		minCostHeap.push({.placeIdx = src, .stopCnt = INITIAL_STOP_CNT, .cost = 0});

		// dijkstra check min cost flight
		while(minCostHeap.size()) {

			// pop min cost dist from heap
			auto [placeIdx, stopCntToCurPlace, costToCurPlace] = minCostHeap.top();
			minCostHeap.pop();
			
			// check if dst is shorter
			if(stopCntToCurPlace > k) continue;

			// check lower cost & update min cost to place
			if(stopCntToCurPlace != INITIAL_STOP_CNT) {
				int &arrivePlaceCostRef = arrivePlaceCost[placeIdx][stopCntToCurPlace];
				if((arrivePlaceCostRef != -1) && (costToCurPlace >= arrivePlaceCostRef)) continue;
				arrivePlaceCostRef = costToCurPlace;
			}

			// check if dest is reached
			if(placeIdx == dst) return costToCurPlace;

			// prepare for flight from current arrived position
			// (1) check top cnt
			int nextStopCnt = stopCntToCurPlace + 1;
			if(nextStopCnt > k) continue;

			// (2) check flight cost
			for(int flightIdx : flightIdxFromSrcIdx[placeIdx]) {
				int totalCostToNext = costToCurPlace + flights[ flightIdx ][2];
				int nextPlaceIdx = flights[ flightIdx ][1];
				
				if(totalCostToNext >= previewOfCostToPlace[nextPlaceIdx][nextStopCnt]) continue;
				previewOfCostToPlace[nextPlaceIdx][nextStopCnt] = totalCostToNext;
				minCostHeap.push({.placeIdx = nextPlaceIdx, .stopCnt = nextStopCnt, .cost = totalCostToNext});
			}
		}

		// finish if the dst can't be reached during process
		return -1;
    }
};
```