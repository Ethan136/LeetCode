---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

# Concept
- **Dijkstra 可以搭配一個類似 DP 的 memo，來記錄『更新的內容』，是否可以讓 cost 更符合預期方向
	- push 前更新 memo 數值 + 比對情況不把會變差的推進去 -> 最能減少分支
	- pop 後檢查當前處理的 case 並且比對 memo -> 分支比較多（因為有可能在 push 的時候多推了好幾個可以過濾掉的情況進去）
- **上面這個 memo 依照情況，可能是 1D vector，也可能是 2D vector -> 這題是 2D Vector 的情況**

# Answer：Brute Force DFS
```Cpp
typedef vector<int> vec_int;
#define INVALID_COST    (-1)
class Solution {
private:
    int minCostFromSrcToDst(auto &flightMap, int src, int dst, int remainFlightCnt) {
        if(remainFlightCnt < 0) return INVALID_COST;
        if(src == dst) return 0;

        int minCost = INVALID_COST;
        for(auto pFlight : flightMap[src]) {

            int toPlace = (*pFlight)[1];
            int toPlaceCost = (*pFlight)[2];
            
            // check the ticket had been used & record ticket used by set price as invalid
            if(toPlaceCost == INVALID_COST) continue;
            (*pFlight)[2] = INVALID_COST;

            // calculate cost of next flight & restore ticket price
            int costAfterToPlace = minCostFromSrcToDst(flightMap, toPlace, dst, remainFlightCnt-1);
            (*pFlight)[2] = toPlaceCost;

            // check if the cost is valid & calculate total cost of path
            if(costAfterToPlace == INVALID_COST) continue;
            int costToDst = toPlaceCost + costAfterToPlace;

            // update minimal cost
            minCost = (minCost == INVALID_COST) ? (costToDst) : (min(minCost, costToDst));
        }

        return minCost;
    }
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        unordered_map<int, vector<vec_int*>> flightMap;
        for(auto &flight : flights) flightMap[ flight[0] ].push_back( &flight );

        int maxFlightCnt = k + 1;
        return minCostFromSrcToDst(flightMap, src, dst, maxFlightCnt );
    }
};
```


# Answer：Dijkstra

## V1：Update MinCostCond To Trim Branch After Pop New Cond (後剪枝)
```Cpp
#define INVALID_FLIGHT_COST (INT_MAX)
#define STOP_NUM_OF_START_POINT (-1)
class Solution {
private:
    struct flightInfo {
        int toIdx;
        int totalCost;
        int totalStopNum;
    };

    struct flightCost {
        int dest;
        int flightCost;
    };

public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {

        vector<vector<flightCost>> flightCostMap(n);
        for(auto &flight : flights) flightCostMap[ flight[0] ].push_back( { flight[1] , flight[2] } );

        auto compFlightInfo = [](flightInfo &a, flightInfo &b) { return (a.totalCost > b.totalCost); };
        priority_queue<flightInfo, vector<flightInfo>, decltype(compFlightInfo)> flightOptionHeap;

        vector<vector<int>> bestCityVisitCostByStop(n, vector<int>(k+1, INVALID_FLIGHT_COST));
        flightOptionHeap.push({src, 0, STOP_NUM_OF_START_POINT});

        while(flightOptionHeap.size()) {
            auto [destIdx, curTotalCost, curTotalStopNum] = flightOptionHeap.top();
            flightOptionHeap.pop();

            if(destIdx == dst) {
                return curTotalCost;
            }

            if(curTotalStopNum != STOP_NUM_OF_START_POINT) {
                if(curTotalCost >= bestCityVisitCostByStop[destIdx][curTotalStopNum]) continue;
                bestCityVisitCostByStop[destIdx][curTotalStopNum] = curTotalCost;
            }

            int nextTotalStopNum = curTotalStopNum + 1;
            if(nextTotalStopNum > k) continue;

            for(auto [newDest, flightCost] : flightCostMap[destIdx]) {

                int nextTotalCost = curTotalCost + flightCost;
                flightOptionHeap.push({newDest, nextTotalCost, nextTotalStopNum});
            }
        }

        return -1;
    }
};
```

## V2：Update MinCostCond To Trim Branch Before Push New Cond (前剪枝)
```Cpp
#define INVALID_FLIGHT_COST (INT_MAX)
#define STOP_NUM_OF_START_POINT (-1)
class Solution {
private:
    struct flightInfo {
        int toIdx;
        int totalCost;
        int totalStopNum;
    };

    struct flightCost {
        int dest;
        int flightCost;
    };

public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {

        vector<vector<flightCost>> flightCostMap(n);
        for(auto &flight : flights) flightCostMap[ flight[0] ].push_back( { flight[1] , flight[2] } );

        auto compFlightInfo = [](flightInfo &a, flightInfo &b) { return (a.totalCost > b.totalCost); };
        priority_queue<flightInfo, vector<flightInfo>, decltype(compFlightInfo)> flightOptionHeap;

        vector<vector<int>> bestCityVisitCostByStop(n, vector<int>(k+1, INVALID_FLIGHT_COST));
        flightOptionHeap.push({src, 0, STOP_NUM_OF_START_POINT});

        while(flightOptionHeap.size()) {
            auto [destIdx, curTotalCost, curTotalStopNum] = flightOptionHeap.top();
            flightOptionHeap.pop();

            if(destIdx == dst) {
                return curTotalCost;
            }

            int nextTotalStopNum = curTotalStopNum + 1;
            if(nextTotalStopNum > k) continue;

            for(auto [newDest, flightCost] : flightCostMap[destIdx]) {

                int nextTotalCost = curTotalCost + flightCost;
                if(nextTotalCost >= bestCityVisitCostByStop[newDest][nextTotalStopNum]) continue;

                bestCityVisitCostByStop[newDest][nextTotalStopNum] = nextTotalCost;
                flightOptionHeap.push({newDest, nextTotalCost, nextTotalStopNum});
            }
        }

        return -1;
    }
};
```
