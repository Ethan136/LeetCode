---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[1584. Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/)

# Concept
- 先選一個點作為 component 1st point
- 後續不斷把新的點加到 component
	- 計算外部的點到 1st point 的距離，並且記錄起來，然後把 min dist 的點加入 component
		- 取得 min dist 的方式可以用 priority queue
	- min dist point 加入 component 前，先計算『這個點以外點外部點』到 min dist point 的距離，並且記錄起來
		- 如果『這個點以外點外部點』到 min dist point 的距離，比先前記錄的『這個外部點到某個 component 的點點距離』距離大
		- -> 不採用，代表這個外部點有其他更近的 component point 可以連線

# Answer - Prime's Algorithm - O( n x nlog(n) )
```Cpp
class Solution {
private:
    struct distInfo_t {
        int toIdx;
        int dist;
    };
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        
        // to record the calculated results
        auto cmpDistInfo = [](distInfo_t &a, distInfo_t &b) {
            return a.dist > b.dist;
        };
        priority_queue<distInfo_t, vector<distInfo_t>, decltype(cmpDistInfo)> distInfoQueue;

        // to record the calculated min dist
        vector<int> minDistCalcRecord(points.size(), INT_MAX);

        // lambda func for dist calculation
        auto calcDist = [&](int idx1, int idx2) {
            return abs(points[idx1][0] - points[idx2][0]) + abs(points[idx1][1] - points[idx2][1]);
        };

        // use idx 0 point as component
        unordered_set<int> usedPointIdxSet = {0};
        minDistCalcRecord[0] = 0;

        // calculate idx 0 to others
        for(int i = 1; i < points.size(); i++) {
            int dist = calcDist(0, i);
            distInfoQueue.push({i, dist});
            minDistCalcRecord[i] = dist;
        }

        // connect remained point to the component
        int totalLen = 0;
        while(usedPointIdxSet.size() < points.size()) {

            int minDistTargetIdx = -1;
            int minDist = INT_MAX;
    
            while( distInfoQueue.size() ) {
                auto [toIdx, dist] = distInfoQueue.top();
                distInfoQueue.pop();

                if(usedPointIdxSet.count(toIdx)) {
                    continue;
                }

                minDistTargetIdx = toIdx;
                minDist = dist;
                break;
            }
            totalLen += minDist;

            usedPointIdxSet.insert(minDistTargetIdx);
            for(int i = 0; i < points.size(); i++) {

                if(usedPointIdxSet.count(i)) continue;
                int dist = calcDist( minDistTargetIdx, i );

                if(dist >= minDistCalcRecord[i]) continue;
                minDistCalcRecord[i] = dist;

                distInfoQueue.push({i, dist});
            }
        }

        return totalLen;
    }
};
```