---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[1584. Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/)

# Concept
- 先選一個點作為 component 1st point
- 後續不斷把新的點加到 component
	- 計算外部的點到 1st point 的距離，並且記錄起來，然後把 min dist 的點加入 component
		- 取得 min dist 的方式可以用 priority queue
	- min dist point 加入 component 前，先計算『這個點以外點外部點』到 min dist point 的距離，並且記錄起來
		- 如果『這個點以外點外部點』到 min dist point 的距離，比先前記錄的『這個外部點到某個 component 的點點距離』距離大
		- -> 不採用，代表這個外部點有其他更近的 component point 可以連線

# Answer - Prime's Algorithm - O( n x nlog(n) )
## V1：複習1st - 速度最佳化的（有 forward branch trim）
```Cpp
class Solution {
private:
    struct distInfo_t {
        int toIdx;
        int dist;
    };
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        
        // to record the calculated results
        auto cmpDistInfo = [](distInfo_t &a, distInfo_t &b) {
            return a.dist > b.dist;
        };
        priority_queue<distInfo_t, vector<distInfo_t>, decltype(cmpDistInfo)> distInfoQueue;

        // to record the calculated min dist
        vector<int> minDistCalcRecord(points.size(), INT_MAX);

        // lambda func for dist calculation
        auto calcDist = [&](int idx1, int idx2) {
            return abs(points[idx1][0] - points[idx2][0]) + abs(points[idx1][1] - points[idx2][1]);
        };

        // use idx 0 point as component
        unordered_set<int> usedPointIdxSet = {0};
        minDistCalcRecord[0] = 0;

        // calculate idx 0 to others
        for(int i = 1; i < points.size(); i++) {
            int dist = calcDist(0, i);
            distInfoQueue.push({i, dist});
            minDistCalcRecord[i] = dist;
        }

        // connect remained point to the component
        int totalLen = 0;
        while(usedPointIdxSet.size() < points.size()) {

            int minDistTargetIdx = -1;
            int minDist = INT_MAX;
    
            while( distInfoQueue.size() ) {
                auto [toIdx, dist] = distInfoQueue.top();
                distInfoQueue.pop();

                if(usedPointIdxSet.count(toIdx)) {
                    continue;
                }

                minDistTargetIdx = toIdx;
                minDist = dist;
                break;
            }
            totalLen += minDist;

            usedPointIdxSet.insert(minDistTargetIdx);
            for(int i = 0; i < points.size(); i++) {

                if(usedPointIdxSet.count(i)) continue;
                int dist = calcDist( minDistTargetIdx, i );

                if(dist >= minDistCalcRecord[i]) continue;
                minDistCalcRecord[i] = dist;

                distInfoQueue.push({i, dist});
            }
        }

        return totalLen;
    }
};
```

## V2：複習2nd - 模板化寫法（有 forward branch trim）
```Cpp
class Solution {
private:
    struct pointIdxWithCost {
        int idx;
        int cost;
    };
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
	    // preview of min cost connect to un-reached points
	    vector<int> minConnectCostPreview(points.size(), INT_MAX);

        // all the connected points
        unordered_set<int> connectedPointIdx;

        // arbiter of the dist between un-connect points to connected-component
        auto cmpLargeCost = [](auto &a, auto &b) {return a.cost > b.cost;};
        priority_queue<pointIdxWithCost, vector<pointIdxWithCost>, decltype(cmpLargeCost)> minCostToConnectedPoint;

        // func to calc cost
        auto calcCost = [](auto &a, auto &b) {
            return abs(a[0] - b[0]) + abs(a[1] - b[1]);
        };

        // select first point to connected group
        minCostToConnectedPoint.push({0, 0});
        minConnectCostPreview[0] = 0;

        // connect all remained points
        int totalCost = 0;
        while(connectedPointIdx.size() < points.size()) {

            // select one point with minimum cost
            auto [pointIdx, cost] = minCostToConnectedPoint.top();
            minCostToConnectedPoint.pop();

            // add selected point to connected component
            // (check if the select point had already been in the connected component
            if(connectedPointIdx.count(pointIdx)) continue;
            connectedPointIdx.insert(pointIdx);

            // update total cost
            totalCost += cost;

            // calc & store the dist of un-selected points to the latest selected ponts
            for(int i = 0; i < points.size(); i++) {
                if(connectedPointIdx.count(i)) continue;

                int connectNewPointCost = calcCost(points[i], points[pointIdx]);
                if(connectNewPointCost >= minConnectCostPreview[i]) continue;
                minConnectCostPreview[i] = connectNewPointCost;

                minCostToConnectedPoint.push({ i, connectNewPointCost });
            }
        }

        // finish
        return totalCost;

    }
};
```