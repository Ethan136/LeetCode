---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)

# Concept
隱藏條件
1. 這些票可以組成一條完整的行程，不會有孤立航線。
2. 起點一定是 "JFK"。  
    → 這就等於保證：  尤拉環的情況
- 整張圖是「連通」的（至少在無向意義下）。
- 入出度條件會滿足「歐拉路徑」的必要條件。

上面條件符合的時候
- 各個機場節點湊成一個閉環
- **如果從 A 觸發的機票有四張，分別到 B / C / D / E，則『不一定』能找到一個這樣的解： .... (A->B)....(A->C)....(A->D).....(A->E)....**

舉例來說，下面這個情況，如果用 pre-order 直接先走 JFK->ATL，後續再走 JFK -> SFO
這個情況下會發生『 JFK -> ATL -> ...JFK -> ATL ... -> ATL』走完後，code 才走 JFK -> SFO
而上面這個走法，是有問題的，因為 『 JFK -> ATL -> ...JFK -> ATL ... -> ATL』走完並沒有回到 JFK，就直接走到 SFO
```
   ┌─────────────→ SFO ──────────┐
   │                              │
JFK ──→ ATL ─→ AAA ─→ ATL ─→ BBB ─JFK─→ ATL ─→ CCC ─→ ATL ─→ … ─→ NNN ─→ ATL
   │                              │
   └──────────────────────────────┘
```


**Hierholzer's Algorithm 概念說明**
- 照順序走一次，但不是 dfs 的時候就記錄，而是等走到 end point 回退的時候才記錄
- **這個情況下 dfs 執行時候可能沒有依照合理的走環順序，但退回時候記錄的順序一定是合理的連結情況**

# Answer：DFS BruteForce
```Cpp
#define START_PLACE ("JFK")
class Solution {
private:
    struct ticketInfo_t {
        string toPlace;
        bool used = false;
    };

    bool flightAllTickets(int ticketNum, auto& ticketInfoMap, auto& fromPlace, auto& result) {
        
        //cout<<"tick num: "<<ticketNum<< " | from" << fromPlace << endl;
        if(!ticketNum) return true;
        auto& ticketInfoVec = ticketInfoMap[fromPlace];

        //cout << " - ticket list num: " << ticketInfoVec.size()<<endl;
        for (auto& [toPlace, ticketUsed] : ticketInfoVec) {
            if(ticketUsed) continue;
            ticketUsed = true;

            //cout << " to place: " << toPlace << endl;
            if (flightAllTickets(ticketNum - 1, ticketInfoMap, toPlace, result)) {
                result.push_back(toPlace);
                return true;
            }

            ticketUsed = false;
        }
        return false;
    }

public: 
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        unordered_map<string, vector<ticketInfo_t>> ticketInfoMap;

        for (auto& ticket : tickets) {
            ticketInfoMap[ticket[0]].push_back({ticket[1], false} );
        }

         auto cmpTicketInfo = [](auto &a, auto &b) {
            return a.toPlace < b.toPlace;
        };

        for (auto& [fromPlace, destVect] : ticketInfoMap) {
            sort(destVect.begin(), destVect.end(), cmpTicketInfo);
        }

        vector<string> resultBackward;
        flightAllTickets(tickets.size(), ticketInfoMap, START_PLACE, resultBackward);
        resultBackward.push_back( START_PLACE);

        auto& result = resultBackward;
        reverse(result.begin(), result.end());
        return result;  
    }
};
``` 

# Answer：DFS + Hierholzer's Algorithm
```Cpp
#define START_PLACE ("JFK")
class Solution {
private:
    struct destTicketInfo_t {
        vector<string> toPlaces;
        int usedTicketNum = 0;
    };

    void flightAllTickets(auto& ticketInfoMap, auto& fromPlace, auto& result) {
    
        // try using remained tickets to go to next places
        auto &[toPlaces, usedTicketNum] = ticketInfoMap[fromPlace];
        while( usedTicketNum < toPlaces.size() ) {
            flightAllTickets(ticketInfoMap, toPlaces[ usedTicketNum++ ], result);
        }

        // record the place when there's no remained ticket to go
        result.push_back(fromPlace);
    };

public: 
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        unordered_map<string, destTicketInfo_t> ticketInfoMap;

        for (auto& ticket : tickets) {
            ticketInfoMap[ticket[0]].toPlaces.push_back(ticket[1]);
        }

        for (auto& [fromPlace, destTicketInfo] : ticketInfoMap) {
            sort(destTicketInfo.toPlaces.begin(), destTicketInfo.toPlaces.end());
        }

        vector<string> resultBackward; resultBackward.reserve(tickets.size()+1);
        flightAllTickets(ticketInfoMap, START_PLACE, resultBackward);

        auto& result = resultBackward;
        reverse(result.begin(), result.end());
        return result;  
    }
};
```