---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)

# Concept
**Dijkstra**
- 有別於 DFS 和 BFS
	- DFS 是以 stack 為 arbiter
	- BFS 是以 queue 為 arbiter
	- dijkstra 是以 heap 為 arbiter -> *優先處理『less / larger cost』*
- 這題要找最短時間，但實際 reach 到某個 node 的方式有很多組
	- **用一個 vector 記錄先前計算過的 min reach time**
	- 用 min heap 來分配每次要檢查的 next node -> 確保每次都拿『待處理的路徑中』最短的一條來做計算

# Answer：Dijkstra

## V1：基本型態 - 一律 Push to Heap，pop out 的時候如果造成較長時間則捨棄這個次 transmit
```Cpp
#define INVALID_REACH_TIME  (-1)
typedef vector<int> vec_int;
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // arrange the transmit info for each node
        vector< vector<vec_int*> > transInfoFromNode(n+1);
        for(auto &time : times) transInfoFromNode[time[0]].push_back(&time);

        // to record the min reach time calculated before
        vec_int minReachTime(n+1, INVALID_REACH_TIME);
        minReachTime[0] = 0;
        minReachTime[k] = 0;

        // func to update the min reach time to node
        auto updateMinReachTime = [&](vec_int* pTime) {

            int fromNode = (*pTime)[0];
            int toNode = (*pTime)[1];
            int transTime = (*pTime)[2];

            int overallTransTime = minReachTime[fromNode] + transTime;            
            bool updateReachTime = (minReachTime[ toNode ] == INVALID_REACH_TIME) || (overallTransTime < minReachTime[ toNode ]);

            if(updateReachTime) {
                minReachTime[ toNode ] = overallTransTime;
            }
            return updateReachTime;
        };

        // priority queue to arbiter the node to be transferred
        auto cmpTimeLarger = [](vec_int* a, vec_int* b) {
            return (*a)[2] > (*b)[2];
        };
        priority_queue<vec_int*, vector<vec_int*>, decltype(cmpTimeLarger)> lessTimeHeap;

        // transfer from initial node k
        for(auto pTime : transInfoFromNode[k]) {
            lessTimeHeap.push(pTime);
        }

        // do transmit
        while(lessTimeHeap.size()) {
            vec_int* pTime = lessTimeHeap.top();
            lessTimeHeap.pop();

            if(!updateMinReachTime(pTime)) continue;

            for(auto pTimeNext : transInfoFromNode[ (*pTime)[1] ]) {
                lessTimeHeap.push(pTimeNext);
            }
        }

        // find max reach time
        int maxReachTime = 0;
        for(auto t : minReachTime) {
            if(t == INVALID_REACH_TIME) return -1;
            maxReachTime = max(maxReachTime, t);
        }
        return maxReachTime;
    }
};
```

## V2：Push to Heap 前先檢查待傳入的 time 是否會產生較大的時間 -> 如果是則避免傳入
```Cpp
#define INVALID_REACH_TIME  (-1)
typedef vector<int> vec_int;
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // arrange the transmit info for each node
        vector< vector<vec_int*> > transInfoFromNode(n+1);
        for(auto &time : times) transInfoFromNode[time[0]].push_back(&time);

        // to record the min reach time calculated before
        vec_int minReachTime(n+1, INVALID_REACH_TIME);
        minReachTime[0] = 0;
        minReachTime[k] = 0;

        // func to update the min reach time to node
        auto cmpReachTimeLess = [&](int toNode, int newReachTime) {
            return (minReachTime[ toNode ] == INVALID_REACH_TIME) || (newReachTime < minReachTime[ toNode ]);
        };
        auto updateMinReachTime = [&](vec_int* pTime) {

            int fromNode = (*pTime)[0];
            int toNode = (*pTime)[1];
            int reachTime = minReachTime[ fromNode ] + (*pTime)[2];

            bool updateReachTime = cmpReachTimeLess(toNode, reachTime);
            if(updateReachTime) {
                minReachTime[ toNode ] = reachTime;
            }
            return updateReachTime;
        };

        // priority queue to arbiter the node to be transferred
        auto cmpTimeLarger = [](vec_int* a, vec_int* b) {
            return (*a)[2] > (*b)[2];
        };
        priority_queue<vec_int*, vector<vec_int*>, decltype(cmpTimeLarger)> lessTimeHeap;

        // transfer from initial node k
        for(auto pTime : transInfoFromNode[k]) {
            lessTimeHeap.push(pTime);
        }

        // do transmit
        while(lessTimeHeap.size()) {
            vec_int* pTime = lessTimeHeap.top();
            lessTimeHeap.pop();

            if(!updateMinReachTime(pTime)) continue;

            int fromNode = (*pTime)[1];
            for(auto pTimeNext : transInfoFromNode[fromNode]) {
                int toNode = (*pTimeNext)[1];
                int reachTime = minReachTime[fromNode] + (*pTimeNext)[2];

                if(!cmpReachTimeLess(toNode, reachTime)) continue;
                lessTimeHeap.push(pTimeNext);
            }
        }

        // find max reach time
        int maxReachTime = 0;
        for(auto t : minReachTime) {
            if(t == INVALID_REACH_TIME) return -1;
            maxReachTime = max(maxReachTime, t);
        }
        return maxReachTime;
    }
};
```


## V3：Heap 依照 final reach time 來排序，而不依照『node trans time』排序
**速度和 V2 差不多，主要效益來自於 push 前檢查 final reach time 是否會有效降低**
```Cpp
#define INVALID_REACH_TIME  (-1)
typedef vector<int> vec_int;
typedef pair<int, int> pair_int;
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // arrange the transmit info for each node
        vector< vector<vec_int*> > transInfoFromNode(n+1);
        for(auto &time : times) transInfoFromNode[time[0]].push_back(&time);

        // to record the min reach time calculated before
        vec_int minReachTime(n+1, INVALID_REACH_TIME);
        minReachTime[0] = 0;
        minReachTime[k] = 0;

        // func to update the min reach time to node
        auto cmpReachTimeLess = [&](pair_int &toNodeTime) {
            return (minReachTime[ toNodeTime.first ] == INVALID_REACH_TIME) || (toNodeTime.second < minReachTime[ toNodeTime.first ]);
        };
        auto updateMinReachTime = [&](pair_int &toNodeTime) {

            bool updateReachTime = cmpReachTimeLess(toNodeTime);
            if(updateReachTime) {
                minReachTime[ toNodeTime.first ] = toNodeTime.second;
            }
            return updateReachTime;
        };

        // priority queue to arbiter the node to be transferred
        auto cmpTimeLarger = [](pair_int &a, pair_int &b) {
            return a.second > b.second;
        };
        priority_queue<pair_int, vector<pair_int>, decltype(cmpTimeLarger)> lessTimeHeap;

        // transfer from initial node k
        for(auto pTime : transInfoFromNode[k]) {
            pair_int toNodeTime = { (*pTime)[1], (*pTime)[2] };
            lessTimeHeap.push(toNodeTime);
        }

        // do transmit
        while(lessTimeHeap.size()) {
            pair_int toNodeTime = lessTimeHeap.top();
            lessTimeHeap.pop();

            if(!updateMinReachTime(toNodeTime)) continue;

            for(auto pTimeNext : transInfoFromNode[ toNodeTime.first ]) {
                int toNextNode = (*pTimeNext)[1];
                int reachTime = minReachTime[ toNodeTime.first ] + (*pTimeNext)[2];
                pair_int toNextNodeTime = {toNextNode, reachTime};

                if(!cmpReachTimeLess(toNextNodeTime)) continue;
                lessTimeHeap.push(toNextNodeTime);
            }
        }

        // find max reach time
        int maxReachTime = 0;
        for(auto t : minReachTime) {
            if(t == INVALID_REACH_TIME) return -1;
            maxReachTime = max(maxReachTime, t);
        }
        return maxReachTime;
    }
};
```

## V4：和 V3 相同邏輯但 Code 簡化 + 一開始的時候 push first node + reach time 0 進 Heap 即可
```Cpp
#define INVALID_REACH_TIME  (-1)
typedef vector<int> vec_int;
typedef pair<int, int> pair_int;
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // arrange the transmit info for each node
        vector< vector<vec_int*> > transInfoFromNode(n+1);
        for(auto &time : times) transInfoFromNode[time[0]].push_back(&time);

        // to record the min reach time calculated before
        // init redundant node0 reach time as 0
        vec_int minReachTime(n+1, INVALID_REACH_TIME);
        minReachTime[0] = 0;

        // priority queue to arbiter the node to be transferred
        auto cmpTimeLarger = [](pair_int &a, pair_int &b) {
            return a.second > b.second;
        };
        priority_queue<pair_int, vector<pair_int>, decltype(cmpTimeLarger)> lessTimeHeap;

        // transfer from initial node k -> {toNode = k, time = 0}
        minReachTime[k] = 0;
        lessTimeHeap.push({k, 0});

        // do transmit
        while(lessTimeHeap.size()) {
            pair_int toNodeTime = lessTimeHeap.top();
            lessTimeHeap.pop();

            for(auto pTimeNext : transInfoFromNode[ toNodeTime.first ]) {
                int toNextNode = (*pTimeNext)[1];
                int reachTime = minReachTime[ toNodeTime.first ] + (*pTimeNext)[2];

                if((minReachTime[ toNextNode ] != INVALID_REACH_TIME) && (reachTime >= minReachTime[ toNextNode ])) continue;
                minReachTime[ toNextNode ] = reachTime;

                lessTimeHeap.push({toNextNode, reachTime});
            }
        }

        // find max reach time
        int maxReachTime = 0;
        for(auto t : minReachTime) {
            if(t == INVALID_REACH_TIME) return -1;
            maxReachTime = max(maxReachTime, t);
        }
        return maxReachTime;
    }
};
```