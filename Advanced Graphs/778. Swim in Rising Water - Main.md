---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)

# Concept
- 題目轉換後的目標 -> **找一個路徑，路徑上面的 max height 是最低的**
- **可以用 Dijkstra 進行 traverse，每次 traverse 都更新『走到某個位置的時候，路徑上最低的 max height 是多少』 -> 這個資訊也用來剪枝**


# Answer: Brute Force DFS
```Cpp
class Solution {
private:
    int swimToLastPointAndGetHighestInPath(auto &grid, int r, int c, int prevHighest) {
        // out of range
        if((r < 0) || (r >= grid.size())) return -1;
        if((c < 0) || (c >= grid[r].size())) return -1;
        
        // final dest
        if((r == (grid.size()-1)) && (c == (grid[r].size()-1))) return max(grid[r][c], prevHighest);
        
        // if traversed
        if(grid[r][c] == -1) return -1;
        
        // mark traversed
        int curH = grid[r][c];
        grid[r][c] = -1;
        
        // prev highest point to include cur position
        prevHighest = max(prevHighest, curH);
        
        // init trav result
        int result = -1;
        
        // traverse to adjacent point
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        for(int i = 0; i < 4; i++) {
            int nextH = swimToLastPointAndGetHighestInPath(grid, r+dir[i][0], c+dir[i][1], prevHighest);
            if(nextH < 0) continue;
            result = (result == -1) ? (nextH) : min(result, nextH);
        }
        
        // restore traversed mark & return result
        grid[r][c] = curH;
        return result;
    }
public:
    int swimInWater(vector<vector<int>>& grid) {
        return swimToLastPointAndGetHighestInPath(grid, 0, 0, 0);
    }
};
```
# Answer: Dijkstra + Trim Branch Before Push Heap
```Cpp
class Solution {
private:
    struct travInfo{
        int r;
        int c;
        int onPathHighest;
    };
public:
    int swimInWater(vector<vector<int>>& grid) {
        vector<vector<int>> minHighestOnPath(grid.size(), vector<int>(grid[0].size(), INT_MAX));
        
        auto cmpTravInfoLarge = [](auto &a, auto &b) { return a.onPathHighest > b.onPathHighest; };
        priority_queue<travInfo, vector<travInfo>, decltype(cmpTravInfoLarge)> minTravInfoHeap;
        
        minHighestOnPath[0][0] = grid[0][0];
        minTravInfoHeap.push( {0, 0, grid[0][0]} );
        
        while(minTravInfoHeap.size()) {
            auto [r, c, onPathHighest] = minTravInfoHeap.top();
            minTravInfoHeap.pop();
            
            if((r == (grid.size()-1)) && (c == (grid[r].size()-1))) {
                break;
            }
            
            int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
            for(int i = 0; i < 4; i++) {
                int r2 = r + dir[i][0];
                int c2 = c + dir[i][1];
                
                if((r2 < 0) || (r2 >= grid.size())) continue;
                if((c2 < 0) || (c2 >= grid[r2].size())) continue;
                
                int onPathHighestToNext = max(grid[r2][c2], onPathHighest);
                if(onPathHighestToNext >= minHighestOnPath[r2][c2]) continue;
                
                minHighestOnPath[r2][c2] = onPathHighestToNext;
                minTravInfoHeap.push( {r2, c2, onPathHighestToNext} );
            }
        }
        
        return minHighestOnPath.back().back();
    }
};
``` 

# Answer：Dijkstra 模板寫法
```Cpp
#define INVALID_REACH_TIME (-1)
class Solution {
private:
	struct gridReachTime {
		int row;
		int col;
		int time;
	};
public:
    int swimInWater(vector<vector<int>>& grid) {
	    // min reach time preview
	    vector<vector<int>> minReachTimePreview(grid.size(), vector<int>(grid[0].size(), INVALID_REACH_TIME));

		// reached grid min time record
		vector<vector<int>> reachTimeRecord(grid.size(), vector<int>(grid[0].size(), INVALID_REACH_TIME));

		// heap to arbiter the traverse
		auto cmpReachTime = [](auto &a, auto &b) {return a.time > b.time;};
		priority_queue<gridReachTime, vector<gridReachTime>, decltype(cmpReachTime)> minReachTimeHeap(cmpReachTime);

		// initial condition
		minReachTimePreview[0][0] = grid[0][0];
		minReachTimeHeap.push({.row = 0, .col = 0, .time = grid[0][0]});

		// do traverse
		while(minReachTimeHeap.size()) {
			// pop min time reachable grid
			auto [row, col, time] = minReachTimeHeap.top();
			minReachTimeHeap.pop();

			// check reach time is less than before
			if((reachTimeRecord[row][col] != -1) && (reachTimeRecord[row][col] <= time)) continue;
			reachTimeRecord[row][col] = time;

			// check if finishing point is reached
			if( (row == (grid.size()-1) ) && (col == (grid[0].size() - 1) ) ) return time;

			// check adjacent point to go
			const int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
			for(int i = 0; i < 4; i++) {
				int nextRow = row + dir[i][0];
				if(nextRow >= grid.size()) continue;
				
				int nextCol = col + dir[i][1];
				if(nextCol >= grid[0].size()) continue;
				
				int nextReachTime = max(time, grid[nextRow][nextCol]);
				int &reachTimePreviewRef = minReachTimePreview[nextRow][nextCol];

				if((reachTimePreviewRef != -1) && (nextReachTime >= reachTimePreviewRef)) continue;
				reachTimePreviewRef = nextReachTime;
				minReachTimeHeap.push({.row = nextRow, .col = nextCol, .time = nextReachTime});
			}
		}

		// if the target point can't be reached
		return -1;
    }
};
```