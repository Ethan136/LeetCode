---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)

# Concept
- 題目轉換後的目標 -> **找一個路徑，路徑上面的 max height 是最低的**
- **可以用 Dijkstra 進行 traverse，每次 traverse 都更新『走到某個位置的時候，路徑上最低的 max height 是多少』 -> 這個資訊也用來剪枝**


# Answer: Brute Force DFS
```Cpp
class Solution {
private:
    int swimToLastPointAndGetHighestInPath(auto &grid, int r, int c, int prevHighest) {
        // out of range
        if((r < 0) || (r >= grid.size())) return -1;
        if((c < 0) || (c >= grid[r].size())) return -1;
        
        // final dest
        if((r == (grid.size()-1)) && (c == (grid[r].size()-1))) return max(grid[r][c], prevHighest);
        
        // if traversed
        if(grid[r][c] == -1) return -1;
        
        // mark traversed
        int curH = grid[r][c];
        grid[r][c] = -1;
        
        // prev highest point to include cur position
        prevHighest = max(prevHighest, curH);
        
        // init trav result
        int result = -1;
        
        // traverse to adjacent point
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        for(int i = 0; i < 4; i++) {
            int nextH = swimToLastPointAndGetHighestInPath(grid, r+dir[i][0], c+dir[i][1], prevHighest);
            if(nextH < 0) continue;
            result = (result == -1) ? (nextH) : min(result, nextH);
        }
        
        // restore traversed mark & return result
        grid[r][c] = curH;
        return result;
    }
public:
    int swimInWater(vector<vector<int>>& grid) {
        return swimToLastPointAndGetHighestInPath(grid, 0, 0, 0);
    }
};
```
# Answer: Dijkstra + Trim Branch Before Push Heap
```Cpp
class Solution {
private:
    struct travInfo{
        int r;
        int c;
        int onPathHighest;
    };
public:
    int swimInWater(vector<vector<int>>& grid) {
        vector<vector<int>> minHighestOnPath(grid.size(), vector<int>(grid[0].size(), INT_MAX));
        
        auto cmpTravInfoLarge = [](auto &a, auto &b) { return a.onPathHighest > b.onPathHighest; };
        priority_queue<travInfo, vector<travInfo>, decltype(cmpTravInfoLarge)> minTravInfoHeap;
        
        minHighestOnPath[0][0] = grid[0][0];
        minTravInfoHeap.push( {0, 0, grid[0][0]} );
        
        while(minTravInfoHeap.size()) {
            auto [r, c, onPathHighest] = minTravInfoHeap.top();
            minTravInfoHeap.pop();
            
            if((r == (grid.size()-1)) && (c == (grid[r].size()-1))) {
                break;
            }
            
            int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
            for(int i = 0; i < 4; i++) {
                int r2 = r + dir[i][0];
                int c2 = c + dir[i][1];
                
                if((r2 < 0) || (r2 >= grid.size())) continue;
                if((c2 < 0) || (c2 >= grid[r2].size())) continue;
                
                int onPathHighestToNext = max(grid[r2][c2], onPathHighest);
                if(onPathHighestToNext >= minHighestOnPath[r2][c2]) continue;
                
                minHighestOnPath[r2][c2] = onPathHighestToNext;
                minTravInfoHeap.push( {r2, c2, onPathHighestToNext} );
            }
        }
        
        return minHighestOnPath.back().back();
    }
};
``` 