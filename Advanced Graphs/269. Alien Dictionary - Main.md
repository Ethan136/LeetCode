---
ParentTask:
  - "[[advanced_graphs]]"
---

# LeetCode
[269. Alien Dictionary](https://leetcode.com/problems/alien-dictionary/)

# Concept
- 先建立一個表『每個字後續有幾個字待確認順序』
- **為 course schedule 的變體**
	- [[207. Course Schedule - Main]]
	- [[210. Course Schedule II - Main]]
- 使用 Dijkstra 反序
	- 先從『後續沒有字需要確認的字母開始 traverse』 -> 這個字一定是最後面的
	- 再把『後續有上述這個字的，扣除這個後續待處理字』 -> 如果扣除後後續沒有字 -> traverse 這個字
	- 上面兩個步驟往復執行

# Answer
```Cpp
class Solution {
private:
    struct charInfo{
        bool waitChk = false;
        int unChkNextCharCnt = 0;
        unordered_set<int> nextCharIdx;
    };
public:
    string foreignDictionary(vector<string>& words) {

        // with 0 word
        if(words.size() == 0) return "";
    
        // only 1 word
        if(words.size() == 1) {
            unordered_set<char> charSet;
            for(char c : words[0]) {
                charSet.insert(c);
                if(charSet.size() == 26) break;
            }
            
            string res = "";
            for(auto c : charSet) res += c;
            return res;
        }
        
        // char relationship: from char i -> next char(s)
        // (0) init
        vector<charInfo> charIdxToNext(26);
        
        // (1) check exist char
        int allCharNum = 0;
        for(auto &word : words) {
            
            for(auto c : word) {
                if(charIdxToNext[c - 'a'].waitChk) continue;
                charIdxToNext[c - 'a'].waitChk = true;
                
                allCharNum++;
                if(allCharNum == 26) break;
            }
            if(allCharNum == 26) break;
        }
        
        // (2) build relationship
        for(int i = 0; i < (words.size()-1); i++){
            // fetch two adjacent words
            auto &word1 = words[i];
            auto &word2 = words[i+1];

            // check if word1 includes word2
            if( (word1.size() > word2.size()) && (word1.find(word2) == 0) ) {
                return "";
            }

            // compare to word
            for(int j = 0; j < min(word1.size(), word2.size()); j++) {
                if(word1[j] == word2[j]) continue;
                if(charIdxToNext[ word1[j] - 'a' ].nextCharIdx.count(word2[j] - 'a')) break;

                charIdxToNext[ word1[j] - 'a' ].nextCharIdx.insert(word2[j] - 'a');
                charIdxToNext[ word1[j] - 'a' ].unChkNextCharCnt++;
                break;
            }
        }
        
        // reverse-traverse all char based on relationship
        // (1) initially traverse char without later char
        queue<int> pendingCharIdx;
        for(int i = 0; i < charIdxToNext.size(); i++) {
            if(!charIdxToNext[i].waitChk) continue;
            if(charIdxToNext[i].unChkNextCharCnt) continue;
            
            charIdxToNext[i].waitChk = false;
            pendingCharIdx.push(i);
        }
        
        // (2) traverse remained char in reversed order
        string result = "";
        while(pendingCharIdx.size()) {

            // pop out one char
            int charIdx = pendingCharIdx.front();
            pendingCharIdx.pop();

            // append result in backward direction
            result += ('a' + charIdx);
            
            // update char relationship & push in new char
            for(int i = 0; i < charIdxToNext.size(); i++) {
                if(!charIdxToNext[i].waitChk) continue;
                if(!charIdxToNext[i].nextCharIdx.count(charIdx)) continue;
                if(--charIdxToNext[i].unChkNextCharCnt) continue;
                
                charIdxToNext[i].waitChk = false;
                pendingCharIdx.push(i);
            }
        }

        // check if all char are checked
        if(result.size() != allCharNum) return "";

        // reverse back the result order
        reverse(result.begin(), result.end());
        return result;
    }
};

```