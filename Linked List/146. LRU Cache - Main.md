---
ParentTask:
  - "[[linked_list]]"
---

# LeetCode
[146. LRU Cache](https://leetcode.com/problems/lru-cache/)

# Concept
- **題目分兩個面向： store 和 mapping**
- store：使用 double link linklist，並且加入一個 augmented entry node
	- entry node -> next = head = 最新的 node
	- entry node -> prev = tail = 最舊的 node
	- 初始化的時候，所有 node key 都用 invalid value （-1）
- mapping：為了達成 O(1) get value
	- 額外一個 map 來找出某個 key 對應的 storage 位置
	- 如果 map 找不到 key -> 把 oldest node 拿來存新的 value -> **需要把 old key 刪除： 所以 node 裡面也必須存 key 的資訊**

# Answer: Ringed DoubleLink LinkList - O(n)
## V1 - 包比較多 func
```Cpp
#define DEBUG_EN (0)
#if DEBUG_EN
void printGet(int key)
{
	cout<<"------------"<<endl;
	cout<<"get: "<<key<<endl;
}

void printPut(int key, int value) {
	cout<<"------------"<<endl;
	cout<<"put: [ "<<key<<" , "<<value<<" ]"<<endl;
}

void printKeyValList(string title){
    cout<<title<<endl;
    auto pNode=m_ValListEntry.next;
    while(pNode!=&m_ValListEntry) {
        cout<<"key: "<<pNode->key<<" | val:"<<pNode->val<<endl;
        pNode=pNode->next;
    }
}
#else
#define printKeyValList(title)
#define printGet(key)
#define printPut(key, value)
#endif

class LRUCache {
private:
    struct tKeyValNode{
        tKeyValNode *next;
        tKeyValNode *prev;
        int key;
        int val;
        tKeyValNode() {next=NULL;prev=NULL;key=-999;val=-999;};
    };
    unordered_map<int,tKeyValNode*> m_KeyToKeyValNode;

    // head: most recently used key
    // tail: least recently used key
    // entry
    // (1) next node=head
    // (2( prevnode=tail
    tKeyValNode m_ValListEntry;

    void LinkNodes(tKeyValNode *node1, tKeyValNode *node2) {
        if(!node1 || !node2) return;
        node1->next=node2;
        node2->prev=node1;
    }

    void MoveNodeToHead(tKeyValNode *node) {
        // de-attach the target node
        LinkNodes(node->prev,node->next);
        
        // move target node to head (recently used)
        // (1) target node link to the current head
        // (2) entry point link to target node
        LinkNodes(node,m_ValListEntry.next);
        LinkNodes(&m_ValListEntry,node);
    }

public:
    LRUCache(int capacity) {

        // init: link entry to itself
        LinkNodes(&m_ValListEntry,&m_ValListEntry);

        // ptr to trasverse the list
        tKeyValNode *curNode=&m_ValListEntry;

        // add new node
        for(int i=0; i<capacity; i++) {
            // create new node
            tKeyValNode *newNode=new tKeyValNode;

            // build link
            LinkNodes(curNode,newNode);
            curNode = curNode->next;
        }

        // build the ring back link
        LinkNodes(curNode,&m_ValListEntry);
    }
    
    int get(int key) {

		// debug info
		printGet(key);

        // debug info
        printKeyValList("before get");

        // check key existance
        if(!m_KeyToKeyValNode.count(key)) return -1;

        // get the node with target value
        tKeyValNode *targetValNode=m_KeyToKeyValNode[key];

        // move node to head
        MoveNodeToHead(targetValNode);

        // debug info
        printKeyValList("after get");

        // return target value
        return targetValNode->val;
    }
    
    void put(int key, int value) {

		// debug info
		printPut(key, value);

        // debug info: before put
        printKeyValList("before put");

        // get the node to set value
        tKeyValNode *setNode;

		// (1) if key exist -> get node with key
		if( m_KeyToKeyValNode.count(key) ) {
			setNode = m_KeyToKeyValNode[key];
		}
		// (2) if not -> get tail node (least recent used) and replace the old key
		else {
			// get tail node
			setNode = m_ValListEntry.prev;

			// replace the old key
			m_KeyToKeyValNode.erase(setNode->key);
			m_KeyToKeyValNode[key] = setNode;
		}

        // set key & val to the node
        setNode->key=key;
        setNode->val=value;

        // move node to head (recently used)
        MoveNodeToHead(setNode);

        // debug info: after put
        printKeyValList("after put");
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```
題目需求
- 建立一個 (key-value) 表

- get( key )
	- 針對這個 key 回傳 value
	- 如果這個 key 不存在，回傳 -1

- put( key, value )
	- 新增一筆 pair: (key - value)
	- 可以儲存的 key 數目有限，如果存滿了，則把『最久沒用到的 key 刪掉』
		- 新 put 進來的 key: 視爲最新使用的 key
		- 新 get 設定的 key: 視爲最新使用的 key

執行概念
- 每次執行的時候，要重新做『新舊排序』
- key 數量雖然有上限，但需要動態增加 -> 使用 link list
- 排序時所需要的
	- head 位置: 最新使用的 key
	- tail 位置: 最久未用的 key

資料結構
- 使用單項 link list 的缺點 -> *每次 pop oldest key 的時候會需要 traverse 到 end*
	- 當使用 put 拔掉某個 key 需要 pop tail 並且 add head 
	- (1) pop tail 須把 traverse 到 prev to tail
	- (2) insert head 需要 insert head
	- **而且由於使用 get 的時候也可能觸發重新排序**
		- **無法透過記錄 prev to tail 來快速處理 tail**
		- **因爲 prev to tail 隨時有可能變成 head**
- 使用雙向 link list + EntryNode + RingBack
	- EntryNode: 本身不儲存資料，作爲入口點
		- EntryNode->next: 儲存 head
		- EntryNode->prev: 儲存 tail
	- 每次要把某個 node 更新到 head
		- (1) 這個 node de-tach: node->prev <前後連結> 到 node->next
			- 如果這個 node 剛好是tail，則這個 node 的前一個是new tail，這個 node 後一個是 EntryNode -> 兩個相連就完成 tail 更新
		- (2) 這個 node 連結到 head
			- 這個 node <前後連結> 到 EntryNode->next
			- EntryNode <前後連結> 到 這個 node
- 提升 get 時候的速度
	- ring link list 只操作 node ptr，不操作實體位置
	- 實際 node 的位置可以用一個 unordered_map<key, node*> 記錄起來，這樣就可以快速從 key 找到對應的 node
	- 由於剔除舊的 key 的時候，除了更新 link list，還需要把 unordered_map 上面的 key 刪除
		- 需要在 node 裏面記錄 key
		- **這樣需要剔除 key 的 tail node 可以快速找出這個 node 對應的 key 是多少**

執行機制
- 建構子: 直接依照 capacity 把 ringe link list 建立起來
	- 總共有: EntryNode + N 個 Data Node
		- EntryNode: 是 member data，不用 new 建構
		- N 個 Data Node: 需要 new 建構
	- 從 EntryNode 開始往後建立 N 個 Node 並且連結過去
	- 最後一個 Node 再連回 Entry Node
- put(key, node)
	- 如果這個 key 不存在 -> 把 TailNode (EntryNode.prev) 取出來
	- 如果這個 key 存在 -> 使用 Map 把對應的 Node 取出來
	- 針對取出的 node 設定 key + value
	- 取出的 node move to head
- get(key)
	- 使用 map 檢查這個 key 有沒有存在
	- 如果 map 檢查 key 不存在 -> 回傳 -1
	- 如果 map 檢查 key 存在 -> 把對應的 node move to head，然後回傳 node 的數值

## V2 - 比較少 func，稍微簡化 move to head 的流程
```Cpp
class LRUCache {
private:
    struct ListNode {
        int key;
        int val;
        ListNode* next;
        ListNode* prev;
    };
    ListNode m_ListEntry;

    unordered_map<int, ListNode*> m_keyToValStore;

    void MoveNodeToHead(ListNode *node) {
        // if the node has already in head
        if(m_ListEntry.next == node) return;

        // remove from the origin position
        // (1) get adjacent nodes
        ListNode *nodePrevToStore = node->prev;
        ListNode *nodeNextToStore = node->next;

        // (2) link adjacent nodes together
        nodePrevToStore->next = nodeNextToStore;
        nodeNextToStore->prev = nodePrevToStore;

        // insert after entry (as newest used position)
        // (1) link new second new node
        ListNode *newNextNode = m_ListEntry.next;
        node->next = newNextNode;
        newNextNode->prev = node;

        // (2) link with entry
        m_ListEntry.next = node;
        node->prev = &m_ListEntry;
    }
public:
    LRUCache(int capacity) {

        // create storage nodes after entry
        ListNode *curNode = &m_ListEntry;
        while(capacity--) {
            ListNode* pNewNode = new ListNode({.key=-1, .val=-1, .next=nullptr, .prev=nullptr});

            curNode->next = pNewNode;
            pNewNode->prev = curNode;

            curNode = pNewNode;
        }

        // link entry back to last created node
        curNode->next = &m_ListEntry;
        m_ListEntry.prev = curNode;
    }
    
    int get(int key) {
        if(!m_keyToValStore.count(key)) return -1;

        ListNode *node = m_keyToValStore[key];
        MoveNodeToHead(node);

        return node->val;
    }
    
    void put(int key, int value) {

        // get node for storage
        ListNode* nodeStoreNewVal = (m_keyToValStore.count(key)) ? (m_keyToValStore[key]) : (m_ListEntry.prev);

        // handle key mapping: delete old key & insert new key
        if(key != nodeStoreNewVal->key) {
            m_keyToValStore.erase(nodeStoreNewVal->key);
            m_keyToValStore[key] = nodeStoreNewVal;
        }

        // handle key in storage: store new key & value
        nodeStoreNewVal->key = key;
        nodeStoreNewVal->val = value;

        // move node to head
        MoveNodeToHead(nodeStoreNewVal);
    }
};

```

## V3：複習2nd - 模板化寫法
```Cpp
class LRUCache {
private:
    struct Node {
        Node* prev = nullptr;
        Node* next = nullptr;
        int val = 0;
        int key = 0;
    };

    Node* m_pEntry;
    unordered_map<int, Node*> m_keyToNode;
    int m_capacity;

    void takeOutNodeFromList(Node* node) {
        Node *prevNode = node->prev;
        Node *nextNode = node->next;
        prevNode->next = nextNode;
        nextNode->prev = prevNode;
    }

    void InsertNodeToListHead(Node* node) {
        Node *oldHead = m_pEntry->next;
        m_pEntry->next = node;
        node->next = oldHead;
        oldHead->prev = node;
        node->prev = m_pEntry;
    }
public:
    LRUCache(int capacity) {
        // ringed link list
        m_pEntry = new Node();
        m_pEntry->prev = m_pEntry;
        m_pEntry->next = m_pEntry;

        // record capacity
        m_capacity = capacity;
    }
    
    int get(int key) {
        // if key invalid
        if(!m_keyToNode.count(key)) return -1;

        // fetch value
        int val = m_keyToNode[key]->val;

        // update node arrangement
        // (1) take out the used node
        Node *usedNode = m_keyToNode[key];
        takeOutNodeFromList(usedNode);

        // (2) insert used node to head
        InsertNodeToListHead(usedNode);

        // finish
        return val;
    }
    
    void put(int key, int value) {
        // (0) if key already exist
        if(m_keyToNode.count(key)) {
            // update node value
            Node* keyNode = m_keyToNode[key];
            keyNode->val = value;

            // takeout keyNode from origin position
            takeOutNodeFromList(keyNode);

            // insert keyNode to head
            InsertNodeToListHead(keyNode);
        }
        // (1) add new node
        else if(m_keyToNode.size() < m_capacity) {
            // add new node
            Node* addNode = new Node();
            addNode->key = key;
            addNode->val = value;
        
            // link new node to head
            InsertNodeToListHead(addNode);

            // record on map
            m_keyToNode[key] = addNode;
        }
        // (2) remove old node
        else {
            // remove tail node & key on map
            Node *oldTail = m_pEntry->prev;
            takeOutNodeFromList(oldTail);
            m_keyToNode.erase( oldTail->key );

            // removed node & store new info & update map
            Node *newStoreNode = oldTail;
            newStoreNode->key = key;
            newStoreNode->val = value;
            m_keyToNode[key] = newStoreNode;

            // new stored node move to head
            InsertNodeToListHead(newStoreNode);
        }
    }
};

```