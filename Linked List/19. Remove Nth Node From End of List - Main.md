---
ParentTask:
  - "[[linked_list]]"
---

# LeetCode
[19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

# Answer
## V1 - Naming 比較不直觀
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

        // initialize the node previous to the one to be deleted and the node on the tail
		// NodePrevToDel: slow pointer to the node before the delete-one
		// TailNode: fast pointer to the last node (valid entity)
        ListNode augmentedHead(0, head);
        ListNode *NodePrevToDel=&augmentedHead, *tailNode=&augmentedHead;

        // move TailNode and make distance "n" after NodePrevToDel
        for(int i=0; i<n; i++) {
            // if the delete N exceeds list length
            if(!tailNode->next) return head;
            tailNode=tailNode->next;
        }

        // trasverse to the tail node (valid entity, not nullptr after last node)
        while(tailNode->next) {
            tailNode=tailNode->next;
            NodePrevToDel=NodePrevToDel->next;
        }

        // delete the target node
        NodePrevToDel->next=NodePrevToDel->next->next;

        // return result
        return augmentedHead->next;
    }
};
```
概念推演
- 從後面刪除第 N 個 Node
	- N=1:刪除最後一個 Node
	- N=2:刪除倒是第二個 Node
- 要從後面刪除 Node
	- 需要知道 Last Node 在哪
	- ->*需要 Traverse To Last Node* -> **Fast Pointer**
- 刪除 Node 需要『被刪除的 Node 的前一個』
	- N=1:刪除最後 [1] 個 Node -> 需要『倒數第二個 Node』-> "last node 的前 [1] 個"
	- N=2:刪除倒是第 [2] 個 Node -> 需要『倒數第三個 Node』-> "last node 的前 [2] 個"
	- ->*需要 Traverst to Node "n" previous to last node* -> **Slow Pointer**
- Augment Head
	- 由於 FastPtr 需要先往後走 n 個位置
	- 爲了符合『只有 head 一個 node 的時候也可以產生 FastPtr / SlowPtr 位置差距』 -> 新增一個 AugmentHead
	- 後續 Slow / Fast Ptr 都從 Augment Head 開始走
	- **再來就是有 Augment Head 比較好處理 delete node 的情況**
		- 可以避免執行中判斷各種 head 被刪掉的情況
		- 不論原本的 head 是否被刪除，最後回傳 AugmentHead 的下一個 node 一定是正確的 new list head
			- origin head 被刪除: AugmentHead 的下一個 node 是 new head (origin head 的下一個)
			- origin head 沒刪除: AugmentHead 的下一個 node 是 origin head
		- **注意：augment Head 是實體 temp variable Node，回傳時要用 augmenthead.next (不要用 augmenthead->next)**

執行流程
- Augment Head
	- 在原本 node 前面加一個 augment head node
- 初始化兩個 Pointer
	- Fast Ptr: 從 augment head 開始，最後要走到 TailNode
	- Slow Ptr: 從 augment head 開始，最後要走到 TargetNode 的前面 -> *位在 TailNode 往前 n 的位置*
- 把 Fast / Slow Ptr 拉開距離
	- Fast Ptr: 往後走 n 個 node
		- 途中如果還沒走 n 個 node 就到達 tail node
		- -> *代表 list 不夠長沒辦法 tail 往前刪除 n-th node*
		- -> *直接回傳 head (代表沒有 node 被刪除)*
	- Slow Ptr: 維持不動
- 開始 Traverse
	- Fast Ptr: 往後走到 last valid node
	- slow Ptr: 同步往後走
- 刪除 Node
	- slow Ptr 的下一個 node 要刪除: slowPtr->next = slowPtr->next->next;
- 回傳結果
	- 如果 slow Ptr 位在 AugmentHead: 代表 Head 被刪除 -> 回傳 AugmentHead 的下一個 node
	- 如果 slow Ptr 不在 AugmentHead: 代表 Head 是原本 -> 回傳 AugmentHead 的下一個 node

## V2 - Naming 比較直觀，寫法也比較簡化
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return head;

        ListNode* aheadNode = head;
        while(n--) {
            // if the list node is not sufficient to be deleted
            if(!aheadNode) return head;
            aheadNode = aheadNode->next;
        }

        ListNode augmentHead(0, head);
        ListNode *prevNode=&augmentHead, *curNode=augmentHead.next;
        while(aheadNode) {
            prevNode = curNode;
            curNode = curNode->next;

            aheadNode = aheadNode->next;
        }

        prevNode->next = curNode->next;
        delete curNode;

        return augmentHead.next;
    }
};
```
- **先用 ahead / behind pointer 做出 n 間隔**
- 再同時 ahead / behind pointer 走整個list -> **ahead 走到 null per 的時候，behind pointer 就是 delete node**
	- > **所以還需要一個 prevNode 來記得 delete node 的前一個 node**
- 此外，為了處理 delete first node 的情況，設定一個 augment head

## V3：複習2nd - 模板化寫法
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:
	ListNode* getKthNodeFromStart(ListNode* start, int k) {
		ListNode augmentedHead(0, start);

		int travCnt = 0;
		ListNode *travNode = &augmentedHead;
		while(travNode && (travCnt < k)) {
			travNode = travNode->next;
			travCnt++;
		}
		
		return (travCnt == k) ? (travNode) : (nullptr);
	}
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // augment head
        ListNode augmentedHead(0, head);

        // get (n+1)-th node from end
        // (fast ptr stop at tail valid node)
        // (slow ptr stop at (n) before tail valid node)
        // (1) fast ptr traverse n+1 nodes
        ListNode *fast = getKthNodeFromStart(&augmentedHead, n+1);
        if(!fast) return head;

        // (2) slow / fast ptr traverse at the same time
        // fast node stop at end valid node
        ListNode *slow = &augmentedHead;
        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next;
        }

        // take out target node
        ListNode *takeoutNode = slow->next;
        slow->next = takeoutNode->next;
        takeoutNode->next = nullptr;

        // finish
        return augmentedHead.next;
    }
};
```