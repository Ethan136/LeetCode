# LeetCode
https://leetcode.com/problems/sort-list/description/

# Concept
- **使用 merge sort 的時候，記得要先「把需要 sort 的 sublist1 / sublist2 切斷」**
- sublist1 最後一個 node 往後本來是 sublist2 head -> 切斷，改成連到 nullptr -> **recursive / iteration 都需要**
- sublist2 最後一個 node 和下一段的 sublist1 切斷 -> **只有 iteration 才需要，recursive 不需要**
	- **因為在 recursive 的途中，會逐漸透過 sublist1 / sublist2 切斷，來把整個 list 每個 node 都切開**

# Answer: Iteration 進行 merge sort + 記憶體最佳化 -> 寫法比較複雜
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // check if head is valid & set augmented head
        if(!head) return head;
        ListNode augmentedHead(-1, head);

        // check node total num
        int listLen = 0;
        for(ListNode *curNode = head; curNode; curNode = curNode->next) listLen++;

        // merge sort
        for(int subListNodeCnt = 1; subListNodeCnt < listLen; subListNodeCnt *= 2) {

            // merge lists two by two
            for(ListNode *curNode = &augmentedHead, *curSectionFirstNode = augmentedHead.next, *nextSectionFirstNode = nullptr;
                curSectionFirstNode; curSectionFirstNode = nextSectionFirstNode) {

                // first sub-list
                ListNode *node1 = curSectionFirstNode;

                // second sub-list
                ListNode *node2 = node1, *node2Prev;
                for(int i = 0; (i < subListNodeCnt) && node2; i++) {
                    node2Prev = node2;
                    node2 = node2->next;
                }
                if(!node2) break;

                // disconnect sub-list1 / sub-list2
                node2Prev->next = nullptr;

                // update the 1st node of next merge region
                nextSectionFirstNode = node2;
                ListNode *prevNodeOfNextSection;
                for(int i = 0; (i < subListNodeCnt) && nextSectionFirstNode; i++) {
                    prevNodeOfNextSection = nextSectionFirstNode;
                    nextSectionFirstNode = nextSectionFirstNode->next;
                }

                // disconnect sub-list2 / next section
                prevNodeOfNextSection->next = nullptr;

                // merge list1 & list2
                while(node1 && node2) {
                    ListNode *&pickNode = (node1->val <= node2->val) ? (node1) : (node2);

                    curNode->next = pickNode;
                    curNode = curNode->next;

                    pickNode = pickNode->next;
                }

                // link to the remained list
                curNode->next = (node1) ? (node1) : (node2);

                // traverse to the tail of merged list
                while(curNode->next) curNode = curNode->next;

                // link to the next section
                curNode->next = nextSectionFirstNode;
            }
        }

        return augmentedHead.next;
    }
};
```

# Answer: Recursive 進行 merge sort + 記憶體最佳化 -> 寫法簡單很多
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) return head;

        // find mid point (mid point = slow)
        ListNode *midPrev = nullptr, *mid = head, *fast = mid;
        while(fast && fast->next) {
            midPrev = mid;
            mid = mid->next;
            fast = fast->next->next;
        }

        // split to two lists
        midPrev->next = nullptr;

        // sort each list
        ListNode *node1 = sortList(head);
        ListNode *node2 = sortList(mid);

        // merge l1 & l2
        ListNode augmentedHead(-1, head), *curNode = &augmentedHead;
        while(node1 && node2) {
            ListNode *&pickNode = (node1->val <= node2->val) ? (node1) : (node2);
    
            curNode->next = pickNode;
            curNode = curNode->next;

            pickNode = pickNode->next;
        }
        curNode->next = (node1) ? (node1) : (node2);

        // return merged list
        return augmentedHead.next;
    }
};
```


# Answer：複習2nd - 模板化寫法
## V1: Bottom Up Iteration
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:
    int checkListNodeNum(ListNode* head) {
        ListNode *node = head;
        int travCnt = 0;
        while(node) {
            node = node->next;
            travCnt++;
        }
        return travCnt;
    }

    ListNode* getAtMostKthNodeFromStart(ListNode* start, int k) {
        if(!start) return nullptr;
        ListNode augmentedHead(0, start);

        int travCnt = 0;
        ListNode *node = &augmentedHead;
        while(node->next && (travCnt < k)) {
            node = node->next;
            travCnt++;
        }
        return node;
    }

    bool getKNodeSubListAfter(ListNode* nodePrevToSubList, int k, ListNode *&subListHead, ListNode *&subListTail, ListNode *&nodeAfterSubList) {
        if(!nodePrevToSubList) return false;
        subListHead = nodePrevToSubList->next;

        subListTail = getAtMostKthNodeFromStart(subListHead, k);
        if(!subListTail) return false;

        nodeAfterSubList = subListTail->next;
        return true;
    }

    ListNode*& cmpAndSelectSmallNode(ListNode *&node1, ListNode *&node2) {
        if(!node1) return node2;
        if(!node2) return node1;

        if(node1->val < node2->val) return node1;
        else return node2;
    }

    ListNode* mergeTwoSortedLists(ListNode* list1, ListNode* list2, ListNode*& mergedTail) {
        ListNode augmentMergeHead;
        ListNode *mergedNode = &augmentMergeHead;

        ListNode *node1 = list1;
        ListNode *node2 = list2;
        while(node1 || node2) {

            ListNode *&selectNode = cmpAndSelectSmallNode(node1, node2);
            mergedNode->next = selectNode;

            mergedNode = mergedNode->next;
            selectNode = selectNode->next;
        }

        mergedTail = mergedNode;
        return augmentMergeHead.next;
    }
public:
    ListNode* sortList(ListNode* head) {
        // check node num
        int nodeNum = checkListNodeNum(head);
        if(nodeNum <= 1) return head;

        // merge sort two by two
        ListNode augmentedHead(0, head);
        for(int listNodeNum = 1; listNodeNum < nodeNum; listNodeNum *= 2) {

            //cout << "listNodeNum: " << listNodeNum << endl;
            ListNode *prevOfSortStart = &augmentedHead;
            while(prevOfSortStart) {

                // list1
                ListNode *list1, *list1Tail, *afterList1;
                if(!getKNodeSubListAfter(prevOfSortStart, listNodeNum, list1, list1Tail, afterList1)) break;
                //cout << "list1: " << list1->val << endl;

                // list2
                ListNode *list2 = afterList1, *list2Tail, *afterSortEnd;
                if(!getKNodeSubListAfter(list1Tail, listNodeNum, list2, list2Tail, afterSortEnd)) break;
                //cout << "list2: " << list2->val << endl;

                // cut off list1 & list2
                prevOfSortStart->next = nullptr;
                list1Tail->next = nullptr;
                list2Tail->next = nullptr;

                // sort lsit1 & list2
                ListNode *mergeSortedTail = nullptr;
                ListNode *mergeSortedHead = mergeTwoSortedLists(list1, list2, mergeSortedTail);

                // link mergeSortedList back to origin list
                prevOfSortStart->next = mergeSortedHead;
                mergeSortedTail->next = afterSortEnd;

                // update prevNode of next sort start
                prevOfSortStart = mergeSortedTail;
            }
        }
        
        // finish
        return augmentedHead.next;
    }
};
```

## V2：Top Down Iteration
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:

    ListNode*& cmpAndSelectSmallNode(ListNode *&node1, ListNode *&node2) {
        if(!node1) return node2;
        if(!node2) return node1;

        if(node1->val < node2->val) return node1;
        else return node2;
    }

    ListNode* mergeTwoSortedLists(ListNode* list1, ListNode* list2) {
        ListNode augmentMergeHead;
        ListNode *mergedNode = &augmentMergeHead;

        ListNode *node1 = list1;
        ListNode *node2 = list2;
        while(node1 || node2) {

            ListNode *&selectNode = cmpAndSelectSmallNode(node1, node2);
            mergedNode->next = selectNode;

            mergedNode = mergedNode->next;
            selectNode = selectNode->next;

            if(!node1 || !node2) {
                mergedNode->next = (node1) ? (node1) : (node2);
                break;
            }
        }

        return augmentMergeHead.next;
    }

    ListNode* getMidPointOfList(ListNode* head) {
        if(!head) return head;

        ListNode *slow = head;
        ListNode *fast = head->next;
        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
public:
    ListNode* sortList(ListNode* head) {
        // empty list
        if(!head) return head;

        // if only one node exist
        if(!head->next) return head;

        // get mid point of list
        ListNode *midPoint = getMidPointOfList(head);

        // split list in tow
        ListNode *list1 = head;
        ListNode *list2 = midPoint->next;

        midPoint->next = nullptr;

        // sort two lists separately
        ListNode* sortedList1 = sortList(list1);
        ListNode* sortedList2 = sortList(list2);

        // merge two lists
        return mergeTwoSortedLists(sortedList1, sortedList2);
    }
};
```