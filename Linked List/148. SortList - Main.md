# LeetCode
https://leetcode.com/problems/sort-list/description/

# Concept
- **使用 merge sort 的時候，記得要先「把需要 sort 的 sublist1 / sublist2 切斷」**
- sublist1 最後一個 node 往後本來是 sublist2 head -> 切斷，改成連到 nullptr -> **recursive / iteration 都需要**
- sublist2 最後一個 node 和下一段的 sublist1 切斷 -> **只有 iteration 才需要，recursive 不需要**
	- **因為在 recursive 的途中，會逐漸透過 sublist1 / sublist2 切斷，來把整個 list 每個 node 都切開**

# Answer: Iteration 進行 merge sort + 記憶體最佳化 -> 寫法比較複雜
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // check if head is valid & set augmented head
        if(!head) return head;
        ListNode augmentedHead(-1, head);

        // check node total num
        int listLen = 0;
        for(ListNode *curNode = head; curNode; curNode = curNode->next) listLen++;

        // merge sort
        for(int subListNodeCnt = 1; subListNodeCnt < listLen; subListNodeCnt *= 2) {

            // merge lists two by two
            for(ListNode *curNode = &augmentedHead, *curSectionFirstNode = augmentedHead.next, *nextSectionFirstNode = nullptr;
                curSectionFirstNode; curSectionFirstNode = nextSectionFirstNode) {

                // first sub-list
                ListNode *node1 = curSectionFirstNode;

                // second sub-list
                ListNode *node2 = node1, *node2Prev;
                for(int i = 0; (i < subListNodeCnt) && node2; i++) {
                    node2Prev = node2;
                    node2 = node2->next;
                }
                if(!node2) break;

                // disconnect sub-list1 / sub-list2
                node2Prev->next = nullptr;

                // update the 1st node of next merge region
                nextSectionFirstNode = node2;
                ListNode *prevNodeOfNextSection;
                for(int i = 0; (i < subListNodeCnt) && nextSectionFirstNode; i++) {
                    prevNodeOfNextSection = nextSectionFirstNode;
                    nextSectionFirstNode = nextSectionFirstNode->next;
                }

                // disconnect sub-list2 / next section
                prevNodeOfNextSection->next = nullptr;

                // merge list1 & list2
                while(node1 && node2) {
                    ListNode *&pickNode = (node1->val <= node2->val) ? (node1) : (node2);

                    curNode->next = pickNode;
                    curNode = curNode->next;

                    pickNode = pickNode->next;
                }

                // link to the remained list
                curNode->next = (node1) ? (node1) : (node2);

                // traverse to the tail of merged list
                while(curNode->next) curNode = curNode->next;

                // link to the next section
                curNode->next = nextSectionFirstNode;
            }
        }

        return augmentedHead.next;
    }
};
```

# Answer: Recursive 進行 merge sort + 記憶體最佳化 -> 寫法簡單很多
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) return head;

        // find mid point (mid point = slow)
        ListNode *midPrev = nullptr, *mid = head, *fast = mid;
        while(fast && fast->next) {
            midPrev = mid;
            mid = mid->next;
            fast = fast->next->next;
        }

        // split to two lists
        midPrev->next = nullptr;

        // sort each list
        ListNode *node1 = sortList(head);
        ListNode *node2 = sortList(mid);

        // merge l1 & l2
        ListNode augmentedHead(-1, head), *curNode = &augmentedHead;
        while(node1 && node2) {
            ListNode *&pickNode = (node1->val <= node2->val) ? (node1) : (node2);
    
            curNode->next = pickNode;
            curNode = curNode->next;

            pickNode = pickNode->next;
        }
        curNode->next = (node1) ? (node1) : (node2);

        // return merged list
        return augmentedHead.next;
    }
};
```