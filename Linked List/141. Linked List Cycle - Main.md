---
ParentTask:
  - "[[linked_list]]"
---

# LeetCode

[141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

# Answer: slow 從 0 開始 / fast 從 1 開始
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {

		// fast / slow pointer
        ListNode *slow = head, *fast = head;

		// traverse until fast pointer reaches tail node or end null
        while(fast && fast->next) {

			// traverse first
            fast = fast->next->next;
            slow = slow->next;

			// then check if fast & slow are overlapped
            if(slow == fast) return true;
        }
        return false;
    }
};
```
需要注意
- **Fast / Slow 都是從 Head 開始走**
	- 一開始兩個會重合
	- 要先 traverse 再檢查是否 fast = slow
	- 如果先檢查 fast = slow 才開始 traverse -> **在初始條件 fast = slow 的情況下，兩個直接重合回傳 true**
- **另外一種做法: slow 從 head 開始走，fast 從 head->next 開始走**
	- 不過這種做法要 traverse 到 slow = head 可能會需要比較久的時間

# Answer: slow / fast 都從 0 開始
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        while(fast) {
            if(!fast->next || !fast->next->next) break;
            slow = slow->next;
            fast = fast->next->next;

            if(slow && fast && (slow == fast)) return true;
        }
        return false;
    }
};
```
- **因為 slow / fast 起始點相同，所以必須先 traverse，再比對 node address**