---
ParentTask:
  - "[[linked_list]]"
---

# LeetCode
[23. Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

# Concept
**Merge two lists 的時候，再選擇 node1 / node2 加入 merged list 的時候，可以善用「reference to pointer」 -》 **寫法會簡潔很多**
```Cpp
                // merge two lists
                ListNode augmentHead, *mergedNode = &augmentHead;
                while(node1 && node2) {

                    // use reference to pick node1 or node2
                    ListNode *&pickNode = (node1->val <= node2->val) ? (node1) : (node2);

                    // get the node next to the picked one
                    ListNode *pickNodeNext = pickNode->next;

                    // add to merged list
                    mergedNode->next = pickNode;

                    // traverse to newly merged node
                    mergedNode = pickNode;
    
                    // node1 or node2 traverse to the next one
                    pickNode = pickNodeNext;
                }

                // link to the remained list
                mergedNode->next = (node1) ? (node1) : (node2);
```

# Answer1 - Merge Sort - O(n x logK)
## V1 - Merge by Two Pointer: list[i] + list[j]
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
#define DEBUG (0)
#if DEBUG
void printList(string title, ListNode* head) {
    cout<<title<<endl;
    while(head) { cout<<head->val<<" "; head=head->next; }
    cout<<endl;
}
#else
#define printList(dummy1, dummy2)
#endif
class Solution {
private:
    ListNode* mergeTwoSortedLists(ListNode* list1, ListNode* list2) {
        ListNode augmentHead, *curNode = &augmentHead;
        printList("merge list1",list1);
        printList("merge list2",list2);
        while(list1&&list2) {
            int val1=list1->val;
            int val2=list2->val;
            if(val1<val2) {
                curNode->next=list1;
                list1=list1->next;
            }
            else {
                curNode->next=list2;
                list2=list2->next;
            }
            curNode=curNode->next;
        }
        if(!list1) curNode->next=list2;
        if(!list2) curNode->next=list1;
        printList("merge finish",augmentHead.next);
        return augmentHead.next;
    }
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // check lists number
        int RemainListNum=lists.size();
        if(!RemainListNum) return NULL;

        // merge the list and stor in the input vector
        while(RemainListNum>1) {

            for(int i=0, j=RemainListNum-1;
                i<j;
                i++, j--, RemainListNum--) {
#if DEBUG
cout<<"-----remain list num "<<RemainListNum<<"-----"<<endl;
cout<<"i "<<i<<" | j "<<j<<endl;
#endif
                lists[i]=mergeTwoSortedLists(lists[i],lists[j]);
            }
        }

        // the finally merged list was stored in index 0 of input vector
        return lists[0];
    }
};
```
Complexity
- O(n x logK)
- n = total node num
- k = num of lists

Merge Sort 做法
- 把『任兩個同樣長度的 List 兩兩合併』 -> 直到最後剩下一個 List
- 先記錄一開始有幾個 list -> remain list num = lists.size()
- 合併方式『使用 two pointer』
	- 取得 lists[i]: 從 vector left  開始拿 list
	- 取得 lists[j]: 從 vector right 開始拿 list
	- 合併機制 list[i] + list[j] -> list[i] = list1 / list[j] = list2
		- 先生成一個 augment head 作爲 sorted list 的頭
		- 接着從 list1 / list2 挑選比較小的放到 sorted list
			- 然後 list1 / list2 traverse to next node
		- 一旦 list1 或 list2 traverse to end
			- 結束 two list compare
			- 把另外一個還沒 traverse 完畢的 list 剩餘部分接到 sorted list 後面
		- 最後回傳 augment head.next
	- 合併後存到 lists[i]
		- 合併一次把 remain list num--
		- 如果是奇數個 list，則最中間的 list 不會在這一輪被合併

## V2 - Merge by Two Pointer: list[i] + list[j]
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        // if there's no list at all
        if(lists.empty()) return nullptr;
        
        // list number to be merged
        int listNum = lists.size();

        // merge all lists until only one remained
        while(listNum > 1) {

            // the merged list reduce cnt
            int listMergeReduceCnt = 0;

            // merge lists two pointer
            for(int i = 0, j = listNum-1; i < j; i++, j--) {

                // get two lists
                ListNode *node1 = lists[i];
                ListNode *node2 = lists[j];

                // merge two lists
                ListNode augmentHead, *mergedNode = &augmentHead;
                while(node1 && node2) {

                    // use reference to pick node1 or node2
                    ListNode *&pickNode = (node1->val <= node2->val) ? (node1) : (node2);

                    // get the node next to the picked one
                    ListNode *pickNodeNext = pickNode->next;

                    // add to merged list
                    mergedNode->next = pickNode;

                    // traverse to newly merged node
                    mergedNode = pickNode;
    
                    // node1 or node2 traverse to the next one
                    pickNode = pickNodeNext;
                }

                // link to the remained list
                mergedNode->next = (node1) ? (node1) : (node2);

                // record the merged list
                lists[i] = augmentHead.next;

                // update the list reduce cnt by merge
                listMergeReduceCnt++;
            }

            // update list num
            listNum -= listMergeReduceCnt;
        }

        // return the merge result
        return lists[0];

    }
};
```
## V2 - Merge by two-two: list[i] + list[i+1]
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        // if there's no list at all
        if(lists.empty()) return nullptr;
        
        // list number to be merged
        int listNum = lists.size();

        // merge all lists until only one remained
        while(listNum > 1) {

            // the list num after merge
            int listNumAfterMerge = 0;

            // merge lists two by two
            for(int i = 0; i < listNum; i+=2) {

                // get two lists
                ListNode *node1 = lists[i];
                ListNode *node2 = ((i+1) < listNum) ? lists[i+1] : nullptr;

                // merge two lists
                ListNode augmentHead, *mergedNode = &augmentHead;
                while(node1 && node2) {

                    // use reference to pick node1 or node2
                    ListNode *&pickNode = (node1->val <= node2->val) ? (node1) : (node2);

                    // get the node next to the picked one
                    ListNode *pickNodeNext = pickNode->next;

                    // add to merged list
                    mergedNode->next = pickNode;

                    // traverse to newly merged node
                    mergedNode = pickNode;
    
                    // node1 or node2 traverse to the next one
                    pickNode = pickNodeNext;
                }

                // link to the remained list
                mergedNode->next = (node1) ? (node1) : (node2);

                // record the merged list
                lists[listNumAfterMerge++] = augmentHead.next;
            }

            // update list num
            listNum = listNumAfterMerge;
        }

        // return the merge result
        return lists[0];

    }
};
```
- **注意：因為是 list[i] 和 list[i+1] 合併，i 一次跳兩格 -> 儲存 merged list 的時候，不能用 index i -> ***要用 listNumAfterMerge**
- 注意：這個寫法在「list num 奇數的時候，仍然會試著 merge middle list
	- node1 = middle list
	- node2 = nullptr
	- 兩個 merge 完仍然是 middle list 存到 lists 裡面原本的位置

# Answer2 - MinHeap - O(n x logK)
## V1 - 基本寫法
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        // create a heap to store the min nodes of each lists
        auto cmpGreater = [](ListNode const* a, ListNode const *b) {return (a->val > b->val);};
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmpGreater)> minNodeHeap;

        // pus the smallest node of each list to the heap
        for(auto headNode : lists) {
            if(headNode) minNodeHeap.push(headNode);
        }

        // create a head for sort-merged list
        ListNode AugmentHead;
        ListNode *selectedNode = &AugmentHead;

        // in each term, get the smallest node from heap
        // and push the next node of it (next smallest in the list) into the heap
        while(!minNodeHeap.empty()) {

            // get the un-sorted smallest node of all the lists
            ListNode* minNodeInHeap = minNodeHeap.top();
            minNodeHeap.pop();

            // link the node to the sorted list
            selectedNode->next = minNodeInHeap;

            // the sorted list traverse to the latest node
            selectedNode = minNodeInHeap;

            // put the next smallest node of the list into the heap
            if( minNodeInHeap->next ) minNodeHeap.push(minNodeInHeap->next);
        }

        return AugmentHead.next;
    }
};
```

Complexity
- O(n x logK)
- n = total node num
- k = num of lists

使用 minHeap 合併 List
- minHeap
	- 裝每個 List『un-sorted node 裏面最小的（而且一定是 Valid Node）』
	- 初始化的時候從每個 list 裏面取 『valid head』 放到 minHeap
	- *valid head 才能做 compare，如果是 NULL head 則跳過*

- augment head 作爲 sorted list head

- 執行 while loop 直到 minHeap = empty -> *代表沒有 un-sorted node*
	- 每次從 minHeap 取一個 node 出來
		- *這個 node 就是尚未 sorted node 裏面最小的*
		- 這個 node 直接接到 sorted list 尾端
	- 如果這個 node->next 存在
		- -> **代表這個 node 所屬的 list 還沒 sort 完畢**
		- 把這個 list 尚未 sort 部分的 min node 放到 minHeap -> 也就是把 node->next 放到 minHeap

- 最後回傳 augment head.next

## V2 - 複習時候寫的，稍微簡化內容
```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        // if there's no list at all
        if(lists.empty()) return nullptr;
        
        // min heap of list node
        auto cmpListNode = [](ListNode* &a, ListNode* &b) {return a->val > b->val;};
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmpListNode)> minNodeHeap;

        // push all list head to min heap
        for(ListNode *head : lists) {
            if(!head) continue;
            minNodeHeap.push(head);
        }

        // pick node from heap and push next node to heap to do merge
        ListNode augmentedHead, *mergedNode = &augmentedHead;
        while(minNodeHeap.size()) {
            mergedNode->next = minNodeHeap.top();
            mergedNode = mergedNode->next;

            minNodeHeap.pop();
            if(mergedNode->next) minNodeHeap.push(mergedNode->next);
        }

        // return the merged list
        return augmentedHead.next;
    }
};
```