# LeetCode
[238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

# Solution
## V1 - Additional Vector for NumMultiply Before & After
```Cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> LeftSideMultpy(nums.size(),1);
        for(int i = 1; i < nums.size(); i++) {
            LeftSideMultpy[i] *= (LeftSideMultpy[i-1]*nums[i-1]);
        }

        vector<int> RightSideMultpy(nums.size(),1);
        for(int i = nums.size()-2; i >= 0; i--) {
            RightSideMultpy[i] *= (RightSideMultpy[i+1]*nums[i+1]);
        }

        vector<int> result(nums.size(), 1);
        for(int i = 0; i < nums.size(); i++) {
            result[i] = LeftSideMultpy[i] * RightSideMultpy[i];
        }
        return result;
    }
};
```
- 造兩個 Array，分別為
	- LeftSideMultpy = nums 裡面 index i 左側所有元素乘積
	- RightSideMultpy = nums 裡面 index i 右側所有元素乘積
- 解答為
	- nums 裡面 index i 以外元素乘積 = LeftSideMultpy[i] x RightSideMultpy[i]

## V2 - Additional O(1) space for Multiply Prefix & Suffix
- 用一個 prefix 變數從 index 1 to end 記錄 「index 0 to end-1 的數值相乘，並且同步更新 index 1 to end 的「左乘積」
- 用一個 suffix 變數從 index end-1 to 0 記錄 「index end to 1 的數值相乘，並且同步更新 index end-1 to 0 的「右乘積」
```Cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        // result
        vector<int> result(nums.size(), 1);

        // left multiply & skip self num
        int prefix = 1;
        for(int i = 1; i < result.size(); i++) {
            prefix *= nums[i - 1];
            result[i] *= prefix;
        }

        // right multiply & skip self num
        int postFix = 1;
        for(int i = (int)(result.size()) - 2; i >= 0; i--) {
            postFix *= nums[i + 1];
            result[i] *= postFix;
        }

        return result;
    }
};
```