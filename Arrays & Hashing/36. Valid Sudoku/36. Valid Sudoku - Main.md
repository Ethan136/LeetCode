# LeetCode
[36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

# Solution
## V1 - Bitmap
```C
#define BIT(N)  (1<<(N))
#define REC_ELEMENT(REC_DOUBLE_ARRAY, ROW, COL) REC_DOUBLE_ARRAY[ROW/3][COL/3]
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rowCntBmp[9] = {};
        int colCntBmp[9] = {};
        int recCntBmp[3][3] = {{},{}};

        for(int r = 0; r < 9; r++) {
            for(int c = 0; c < 9; c++) {
                if(board[r][c] == '.') continue;

                int BitValueOfPosition = BIT(board[r][c]-'0');
                int BitValueOfChecked = ( rowCntBmp[r] | colCntBmp[c] | REC_ELEMENT(recCntBmp,r,c) );
                if(BitValueOfPosition & BitValueOfChecked) return false;

                rowCntBmp[r] |= BitValueOfPosition;
                colCntBmp[c] |= BitValueOfPosition;
                REC_ELEMENT(recCntBmp,r,c) |= BitValueOfPosition;
            }
        }
        return true;
    }
};
```
- 目標：檢查是否『每個Row』、『每個Col』、『每個方型區域』都是只有唯一的 1-9
- 建立三種 Check BitMap
	- Row 1-9 的 Check BitMap
	- Col 1-9 的 Check BitMap
	- 方型區域 1-9 的 Check Bitmap
- Check BitMap 的用途
	- 一旦檢查到 Board 上面某個元素不為 empty -> 把上面三種 Check BitMap 登記『這個元素的數值』
- 執行機制
	- 檢查每個 row / col 的元素
	- 一旦這個元素的數值是不為 Empty -> 檢查這個元素在三種 Check BitMap 是否登記過
		- 有登記過 -> 重複的元素 -> invalid board
		- 沒登記過 -> 沒重複元素 -> 繼續檢查
	- 如果檢查通過所有的 row / col -> valid board


## V2 - Bitmap with better expression
```Cpp
#define BIT(N)  (1 << (N))
#define CHECK_BIT_FROM_NUM_CHAR(VAL, NUM_CHAR)   (VAL & BIT((NUM_CHAR - '0')))
#define SET_BIT_FROM_NUM_CHAR(VAL, NUM_CHAR)     (VAL |= BIT((NUM_CHAR - '0')))

#define CHAR_EMPTY  ('.')
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rowNumBitMap[9] = {};
        int colNumBitMap[9] = {};
        int blkNumBitMap[3][3] = {};

        for(int r = 0; r < board.size(); r++) {
            
            for(int c = 0; c < board[r].size(); c++) {
                // if grid empty
                if(board[r][c] == CHAR_EMPTY) continue;

                // if grid with invalid char
                if(board[r][c] < '1' || board[r][c] > '9') return false;

                // if the current num had been registered on the row
                if(CHECK_BIT_FROM_NUM_CHAR(rowNumBitMap[r], board[r][c])) return false;

                // if the current num had been registered on the col
                if(CHECK_BIT_FROM_NUM_CHAR(colNumBitMap[c], board[r][c])) return false;

                // if the current num had been registered on the block
                if(CHECK_BIT_FROM_NUM_CHAR(blkNumBitMap[r/3][c/3], board[r][c])) return false;

                // register the num of row / col / block
                SET_BIT_FROM_NUM_CHAR(rowNumBitMap[r], board[r][c]);
                SET_BIT_FROM_NUM_CHAR(colNumBitMap[c], board[r][c]);
                SET_BIT_FROM_NUM_CHAR(blkNumBitMap[r/3][c/3], board[r][c]);
            }
        }
        return true;
    }
};
```