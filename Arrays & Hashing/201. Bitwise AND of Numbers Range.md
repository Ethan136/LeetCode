# Concept
這道題目的解法核心意義在於：尋找 left 和 right 在二進制表示下的「最長公共前綴」（Longest Common Prefix）。
以下詳細說明這個概念及其背後的邏輯：
## 核心邏輯：為什麼是「公共前綴」？
當我們將區間 [left, right] 內的所有數字進行 Bitwise AND（按位與） 運算時，結果取決於這些數字在二進制上的共同特徵。
 * 連續數字的特性
	 * 數字是連續遞增的（如 9, 10, 11, 12...）。在二進制中，加 1 的操作會導致低位元（右側）頻繁翻轉（0 變 1，1 變 0），並向高位元（左側）進位。
 - 差異的意義
	 - 如果 left 和 right 在某個高位元（左側）不同，這意味著在這個區間內，該位元發生了變化（從 0 變成了 1）。
	 - 既然該位元在區間內既出現過 0 也出現過 1，那麼所有數字進行 AND 運算後，該位元的結果一定是 0。
	 - 更重要的是，如果一個較高的位元發生了變化，那麼該位元右邊的所有低位元在這個過程中一定都經歷過 0 和 1 的完整循環。因此，這些低位元的 AND 結果也全部為 0。

結論
- 最終的結果，就是 left 和 right 二進制中左邊完全相同的部分（公共前綴），其餘右邊的部分全部補 0。

## NeetCode 解法的具體意義
意義：
* 將 left 和 right 同時向右移（丟棄低位元），直到兩者相等。這一步是為了過濾掉右邊所有不同的位元，只保留相同的公共前綴。
* 記錄移動了多少次（shift）。
* 最後將保留下來的公共前綴向左移回 shift 位（右邊補 0），還原成原本的數值大小。
* 直觀理解：把「不相同」的尾巴切掉，剩下的頭就是答案，然後再把尾巴補成 0。

總結
這個解法的意義在於看透了 Bitwise AND 在連續數列上的性質：只要高位不同，低位必為 0。因此，問題從「對一堆數字做運算」轉化為簡單的「找兩個數字的共同頭部」。


# Answer 1st
```Cpp
class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {

        // record the bit shift cnt
        int bitShiftCnt = 0;

        // find the pivot common part of left & right
        while(left != right) {
            left = (left >> 1);
            right = (right >> 1);
            bitShiftCnt++;
        }

        // restore the pivot common part to it's origin bit
        return (left << bitShiftCnt);
    }
};
```