---
ParentTask:
  - "[[arrays_and_hashing]]"
---

# LeetCode
[912. Sort an Array](https://leetcode.com/problems/sort-an-array/)

## MergeSort 在 Array 需要額外空間，LinkList 則不用
簡單來說：**是的，如果不宣告 `temp`（輔助陣列），要寫出「時間複雜度合格」的 Array Merge Sort 是非常困難的。**

雖然「In-Place Merge Sort（原地合併排序）」在學術上存在，但在 LeetCode 或面試實戰中，我們通常**強烈不建議**這樣做。

以下為你分析為什麼「不宣告 temp」會讓問題變得這麼棘手：

---

### 1. 為什麼標準 Merge Sort 需要 `temp`？

Merge Sort 的核心動作是「合併」兩個**已經排好序**的子陣列，例如：

* 左邊：`[2, 5, 8]`
* 右邊：`[3, 6, 9]`

當我們要合併這兩組時，必須比較 `2` 和 `3`。

* `2` 比較小，放在第一個位置（沒問題）。
* 接著比較 `5` 和 `3`，`3` 比較小，應該放在第二個位置。

**這裡就是問題所在：**
原本陣列的第二個位置放的是 `5`。如果你直接把 `3` 寫進去（In-place），`5` 就會被覆蓋掉（消失了）。為了不弄丟 `5`，你必須把它往後挪。

如果為了省空間而不開 `temp`，你就必須頻繁地「搬移元素」。

---

### 2. 硬要「不宣告 temp」的兩種後果

如果你堅持不使用額外空間，通常會掉入以下兩種情況之一：

#### 情況 A：犧牲時間 (會導致 TLE)

最簡單的 In-Place 方法類似於 **Insertion Sort** 的邏輯。當右邊的元素比左邊小時，將左邊剩餘的元素全部「往右推一格」，把右邊那個元素插進來。

* **後果：** 搬移元素是  的動作。
* **總複雜度：** Merge Sort 原本是 ，加上搬移後會退化成 ****。
* **LeetCode 結果：** 這一題 ，用  解法會直接 **Time Limit Exceeded (超時)**。

#### 情況 B：寫法極度複雜 (Block Merge Sort)

有一些高階演算法（如 *Block Merge Sort* 或 *GrailSort*）可以達成  空間且保持  時間。

* **原理：** 利用陣列內部的一小塊區域當作緩衝區，進行極其複雜的交換操作。
* **後果：** 程式碼量會暴增 3~5 倍，邏輯極其難懂，面試時幾乎不可能在 40 分鐘內寫對。

---

### 3. 特例：Linked List 不需要 temp

值得一提的是，如果題目是 **Sort List (LeetCode 148)**，也就是對 Linked List 進行 Merge Sort，那麼**不需要** `temp` 空間。

因為 Linked List 只要改變指標 (Pointer) 的指向就能插入元素，不需要搬移資料，所以 Linked List 的 Merge Sort 天生就是  空間（不計遞迴堆疊）。

---

### 4. 總結建議

針對 **LeetCode 912 (Sort an Array)** 這題：

1. **如果不介意空間 ：** 請乖乖宣告 `temp` 陣列（或 Python 的 Slice），這是最標準、最不容易寫錯的解法。
2. **如果面試官限制空間 ：** 這時候**不要用 Merge Sort**。請改用 **Heap Sort (堆積排序)**，它天生就是  時間且  空間（In-Place）。

**結論：** 用 Array 做 Merge Sort 時，宣告 `temp` 是為了用「空間換取時間」；如果不宣告，要嘛變很慢，要嘛變超級難寫。


## MergeSort / HeapSort / QuickSort 比較 -> 如果只會 MergeSort 是否可行
**結論是：不會直接因為「只會 Merge Sort」就被刷掉，但你可能會在「追問環節」失去加分機會。**

只要你能寫出 Bug-free 的 Merge Sort（像你剛剛寫的那樣），在 LeetCode 912 這類題目上你是**及格**的，甚至能拿到不錯的分數，因為：

1. **時間複雜度合格：**  是排序題的標準要求。
2. **穩定性 (Stability)：** Merge Sort 是穩定的，這點在某些應用場景下比 Quick Sort 和 Heap Sort 更有優勢。
3. **最差情況保證：** Merge Sort 不會像 Quick Sort 那樣因為選錯 Pivot 而退化成 。

---

### 但為什麼面試官可能會覺得「還不夠」？

如果你只會 Merge Sort，遇到以下三種「追問 (Follow-up)」，你會比較危險：

#### 1. 空間複雜度的限制

* **面試官問：** 「你的解法用了  的額外空間（temp 陣列），如果我的記憶體非常有限（Embedded System 或海量數據），能不能優化成 ？」
* **你的處境：** Merge Sort 的  版本極難寫（Block Merge Sort）。這時候標準答案其實是 **Heap Sort**（或者可接受  stack 空間的 Quick Sort）。
* **解套方法：** 如果你不會寫 Heap Sort，至少要**口頭說出**：「我知道 Merge Sort 需要  空間，如果是空間敏感的場景，我會選擇 Heap Sort 來達到 In-place ，或是 Quick Sort。」（展現你的知識廣度）。

#### 2. 實際效能的比較 (Quick Sort vs Merge Sort)

* **面試官問：** 「雖然理論上都是 ，為什麼 C++ STL 的 `std::sort` 預設是用 Quick Sort (Introsort) 而不是 Merge Sort？」
* **你的處境：** 這是在考計算機結構觀念。
* **答案關鍵：**
* **Cache Locality (快取局部性)：** Quick Sort 是原地交換，記憶體存取通常是連續的，Cache Hit Rate 高。Merge Sort 需要頻繁拷貝到 `temp` 再拷貝回來，對 Cache 較不友善。
* **常數項 (Constant Factor)：** Quick Sort 在實作上的常數因子比 Merge Sort 小，所以平均跑起來比較快。



#### 3. 特殊數據分佈

* **面試官問：** 「如果這個陣列已經『幾乎排好序』了，哪種排序最快？」
* **答案：** Insertion Sort (這時候是 )。Merge Sort 依然會傻傻地切分再合併，還是 。

---

### 給你的生存策略 (Survival Guide)

如果你不想背那麼多程式碼，只想專精 Merge Sort，請務必把以下 **「話術」** 記熟，面試時就能化險為夷：

1. **承認空間缺點，提出替代方案：**
> "我選擇 Merge Sort 是因為它穩定且最差情況也有保證。我知道它需要  空間，如果記憶體受限，我會改用 Heap Sort。" (即使你當下寫不出來，這句話證明你有觀念)


2. **強調穩定性 (Stability)：**
> "如果是排序物件（Object），且需要多重條件排序（例如先排分數、再排名字），Merge Sort 的穩定性非常重要，這是 Quick Sort 做不到的。"


3. **知道 Quick Sort 的弱點：**
> "Quick Sort 雖然平均比較快，但在最差情況（Pivot 選不好）會退化成 ，且不穩定。所以我優先實作更保險的 Merge Sort。"



### 總結

* **只會 Merge Sort 寫 LeetCode：** ✅ 沒問題，絕對能過。
* **只會 Merge Sort 去面試：** ⚠️ 有風險。

**建議：**
你不需要練到能「秒寫」Heap Sort 或 Quick Sort，但你一定要**看懂它們的邏輯**，並且能夠比較這三者的優缺點表。

**需要幫你整理一張「排序演算法比較表 (面試作弊單)」讓你背起來嗎？**


# Answer 1st
## MergeSort
```Cpp
class Solution {
private:
    void sortArray(auto &nums, int startIdx, int endIdx, auto &tempVec) {
        // check valid range
        if(startIdx >= endIdx) {
            return;
        }

        // divide and conquer
        int midIdx = startIdx + (endIdx - startIdx) / 2;
        int startIdx2 = midIdx+1;
        sortArray(nums, startIdx, midIdx, tempVec);
        sortArray(nums, startIdx2, endIdx, tempVec);

        // sort and store in temp vector
        for(int t = startIdx, i = startIdx, j = startIdx2; t <= endIdx; t++) {

            // if one of the sub-vector used up
            if((i > midIdx) || (j > endIdx)) {
                int &targetIdx = (i <= midIdx) ? (i) : (j);
                tempVec[t] = nums[ targetIdx++ ];
            }
            // sub-vector1[i] <= sub-vector2[j]
            else if(nums[i] <= nums[j]) {
                tempVec[t] = nums[i++];
            }
            // sub-vector1[i] > sub-vector2[j]
            else {
                tempVec[t] = nums[j++];
            }
        }

        // paste the sorted temp vector back to origin one
        for(int i = startIdx; i <= endIdx; i++) {
            nums[i] = tempVec[i];
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        vector<int> tempVec(nums.size());
        sortArray(nums, 0, nums.size()-1, tempVec);
        return nums;
    }
};
```
