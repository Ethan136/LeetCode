---
ParentTask:
  - "[[arrays_and_hashing]]"
---

# LeetCode
[706. Design HashMap](https://leetcode.com/problems/design-hashmap/)

核心概念詳見 [[705. Design HashSet - Main]]
# Answer
```Cpp
#define HASH_LIST_NUM   (813)
class MyHashMap {
private:
    struct ListNode {
        ListNode* next = nullptr;
        int key = 0;
        int val = 0;
    };

    ListNode m_hashListHead[HASH_LIST_NUM];

private:
    ListNode* getAugmentListHead(int key) {
        return &m_hashListHead[key % HASH_LIST_NUM];
    }
    ListNode* getPrevNodeOfKey(int key) {
        ListNode* prev = getAugmentListHead(key);
        ListNode* node = prev->next;

        while(node) {
            if(node->key == key) return prev;
            prev = node;
            node = node->next;
        }
        return nullptr;
    }

public:
    MyHashMap() {
        
    }
    
    void put(int key, int value) {
        // [if key exist]
        ListNode *prevNodeOfKey = getPrevNodeOfKey(key);
        if(prevNodeOfKey) {
            // update value
            prevNodeOfKey->next->val = value;
            return;
        }

        // [if key does not exist]
        // insert after head
        prevNodeOfKey = getAugmentListHead(key);

        // create new node
        ListNode *newNode = new ListNode();
        newNode->key = key;
        newNode->val = value;

        // new node insert to list
        ListNode *nextNode = prevNodeOfKey->next;
        prevNodeOfKey->next = newNode;
        newNode->next = nextNode;
    }
    
    int get(int key) {
        ListNode *prevNodeOfKey = getPrevNodeOfKey(key);
        return (prevNodeOfKey) ? (prevNodeOfKey->next->val) : (-1);
    }
    
    void remove(int key) {
        // check if key exist
        ListNode *prevNodeOfKey = getPrevNodeOfKey(key);
        if(!prevNodeOfKey) return;

        // get nodes related
        ListNode *node = prevNodeOfKey->next;
        ListNode *nextNode = node->next;

        // remove node from list
        delete node;
        prevNodeOfKey->next = nextNode;
    }
};
```
