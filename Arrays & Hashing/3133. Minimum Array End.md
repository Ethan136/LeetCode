# Concept
和 [[201. Bitwise AND of Numbers Range]] 比較說明

這道題目 Minimum Array End (LeetCode 3133) 的解法邏輯與前一題（Bitwise AND of Numbers Range）恰好是相反的思維過程。
前一題是「給定範圍，求這些數字的共同特徵（AND）」；這題是「給定共同特徵（AND）和數量，反推構造出範圍中最後一個數字」。

以下說明這題的解法意義，並進行比較。
## 1. Minimum Array End 的解法意義

### 題目核心要求
你需要構造一個長度為 n 的遞增陣列，使得所有元素的 Bitwise AND 結果等於 x。目標是讓這個陣列的最後一個數字（最大值）盡可能小。
核心邏輯：填空題 (Bit Filling)
為了讓所有數字 AND 起來等於 x，陣列中的每一個數字必須滿足：
 * 繼承 x 的 1：如果 x 的某個位元是 1，那麼陣列中所有數字的該位元必須都是 1（否則 AND 之後該位元會變成 0）。
 * 自由發揮 x 的 0：如果 x 的某個位元是 0，陣列中的數字可以在該位元填 0 或 1。這就是我們可以利用來創造「遞增」和「不同數字」的空間。

### 演算法思路
我們要把這題想像成將 n-1 的二進制數值，塞進 x 的空位（0 的位置）裡。
 * 為什麼是 n-1？
   陣列第一個數一定是 x 本身（最小）。我們還需要構造剩下的 n-1 個數。為了讓最後一個數最小，我們相當於是在 x 的基礎上，利用那些「位元 0」的位置來計數，數到第 n-1 個。
 * 如何操作？
   我們將 x 看作一個模版。
   * x 中為 1 的位元：鎖定，不能動。
   * x 中為 0 的位元：空位，用來依序填入 n-1 的二進制位元。

### 舉例：
設 n = 3, x = 4 (二進制 100)。
我們需要構造 3 個數，還需要再造 n-1 = 2 個數。
2 的二進制是 10。
 * x 的二進制：1 0 0 (第 2 位鎖定為 1，第 0, 1 位是空位)
 * n-1 的二進制：1 0
 * 填空過程：
   * 拿 n-1 的最低位 0 -> 填入 x 的第 0 位（空位）。
   * 拿 n-1 的次低位 1 -> 填入 x 的第 1 位（空位）。
 * 結果：1 1 0 (十進制 6)。
所以陣列會是 [4, 5, 6]，AND 結果是 4，最後一個數字是 6。

## 2. 與「Bitwise AND of Numbers Range」的比較

這兩題在思考方向上是互逆的：

| 特徵 | 前一題 (Bitwise AND Range) | 這一題 (Minimum Array End) |
|---|---|---|
| 輸入 | 一個連續區間 [left, right] | AND 的結果 x 和數量 n |
| 輸出 | 這些數字的 AND 結果 | 構造出的序列之最後一個數字 |
| 核心操作 | 做減法 / 找交集 | 做加法 / 填空隙 |
| 邏輯方向 | 由多變少：給定一堆變動的數字，問什麼東西是不變的？ | 由少變多：給定不變的特徵（x），如何變出最多的數字？ |
| 對位元的處理 | 消除差異：只要位元有變化（0變1），該位元結果就歸零。 | 保留特徵並填充：保留 x 的 1，把 n-1 的值塞進 x 為 0 的縫隙裡。 |
| 結果大小 | 結果 \le left | 結果 \ge x |
| 比喻 | 給你一堆不同顏色的樂高積木，問它們哪裡長得一樣？（找公共前綴） | 給你一個固定的樂高底座，要你在上面加蓋積木，蓋出第 n 種造型。（在空位填值） |
## 總結
 * 前一題 (Range AND) 告訴我們：連續數字的 AND 運算會抹除低位元的差異，只保留公共前綴。
 * 這一題 (Min Array End) 告訴我們：要在保持 AND 結果不變的前提下構造遞增數字，我們只能操作那些原本是 0 的低位元，把計數器（n-1）的位元「映射」到這些空位上。

# Answer 1st： Brute Force
```Cpp
class Solution {
public:
    long long minEnd(int n, int x) {

        // init maxNum as the least num in array
        long long maxNumTry = x;

        // the remain cnt in array
        int needNumCnt = (n-1);
        while(needNumCnt) {
            // try add one and OR to must required base bit num
            maxNumTry = ((maxNumTry + 1) | x);

            // reduce the need cnt
            needNumCnt--;
        }

        // finish
        return maxNumTry;
    }
};
```

# Answer 1st： Optimal - 把 (n-1) 填入 x 空白的 bits 裡面
```Cpp
class Solution {
public:
    long long minEnd(int n, int x) {

        // least num must be x
        int leastNum = x;

        // init max num as least num
        long long maxNum = leastNum;

        // fill (n-1) in the bit0 parts sparsely in the bits of x
        int useBitOfX = 0;
        int remainBitPartsToFill = (n-1);
        while(remainBitPartsToFill) {

            // find empty bit in X
            while( ((long long)1 << useBitOfX) & x) {
                useBitOfX++;
            }

            // fill the bit of n into empty bit of x
            maxNum |= ((long long)(remainBitPartsToFill & 1) << useBitOfX);

            // reduce the remained bits to fill
            remainBitPartsToFill = (remainBitPartsToFill >> 1);

            // try next bit of X
            useBitOfX++;
        }

        // finish
        return maxNum;
    }
};
```