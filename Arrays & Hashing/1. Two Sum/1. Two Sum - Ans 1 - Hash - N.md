---
Algorithm:
  - Hash
  - Array
---
# 概念
- 如果 A + B = target -> 則 A 的補數 = B -> B = target - A
- 每個掃過的 num 建立一個 value to index map
- 利用 map 搜尋「key 和 value 都是 O(1) 的特性」，來檢查「某個 num 是否出現過」 
  -> 這個「某個 num，就可以是**當前正在檢查的 num 的補數**」

# V1
```Cpp
class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		unordered_map<int, int> numMap; // value -> index
		
		for(int i = 0; i < nums.size(); i++) {
			int complement = target - nums[i];
			
			// Check if complement exists in the map
			if(numMap.count(complement)) {
				return {numMap[complement], i};
			}
			
			// Add current number and its index to the map
			numMap[nums[i]] = i;
		}
		
		return {}; // This line will never be reached due to problem constraints
	}
};
```
- 使用 Map 來做快速解答
- Map 新增東西的時候直接指派 Map[Key] = Value

# V2 - Review
```Cpp
class Solution {
private:
    struct idxValPair {
        int originIdx;
        int value;
    };
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // the complement value of each num (target - num) -> idx of num
        // {num, index of num}
        unordered_map<int, int> numToIdxMap;

        // check each num and find if 
        // "the complement of any num can be created by the other num = target"
        for(int i = 0; i < nums.size(); i++) {
            // calc complement of current value
            int complement = target - nums[i];

            // if the complement of current number is recorded other num
            // -> current num + other num = target
            if(numToIdxMap.count(complement)) return {numToIdxMap[complement], i};

            // add current num to map
            numToIdxMap.insert({nums[i], i});
        }

        // if can't find the solution
        return {};
    }
};
```
