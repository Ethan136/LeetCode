
# LeetCode
[347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

# Answer V1 - 1st Write
```Cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> numCntMap;

        for(auto &num : nums) {

            if(!numCntMap.count(num)) {
                numCntMap[num] = 1;
            }
            else {
                numCntMap[num]++;
            }

        }
     
        vector<pair<int,int>> numCntPairVect(numCntMap.begin(), numCntMap.end());
        sort(numCntPairVect.begin(), numCntPairVect.end(),
            [](const auto& a, const auto& b) {
                return a.second > b.second;
            });

        vector<int> result;
        for(int i = 0; i < k; i++) {
            result.push_back(numCntPairVect[i].first);
        }

        return result;
    }
};
```
- 先用一個 Map 紀錄每個元素出現幾次
- 然後再把 Map 裡面的 Pair 丟到一個 vector -> vector 依照『pair 裡面紀錄的元素出現次數進行排序』
	- vector<pair<int, int>>
	- pair<int, int> 本身是 Map 裡面的元素單位，可以獨立拿來使用
	- sort(vect.begin(), vect.end(), compare_func)
		- compare_func 格式: \[\](const auto& a, const auto&b) {return a.second > b.second;}
		- compare func 預期是輸入 pair<int, int>
		- compare func 裡面 true 的情況『代表 a 排在 b 前面』 -> 這邊由大到小排序
		- 而 pair<int, int> 裡面的 key = first / value = second
- vector<pair<int,int>> 經過 sort 後
	- 裡面的 pair 會依照『元素出現次數排序』
- 這時候再依照題目需求把『出現次數最高的 1-K 個整理到一個 vector』
	- vector<pair<int,int>> 裡面前 0 to (k-1) 個 pair.key 就是所需的答案

# Answer V2
## Review 1st
```Cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> numToOccurTimesMap;
        for(int num : nums) numToOccurTimesMap[num]++;

        vector<pair<int, int>> numToOccurTimesVec;
        for(auto &numToTimesPair : numToOccurTimesMap) numToOccurTimesVec.push_back(numToTimesPair);

        auto cmpMoreTimes = [](pair<int, int> &a, pair<int, int> &b) { return a.second > b.second; };
        sort(numToOccurTimesVec.begin(), numToOccurTimesVec.end(), cmpMoreTimes);

        vector<int> result(k);
        for(int i = 0; i < result.size(); i++) result[i] = numToOccurTimesVec[i].first;

        return result;
    }
};
```

## Review 2nd
```Cpp
class Solution {
private:
    struct numCnt_t {
        int num;
        int cnt;
    };
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> numCntMap;
        for(int num : nums) numCntMap[num]++;

        vector<numCnt_t> numCntVec; numCntVec.reserve( numCntMap.size() );
        for(auto [num, cnt] : numCntMap) numCntVec.push_back( {num, cnt} );

        auto sortNumCnt = [](auto &a, auto &b) {
            return a.cnt > b.cnt;
        };
        sort(numCntVec.begin(), numCntVec.end(), sortNumCnt);

        vector<int> result(k);
        for(int i = 0; i < k; i++) result[i] = numCntVec[i].num;
        return result;
    }
};
```
# Answer V3 - Bucket Sort
- **O(n) Complexity，但需要額外分配記憶體，反而會讓速度下降**
- **要考慮「某個出現次數下，有多個數字的情況，例如 2, 3 都是出現 10次，這種情況」

```Cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> numToOccurTimesMap;
        for(int num : nums) numToOccurTimesMap[num]++;

        vector<vector<int>> occurTimesToNumVec(nums.size() + 1);
        for(auto &numToTimesPair : numToOccurTimesMap) {
            int occurTimes = numToTimesPair.second;
            int num = numToTimesPair.first;
            occurTimesToNumVec[ occurTimes ].push_back( num );
        }

        vector<int> result(k);
        int resultNum = 0;

        for(int i = occurTimesToNumVec.size()-1; i > 0; i--) {
            if(occurTimesToNumVec[i].empty()) continue;
            for(int j = 0; (j < occurTimesToNumVec[i].size()) && (resultNum < k); j++) {
                result[resultNum++] = occurTimesToNumVec[i][j];
            }
        }
        return result;
    }
};
```