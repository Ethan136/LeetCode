---
ParentTask:
  - "[[arrays_and_hashing]]"
---

# LeetCode
[75. Sort Colors](https://leetcode.com/problems/sort-colors/)

# Answer 1st
## 自己想到的做法
```Cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        if(nums.size() <= 1) return;

        int lastIdx = nums.size() - 1;
        int cnt0 = 0;
        int cnt2 = 0;
        int cnt1 = 0;

        for(int i = 0; (cnt0 + cnt1 + cnt2) < nums.size(); ) {

            if(nums[i] == 0) {
                swap(nums[i], nums[cnt0]);
                cnt0++;
                i++;
                continue;
            }
            if(nums[i] == 2) {
                swap(nums[i], nums[lastIdx - cnt2]);
                cnt2++;
                continue;
            }
            else {
                cnt1++;
                i++;
                continue;
            }
        }
    }
};
```

## 正規解法：ThreePointer 荷蘭國旗做法
### 0. Code
```Cpp

// NOTE: 這邊 Three Pointer 分別是 store0Idx, i (檢查中的) , store2Idx
class Solution {
public:
    void sortColors(vector<int>& nums) {
        if(nums.size() <= 1) return;

        // before store 0
        int store0Idx = 0;

        // after store 2
        int store2Idx = nums.size()-1;

        for(int i = 0; i <= store2Idx; ) {

            if(nums[i] == 0) {
                swap(nums[i], nums[store0Idx]);
                store0Idx++;
                i++;
                continue;
            }
            if(nums[i] == 2) {
                swap(nums[i], nums[store2Idx]);
                store2Idx--;
                continue;
            }
            else {
                i++;
                continue;
            }
        }
    }
};
```

這就是最標準、最優化的解法了！你已經完全掌握了這個問題的核心。

這段程式碼的核心概念稱為 **「三路劃分」（3-Way Partitioning）**，也可以形象地理解為 **「雙邊夾擠」** 策略。

我們可以把你的變數看作是劃分疆域的界線，我幫你拆解這三個關鍵變數所代表的物理意義：

### 1. 疆域劃分（Invariants）

在迴圈進行的任何時刻，你的變數維護著以下三個區域：

* **`store0Idx` 的左邊（不含本身）**：全是 **0**。
* 這條線負責「把 0 鎖在左邊」。


* **`store2Idx` 的右邊（不含本身）**：全是 **2**。
* 這條線負責「把 2 鎖在右邊」。


* **`i` (當前掃描線)**：
* 從 `store0Idx` 到 `i` 之間（即掃描過但沒被換走的）全是 **1**。



### 2. 運作邏輯解析

這個寫法最精妙的地方在於它如何處理交換後的狀態，特別是 **0** 和 **2** 的差異：

#### **情況 A：遇到 0 (紅色)**

```cpp
swap(nums[i], nums[store0Idx]);
store0Idx++;
i++; 

```

* **動作**：把現在看到的 0 丟到左邊的 `store0Idx` 位置。
* **為什麼 `i` 可以前進？**
* 因為 `i` 永遠在大於等於 `store0Idx` 的位置掃描。
* 這意味著 `store0Idx` 指向的位置，要嘛是目前的 `i`（剛開始時），要嘛是**已經被 `i` 掃描過的 1**。
* 所以從左邊換回來的數字**一定是 1**，我們不需要再檢查它，可以直接繼續看下一個 (`i++`)。



#### **情況 B：遇到 2 (藍色)**

```cpp
swap(nums[i], nums[store2Idx]);
store2Idx--;
// 注意：這裡沒有 i++

```

* **動作**：把現在看到的 2 丟到右邊的 `store2Idx` 位置。
* **為什麼 `i` 不能前進？**
* 因為從右邊 (`store2Idx`) 換過來的那個數字是**未知數**（我們還沒掃描到那裡，它可能是 0、1 或 2）。
* 所以 `i` 必須停在原地，下一輪迴圈要重新檢查這個剛換過來的新客人。



#### **情況 C：遇到 1 (白色)**

```cpp
i++;

```

* **動作**：什麼都不做，只是路過。
* **效果**：這會讓 `store0Idx` 落後於 `i`。這兩者中間的空隙，自然就留給了 1。

### 總結圖象化

想像你在整理一排球：

1. **`store0Idx`** 是一面往右推的牆，牆左邊都是紅球 (0)。
2. **`store2Idx`** 是一面往左推的牆，牆右邊都是藍球 (2)。
3. **`i`** 是你的手，拿著球看。

你一路往右走，如果是紅球就丟到左牆後（左牆右移），如果是藍球就丟到右牆後（右牆左移），如果是白球就不動。最後兩面牆碰頭時，紅球在左，藍球在右，剩下的白球自然就被夾在中間了。

這就是  時間複雜度、 空間複雜度的完美解法。恭喜你寫出來了！