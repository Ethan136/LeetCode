---
LeetCodeLv: Medium
Algorithm:
  - Hash
  - Array
  - String
---



LeetCode Locked -> 解 NeetCode
https://neetcode.io/problems/string-encode-and-decode?list=neetcode150

# Conecpt
- 把 「Str Length + Special 識別字元」作為一個 Heeader
- 而「String 本身」作為一個 Body
- **關鍵在於：要如何把 origin str len 和 origin str 兩個部分塞在一起，但後續右能拆分** -> **在 str len 和 origin str 之間，放入「識別字元」**
	- 解析但時候，一律先抓數字，直到抓到識別字元，作為 string len
- encode 後的 string 會是 ][Header0\] \[Body0\] + \[Header1\] \[Body1\] ...

# Warning
- String 相關操作要加強
	- string to num: stoi()
	- num to string: to_string()
	- sub string: substr()

# Answer
## V1 - 直接轉換
- forloop 裡面檢查 encoded string 每個字元
- 每一次 Loop 都直接「處理完一個 string」
- 寫法比較簡單
```Cpp
class Solution {
public:

    string encode(vector<string>& strs) {
        string result = "";
        for(auto &str: strs) {
            result += (to_string(str.size()) + "#" + str);
        }
        return result;
    }

    vector<string> decode(string s) {
        vector<string> result;
        for(int i = 0; i < s.size(); ) {

            // read { [1234] $ str }
            int strLen = 0;
            for(; s[i] != '#'; i++) {
                strLen = (strLen * 10 + (s[i] - '0'));
            }

            // read { 1234 [$] str }
            i++;

            // read { 1234 $ [str] }
            result.push_back( s.substr(i, strLen) );
            i += strLen;
        }

        return result;
    }
};
```

## V2 - 使用狀態機
- forloop 裡面檢查 encoded string 每個字元
- 每一次 Loop 只檢查一個 char
- 需要透過狀態機來維護，比較多 corner case，寫法比較複雜

```Cpp
#define ENCODE_STR_LEN_START_CHAR   ('#')
#define ENCODE_STR_LEN_END_CHAR     ('!')
class Solution {
    enum eDECODE_STATE {
        FIND_STR_LEN_START_CHAR,
        FIND_STR_LEN_PROCESS,
        DECODE_STR
    };
public:

    string encode(vector<string>& strs) {
        string encodedStr = "";

        for(string &str : strs) encodedStr += (ENCODE_STR_LEN_START_CHAR + to_string(str.size()) + ENCODE_STR_LEN_END_CHAR + str);
        cout << encodedStr << endl;
        return encodedStr;
    }

    vector<string> decode(string s) {
        vector<string> result;

        eDECODE_STATE decodeState = FIND_STR_LEN_START_CHAR;
        int strLenStartIdx, strLenDigitNum, strStartIdx, strLen = 0;

        for(int i = 0; i < s.size(); ) {
            switch(decodeState) {
            case FIND_STR_LEN_START_CHAR:
                if(s[i++] != ENCODE_STR_LEN_START_CHAR) {
                    continue;
                }

                // fall through to next state
                decodeState = FIND_STR_LEN_PROCESS;
                strLenDigitNum = 0;
                strLenStartIdx = i;

            case FIND_STR_LEN_PROCESS:
                if(s[i++] != ENCODE_STR_LEN_END_CHAR) {
                    strLenDigitNum++;
                    continue;
                }

                // fall through to next state
                decodeState = DECODE_STR;
                strStartIdx = i;

            case DECODE_STR:
                strLen = stoi(s.substr(strLenStartIdx, strLenDigitNum));
                result.push_back(s.substr(strStartIdx, strLen));

                decodeState = FIND_STR_LEN_START_CHAR;
                i += strLen;
                break;
            }
        }

        return result;
    }
};
```