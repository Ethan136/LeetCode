---
ParentTask:
  - "[[arrays_and_hashing]]"
---

# LeetCode
[705. Design HashSet](https://leetcode.com/problems/design-hashset/)

## 題目概念
這題 **LeetCode 705. Design HashSet** 是一道經典的「設計類」題目。它不考你用現成的 `std::set` (C++) 或 `set` (Python)，而是要你**造輪子**，藉此考察你對 Hash Table（雜湊表）底層原理的理解。

以下為你整理這題的核心概念、解題策略，以及面試時的通過標準。

---

### 1. 核心概念：什麼是 Hash Set？

Hash Set 的目標是儲存一組**不重複**的元素，並支援以下三個操作，且理想情況下時間複雜度應為 ：

1. `add(key)`: 加入元素。
2. `remove(key)`: 移除元素。
3. `contains(key)`: 檢查元素是否存在。

#### 關鍵挑戰：雜湊與衝突 (Hashing & Collision)

由於記憶體有限，我們無法為無限大的整數範圍準備無限大的陣列。我們需要一個 **Hash Function** 將輸入的數字（Key）映射到一個較小的陣列索引範圍（Index）。

當兩個不同的 Key 經過 Hash Function 算出相同的 Index 時，就發生了**衝突 (Collision)**。這題的重點就在於**你如何解決衝突**。

---

### 2. 解題策略：兩種常見解法

在面試中，通常會經歷從「暴力解」優化到「正規解」的過程。

#### 方法一：超大陣列法 (Boolean Array) - 僅適用於特定限制

若是 LeetCode 這題（題目限制 ），你可以開一個大小為  的 Boolean 陣列。

* `add(key)`: `arr[key] = true`
* `remove(key)`: `arr[key] = false`
* **評價**：這是「投機」的解法。雖然速度快 ()，但在面試中這通常被視為 **Bad Practice**，因為若 Key 的範圍變成  (Long Long)，這招就直接讓記憶體爆掉 (Memory Limit Exceeded)。

#### 方法二：拉鍊法 (Separate Chaining) - 面試標準解法

這是最通用的工業級實作方式。

1. **主結構**：建立一個固定大小的陣列（Buckets），例如大小為 （通常選質數以減少衝突）。
2. **Hash Function**：使用 Modulo 運算 `Index = key % size`。
3. **衝突處理**：每個 Bucket 不只存一個數，而是存一個 **Linked List** (或是動態陣列)。如果多個 Key 算出來是同一個 Index，就將它們掛在這個 Bucket 的 List 後面。

**邏輯示意 (Python 風格):**

```python
class MyHashSet:
    def __init__(self):
        self.size = 1000
        # 建立 1000 個桶子，每個桶子是一個 List
        self.buckets = [[] for _ in range(self.size)]

    def _hash(self, key):
        return key % self.size

    def add(self, key):
        index = self._hash(key)
        bucket = self.buckets[index]
        if key not in bucket: # 避免重複
            bucket.append(key)

    def remove(self, key):
        index = self._hash(key)
        bucket = self.buckets[index]
        if key in bucket:
            bucket.remove(key)

    def contains(self, key):
        index = self._hash(key)
        bucket = self.buckets[index]
        return key in bucket

```

---

### 3. 面試需要做到哪個程度？

在面試中，這題的通過標準分為三個層次。你需要根據面試官的引導和剩餘時間來決定做到哪一層。

#### Level 1: 及格線 (Intern / Junior)

* **做到：** 使用「拉鍊法 (Separate Chaining)」做出來。
* **細節：** 能夠定義 `Bucket` 結構（如 `vector<list<int>>`），並正確處理 `Key % Size`。
* **回答：** 能解釋為什麼不用超大陣列（空間浪費）。

#### Level 2: 優秀線 (Mid / Senior)

* **做到：** 除了實作，必須主動分析**時間複雜度**與**空間複雜度**。
* **關鍵對話：**
* **Q:** 為什麼查詢是 ？
* **A:** 平均情況下是 。但在最差情況下（所有 Key 都衝突撞在一起），會退化成 （遍歷 Linked List）。
* **Q:** 如何避免退化？
* **A:** 選擇好的 Hash Function (讓分佈均勻) 和適當的 Bucket Size (通常是質數)。



#### Level 3: 加分項 (Tech Lead / System Design Angle)

如果題目很快解完，面試官可能會追問或讓你優化：

1. **Rehashing (擴容)**：當元素數量超過 Bucket 數量的一定比例（Load Factor，例如 0.75）時，你會怎麼做？（答案：建立兩倍大的陣列，把所有元素重新 Hash 搬過去，以維持  效率）。
2. **替代方案**：除了 Linked List，Bucket 裡還能放什麼？（答案：如果衝突極多，Bucket 內部可以升級成 **BST (Binary Search Tree)** 或 **Red-Black Tree**，讓最差搜尋從  優化成 。Java 的 `HashMap` 就是這樣做的）。

---

### 4. 總結與建議

**面試應對腳本：**

1. **先確認範圍**：問面試官 Key 的範圍多大？
2. **提出方案**：「雖然這題範圍小可以用大陣列，但為了通用性，我想實作 **Separate Chaining (拉鍊法)**。」
3. **實作細節**：
* 選定 Bucket 數量（如 1000 或 769）。
* Hash Function 用 Modulo。
* 處理 `add` 時記得檢查 `contains` 以防重複。



**C++ 實作者的小提示：**
在 C++ 中，你可以直接使用 `std::vector<std::list<int>>` 來實作。這樣可以省去手寫 Linked List Node 的時間，將重點放在 Hash 的邏輯上。

---

**下一步建議：**
你想試著用 C++ 寫出 **Level 2** 等級（包含 `vector` 和 `list` 應用）的完整代碼給我看嗎？我可以幫你 Code Review 其中的語法細節。


這是一個非常經典的面試題與演算法設計觀念。

使用質數（Prime Number）作為 Hash Table 的容量（Capacity），核心原因在於**「最大化地打散數據，減少碰撞（Collision）」**，特別是當**數據具有特定規律**的時候。

簡單來說：**質數能充當一個「攪拌器」，破壞數據原本的規律。**

以下用一個具體的例子與數學原理來解釋：


## 爲何 HashTag 用質數
### 1. 具體例子：當數據有規律時

假設你的 Hash Function 很簡單，就是 `key % N`（這也是你在 LeetCode 這題用的寫法）。
現實世界中的數據往往不是隨機的，而是有規律的（例如：記憶體位址通常是 4 或 8 的倍數、ID 編號可能是 10 的倍數）。

#### 情況 A：使用合數 (Composite Number) 作為容量

假設容量 （8 不是質數，是 ）。
假設進來的 Key 剛好都是 **4 的倍數**（4, 8, 12, 16, 20...）。

計算 Index：
- $4 \% 8 = 4$
- $8 \% 8 = 0$
- $12 \% 8 = 4$
- $16 \% 8 = 0$
- $20 \% 8 = 4$

**結果**：所有的數據只會落在 Index `0` 和 `4` 這兩個位置上。
**慘況**：Hash Table 只有 25% 的空間被利用，其他 75%（1, 2, 3, 5, 6, 7）全是空的。這會導致在這兩個 Bucket 上的 Linked List 非常長，查詢效率從  退化成 。

---

#### 情況 B：使用質數 (Prime Number) 作為容量

假設我們選一個附近的質數，容量 。
同樣進來的 Key 是 **4 的倍數**（4, 8, 12, 16, 20...）。

計算 Index：
- $4 \% 7 = 4$
- $8 \% 7 = 1$
- $12 \% 7 = 5$
- $16 \% 7 = 2$
- $20 \% 7 = 6$

**結果**：數據落在 `4, 1, 5, 2, 6...`。
**優勢**：即使數據有很強的規律（都是 4 的倍數），因為質數 7 與 4 **互質（Coprime）**，數據被均勻地散佈到了各個 Bucket 中。

### 2. 數學原理：最大公因數 (GCD)

這背後的數學原理與 **最大公因數 (Greatest Common Divisor, GCD)** 有關。

當我們計算 `index = key % N` 時，如果 Key 的變化具有某種步長（Step），例如 Key 是 （上面的例子步長 ）：

* **如果  與  有公因數**（GCD > 1）：Hash Index 會在特定的幾個格子裡循環，無法覆蓋整個陣列。
* **如果  是質數**：質數除了 1 和自己以外沒有因數。這意味著， 與大多數的 （只要  不是  的倍數）都會是**互質**的。

因為互質，數據會盡可能地「繞行」過整個陣列的每一個位置後才會開始重複，這就是所謂的**均勻雜湊（Uniform Hashing）**。

### 3. 什麼時候質數特別重要？

質數的重要性取決於你的 **Hash Function** 有多複雜：

1. **簡單的 Hash Function (如本題)**：
如果你直接用 `key % table_size`，或者 key 本身規律性很強，那麼**使用質數是必須的**，這是最後一道防線。
2. **複雜的 Hash Function (如 MurmurHash, SHA)**：
如果你在取餘數之前，已經用很強的演算法把 key 的 bits 攪得亂七八糟（Avalanche Effect），那麼 table_size 是否為質數就不那麼重要了（這也是為什麼 Java 的 HashMap 為了優化位元運算，容量選擇用 ，但它內部有一個擾動函數來處理規律）。

### 結論

在 LeetCode 這種需要手寫簡單 HashMap 的題目中，因為我們通常不會去寫很複雜的 Bit mixing 函數，直接依賴 `key % size`，所以**選擇一個質數作為容量，是 CP 值最高、最簡單能避免碰撞的優化手段。**


# Answer 1st
## Brute Force
```Cpp
class MyHashSet {
private:
    bool m_HastData[1000001] = {};
public:
    MyHashSet() {
        
    }
    
    void add(int key) {
        m_HastData[key] = true;
    }
    
    void remove(int key) {
        m_HastData[key] = false;
    }
    
    bool contains(int key) {
        return m_HastData[key];
    }
};

```


## Hash Map with Prime Number
```Cpp
#define HASH_VEC_SIZE   (813)
class MyHashSet {
private:
    struct ListNode {
        ListNode* next = nullptr;
        int val = 0;
    };
private:
    // length in prime number
   ListNode m_hashList[HASH_VEC_SIZE];

    ListNode& getHashListAugHead(int key) {
        return m_hashList[key % HASH_VEC_SIZE];
    }

    ListNode* getPrevNodeOfKey(int key) {
        // get augmented head
        ListNode &augHead = getHashListAugHead(key);

        // traverse to last valid list
        ListNode* prevNode = &augHead;
        ListNode* node = augHead.next;
        while(node) {
            if(node->val == key) return prevNode;
            prevNode = node;
            node = node->next;
        }

        // key does not exist
        return nullptr;
    }
public:
    MyHashSet() {
        
    }
    
    void add(int key) {
        // if key is exist
        if(getPrevNodeOfKey(key)) return;

        // if key does not exist -> add new key next to augmented head
        ListNode &augHead = getHashListAugHead(key);
        ListNode *nextNode = augHead.next;

        // create new node
        ListNode* newNode = new ListNode();
        newNode->val = key;

        // link new node after head
        augHead.next = newNode;

        // link remianed nodes after new one
        newNode->next = nextNode;
    }
    
    void remove(int key) {
        // traverse to last valid list
        ListNode* prevNode = getPrevNodeOfKey(key);

        // if key does not exist
        if(!prevNode) return;

        // node of key
        ListNode *node = prevNode->next;

        // get next node
        ListNode* nextNode = node->next;

        // delete node of key
        delete node;

        // link prev to next node
        prevNode->next = nextNode;
    }
    
    bool contains(int key) {
        return getPrevNodeOfKey(key) != nullptr;
    }
};
```